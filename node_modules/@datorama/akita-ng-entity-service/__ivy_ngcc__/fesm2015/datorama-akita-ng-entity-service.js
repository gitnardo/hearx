import { isFunction, isObject, isNumber, isString, EntityService, isDefined } from '@datorama/akita';
import { Subject, throwError } from 'rxjs';
import { Injectable, defineInjectable, InjectionToken, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { filter, map, tap, catchError, finalize } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
import * as ɵngcc0 from '@angular/core';
const HttpMethod = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
    PATCH: 'PATCH',
    DELETE: 'DELETE',
};
/** @type {?} */
const ofType = (/**
 * @param {?} type
 * @return {?}
 */
(type) => filter((/**
 * @param {?} action
 * @return {?}
 */
(action) => action.type === type)));
/** @type {?} */
const filterMethod = (/**
 * @param {?} method
 * @return {?}
 */
(method) => filter((/**
 * @param {?} action
 * @return {?}
 */
(action) => action.method === method)));
/** @type {?} */
const filterStore = (/**
 * @param {?} name
 * @return {?}
 */
(name) => filter((/**
 * @param {?} action
 * @return {?}
 */
(action) => action.storeName === name)));
class NgEntityServiceNotifier {
    constructor() {
        this.dispatcher = new Subject();
        this.action$ = this.dispatcher.asObservable();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        this.dispatcher.next(event);
    }
}
NgEntityServiceNotifier.ɵfac = function NgEntityServiceNotifier_Factory(t) { return new (t || NgEntityServiceNotifier)(); };
NgEntityServiceNotifier.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgEntityServiceNotifier, factory: NgEntityServiceNotifier.ɵfac, providedIn: 'root' });
/** @nocollapse */ NgEntityServiceNotifier.ngInjectableDef = defineInjectable({ factory: function NgEntityServiceNotifier_Factory() { return new NgEntityServiceNotifier(); }, token: NgEntityServiceNotifier, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgEntityServiceNotifier, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgEntityServiceNotifier.prototype.dispatcher;
    /** @type {?} */
    NgEntityServiceNotifier.prototype.action$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgEntityServiceLoader {
    constructor() {
        this.dispatcher = new Subject();
        this.loading$ = this.dispatcher.asObservable();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        this.dispatcher.next(event);
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    loadersFor(name) {
        /** @type {?} */
        const filterStore = filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ storeName }) => (name ? storeName === name : true)));
        /** @type {?} */
        const filterMethod = (/**
         * @param {?} mthd
         * @return {?}
         */
        mthd => filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ method }) => {
            return isFunction(mthd) ? mthd(method) : method === mthd;
        })));
        /** @type {?} */
        const actionBased = (/**
         * @param {?} current
         * @return {?}
         */
        (current) => this.loading$.pipe(filterStore, filterMethod(current), map((/**
         * @param {?} action
         * @return {?}
         */
        action => action.loading))));
        /** @type {?} */
        const idBased = (/**
         * @param {?} id
         * @param {?} mthd
         * @return {?}
         */
        (id, mthd) => this.loading$.pipe(filterStore, filterMethod(mthd), filter((/**
         * @param {?} action
         * @return {?}
         */
        action => action.entityId === id)), map((/**
         * @param {?} action
         * @return {?}
         */
        action => action.loading))));
        return {
            get$: actionBased(HttpMethod.GET),
            add$: actionBased(HttpMethod.POST),
            update$: actionBased((/**
             * @param {?} method
             * @return {?}
             */
            method => method === HttpMethod.PUT || method === HttpMethod.PATCH)),
            delete$: actionBased(HttpMethod.DELETE),
            getEntity: (/**
             * @param {?} id
             * @return {?}
             */
            (id) => idBased(id, HttpMethod.GET)),
            updateEntity: (/**
             * @param {?} id
             * @return {?}
             */
            (id) => idBased(id, (/**
             * @param {?} method
             * @return {?}
             */
            method => method === HttpMethod.PUT || method === HttpMethod.PATCH))),
            deleteEntity: (/**
             * @param {?} id
             * @return {?}
             */
            (id) => idBased(id, HttpMethod.DELETE))
        };
    }
}
NgEntityServiceLoader.ɵfac = function NgEntityServiceLoader_Factory(t) { return new (t || NgEntityServiceLoader)(); };
NgEntityServiceLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgEntityServiceLoader, factory: NgEntityServiceLoader.ɵfac, providedIn: 'root' });
/** @nocollapse */ NgEntityServiceLoader.ngInjectableDef = defineInjectable({ factory: function NgEntityServiceLoader_Factory() { return new NgEntityServiceLoader(); }, token: NgEntityServiceLoader, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgEntityServiceLoader, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgEntityServiceLoader.prototype.dispatcher;
    /** @type {?} */
    NgEntityServiceLoader.prototype.loading$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NgEntityServiceGlobalConfig() { }
if (false) {
    /** @type {?|undefined} */
    NgEntityServiceGlobalConfig.prototype.baseUrl;
    /** @type {?|undefined} */
    NgEntityServiceGlobalConfig.prototype.httpMethods;
}
/** @type {?} */
const NG_ENTITY_SERVICE_CONFIG = new InjectionToken('NgEntityServiceGlobalConfig');
/** @type {?} */
const defaultConfig = {
    httpMethods: {
        GET: HttpMethod.GET,
        POST: HttpMethod.POST,
        PATCH: HttpMethod.PATCH,
        PUT: HttpMethod.PUT,
        DELETE: HttpMethod.DELETE
    }
};
/**
 * @param {?} target
 * @param {...?} sources
 * @return {?}
 */
function mergeDeep(target, ...sources) {
    if (!sources.length)
        return target;
    /** @type {?} */
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key])
                    Object.assign(target, { [key]: {} });
                mergeDeep(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(target, ...sources);
}
/**
 * @param {?=} config
 * @return {?}
 */
function NgEntityServiceConfig(config = {}) {
    return (/**
     * @param {?} constructor
     * @return {?}
     */
    function (constructor) {
        if (config.baseUrl) {
            constructor['baseUrl'] = config.baseUrl;
        }
        if (config.resourceName) {
            constructor['resourceName'] = config.resourceName;
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} idOrConfig
 * @return {?}
 */
function isID(idOrConfig) {
    return isNumber(idOrConfig) || isString(idOrConfig);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} storeName
 * @param {?} notifier
 * @return {?}
 */
function successAction(storeName, notifier) {
    return (/**
     * @param {?} __0
     * @return {?}
     */
    function ({ payload, method, successMsg }) {
        notifier.dispatch({
            type: 'success',
            storeName,
            payload,
            method,
            successMsg
        });
    });
}
/**
 * @param {?} storeName
 * @param {?} notifier
 * @return {?}
 */
function errorAction(storeName, notifier) {
    return (/**
     * @param {?} __0
     * @return {?}
     */
    function ({ payload, method, errorMsg }) {
        notifier.dispatch({
            type: 'error',
            storeName,
            payload,
            method,
            errorMsg
        });
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const mapResponse = (/**
 * @param {?} config
 * @return {?}
 */
(config) => map((/**
 * @param {?} res
 * @return {?}
 */
res => ((config || {}).mapResponseFn ? config.mapResponseFn(res) : res))));
/**
 * @template S
 */
class NgEntityService extends EntityService {
    /**
     * @param {?} store
     * @param {?=} config
     */
    constructor(store, config = {}) {
        super();
        this.store = store;
        this.config = config;
        this.globalConfig = {};
        this.http = inject(HttpClient);
        this.loader = inject(NgEntityServiceLoader);
        this.notifier = inject(NgEntityServiceNotifier);
        this.globalConfig = inject(NG_ENTITY_SERVICE_CONFIG);
        this.mergedConfig = mergeDeep(defaultConfig, this.globalConfig, config);
        this.dispatchSuccess = successAction(this.store.storeName, this.notifier);
        this.dispatchError = errorAction(this.store.storeName, this.notifier);
    }
    /**
     * @return {?}
     */
    get api() {
        return `${this.baseUrl || this.getConfigValue('baseUrl')}/${this.resourceName}`;
    }
    /**
     * @return {?}
     */
    get resourceName() {
        return this.getConfigValue('resourceName') || this.store.storeName;
    }
    /**
     * @param {?} api
     * @return {?}
     */
    setBaseUrl(api) {
        this.baseUrl = api;
    }
    /**
     * @return {?}
     */
    getHttp() {
        return this.http;
    }
    /**
     * @return {?}
     */
    getConfig() {
        return this.mergedConfig;
    }
    /**
     * @template T
     * @param {?=} idOrConfig
     * @param {?=} config
     * @return {?}
     */
    get(idOrConfig, config) {
        /** @type {?} */
        let url;
        /** @type {?} */
        const isSingle = isID(idOrConfig);
        /** @type {?} */
        const _config = (isSingle ? config : idOrConfig) || {};
        /** @type {?} */
        const method = this.getHttpMethod(HttpMethod.GET);
        if (_config.url) {
            url = _config.url;
        }
        else {
            url = isSingle ? `${this.api}/${idOrConfig}` : this.api;
        }
        this.loader.dispatch({
            method,
            loading: true,
            entityId: isSingle ? idOrConfig : null,
            storeName: this.store.storeName
        });
        return (/** @type {?} */ (this.http[method.toLowerCase()](url, _config).pipe(mapResponse(_config), tap((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            if (isSingle) {
                this.store.upsert((/** @type {?} */ (idOrConfig)), data);
            }
            else {
                if (_config.append) {
                    this.store.add(data);
                }
                else if (_config.upsert) {
                    this.store.upsertMany(data);
                }
                else {
                    this.store.set(data);
                }
            }
            this.dispatchSuccess({
                method,
                payload: data,
                successMsg: _config.successMsg
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => this.handleError(method, error, _config.errorMsg))), finalize((/**
         * @return {?}
         */
        () => {
            this.loader.dispatch({
                method,
                loading: false,
                storeName: this.store.storeName
            });
        })))));
    }
    /**
     *
     * Add a new entity - Creates a POST request
     *
     * service.add(entity)
     * service.add(entity, config)
     *
     * @template T
     * @param {?} entity
     * @param {?=} config
     * @return {?}
     */
    add(entity, config) {
        /** @type {?} */
        const method = this.getHttpMethod(HttpMethod.POST);
        this.loader.dispatch({
            method,
            loading: true,
            storeName: this.store.storeName
        });
        return (/** @type {?} */ (this.http[method.toLowerCase()](this.resolveUrl(config), entity, config).pipe(mapResponse(config), tap((/**
         * @param {?} entity
         * @return {?}
         */
        (entity) => {
            this.store.add(entity, config);
            this.dispatchSuccess({
                method,
                payload: entity,
                successMsg: config && config.successMsg
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => this.handleError(method, error, config && config.errorMsg))), finalize((/**
         * @return {?}
         */
        () => {
            this.loader.dispatch({
                method,
                loading: false,
                storeName: this.store.storeName
            });
        })))));
    }
    /**
     *
     * Update an entity - Creates a PUT/PATCH request
     *
     * service.update(id, entity)
     * service.update(id, entity, config)
     *
     * @template T
     * @param {?} id
     * @param {?} entity
     * @param {?=} config
     * @return {?}
     */
    update(id, entity, config) {
        /** @type {?} */
        const method = config && config.method ? config.method : this.getHttpMethod(HttpMethod.PUT);
        this.loader.dispatch({
            method,
            loading: true,
            entityId: id,
            storeName: this.store.storeName
        });
        return (/** @type {?} */ (this.http[method.toLocaleLowerCase()](this.resolveUrl(config, id), entity, config).pipe(mapResponse(config), tap((/**
         * @param {?} entity
         * @return {?}
         */
        entity => {
            this.store.update(id, (/** @type {?} */ (entity)));
            this.dispatchSuccess({
                method,
                payload: entity,
                successMsg: config && config.successMsg
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => this.handleError(method, error, config && config.errorMsg))), finalize((/**
         * @return {?}
         */
        () => {
            this.loader.dispatch({
                method,
                loading: false,
                entityId: id,
                storeName: this.store.storeName
            });
        })))));
    }
    /**
     *
     * Delete an entity - Creates a DELETE request
     *
     * service.delete(id)
     * service.delete(id, config)
     *
     * @template T
     * @param {?} id
     * @param {?=} config
     * @return {?}
     */
    delete(id, config) {
        /** @type {?} */
        const method = this.getHttpMethod(HttpMethod.DELETE);
        this.loader.dispatch({
            method,
            loading: true,
            entityId: id,
            storeName: this.store.storeName
        });
        return (/** @type {?} */ (this.http[method.toLowerCase()](this.resolveUrl(config, id), config).pipe(mapResponse(config), tap((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            this.store.remove(id);
            this.dispatchSuccess({
                method,
                payload: res,
                successMsg: config && config.successMsg
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => this.handleError(method, error, config && config.errorMsg))), finalize((/**
         * @return {?}
         */
        () => {
            this.loader.dispatch({
                method,
                loading: false,
                entityId: id,
                storeName: this.store.storeName
            });
        })))));
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    getHttpMethod(type) {
        return this.mergedConfig.httpMethods[type];
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    getConfigValue(key) {
        return this.constructor[key] || this.mergedConfig[key];
    }
    /**
     * @private
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    resolveUrl(config, id) {
        /** @type {?} */
        const customUrl = (config || {}).url;
        if (isDefined(id)) {
            return customUrl || `${this.api}/${id}`;
        }
        return customUrl || this.api;
    }
    /**
     * @private
     * @param {?} method
     * @param {?} error
     * @param {?} errorMsg
     * @return {?}
     */
    handleError(method, error, errorMsg) {
        this.dispatchError({
            method,
            errorMsg,
            payload: error
        });
        return throwError(error);
    }
}
if (false) {
    /** @type {?} */
    NgEntityService.prototype.baseUrl;
    /** @type {?} */
    NgEntityService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.notifier;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.globalConfig;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.mergedConfig;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.dispatchSuccess;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.dispatchError;
    /**
     * @type {?}
     * @protected
     */
    NgEntityService.prototype.store;
    /**
     * @type {?}
     * @private
     */
    NgEntityService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NgEntityServiceParams() { }
if (false) {
    /** @type {?|undefined} */
    NgEntityServiceParams.prototype.baseUrl;
    /** @type {?|undefined} */
    NgEntityServiceParams.prototype.resourceName;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { HttpMethod, NG_ENTITY_SERVICE_CONFIG, NgEntityService, NgEntityServiceConfig, NgEntityServiceLoader, NgEntityServiceNotifier, defaultConfig, errorAction, filterMethod, filterStore, isID, mapResponse, mergeDeep, ofType, successAction };

//# sourceMappingURL=datorama-akita-ng-entity-service.js.map