{"version":3,"sources":["ng://@datorama/akita-ng-entity-service/lib/ng-entity-service-notifier.ts","ng://@datorama/akita-ng-entity-service/lib/ng-entity-service.loader.ts","ng://@datorama/akita-ng-entity-service/lib/ng-entity-service.config.ts","ng://@datorama/akita-ng-entity-service/lib/helpers.ts","ng://@datorama/akita-ng-entity-service/lib/action-factory.ts","ng://@datorama/akita-ng-entity-service/lib/ng-entity.service.ts"],"names":["GET","POST","PUT","PATCH","DELETE","NgEntityServiceNotifier","this","dispatcher","Subject","action$","asObservable","prototype","dispatch","event","next","Injectable","args","providedIn","NgEntityServiceLoader","loading$","loadersFor","name","_this","filterStore","filter","_a","storeName","filterMethod","mthd","method","isFunction","actionBased","current","pipe","map","action","loading","idBased","id","entityId","get$","HttpMethod","add$","update$","delete$","getEntity","updateEntity","deleteEntity","NG_ENTITY_SERVICE_CONFIG","InjectionToken","defaultConfig","httpMethods","mergeDeep","target","sources","_i","arguments","length","source","shift","isObject","key","Object","assign","_b","apply","__spread","isID","idOrConfig","isNumber","isString","successAction","notifier","payload","successMsg","type","errorAction","errorMsg","mapResponse","config","res","mapResponseFn","NgEntityService","store","_super","call","globalConfig","http","inject","HttpClient","loader","mergedConfig","dispatchSuccess","dispatchError","__extends","defineProperty","baseUrl","getConfigValue","resourceName","setBaseUrl","api","getHttp","getConfig","get","url","isSingle","_config","getHttpMethod","toLowerCase","tap","data","upsert","append","add","upsertMany","set","catchError","error","handleError","finalize","entity","resolveUrl","update","toLocaleLowerCase","delete","remove","constructor","customUrl","isDefined","throwError","EntityService"],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\nimport { filter } from 'rxjs/operators';\nimport { Msg } from './types';\n\nexport enum HttpMethod {\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  DELETE = 'DELETE'\n}\n\nexport type ActionType = 'success' | 'error';\n\nexport type EntityServiceAction = {\n  storeName: string;\n  type: ActionType;\n  payload: any;\n  method: HttpMethod;\n} & Msg;\n\nexport const ofType = (type: ActionType) => filter((action: EntityServiceAction) => action.type === type);\n\nexport const filterMethod = (method: HttpMethod | keyof (typeof HttpMethod)) =>\n  filter((action: EntityServiceAction) => action.method === method);\n\nexport const filterStore = (name: string) => filter((action: EntityServiceAction) => action.storeName === name);\n\n@Injectable({ providedIn: 'root' })\nexport class NgEntityServiceNotifier {\n  private dispatcher = new Subject<EntityServiceAction>();\n  action$ = this.dispatcher.asObservable();\n\n  dispatch(event: EntityServiceAction) {\n    this.dispatcher.next(event);\n  }\n}\n","import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\nimport { filter, map } from 'rxjs/operators';\nimport { isFunction } from '@datorama/akita';\nimport { HttpMethod } from './ng-entity-service-notifier';\n\ntype Event = { method: HttpMethod; loading: boolean; storeName: string; entityId?: any };\n\n@Injectable({ providedIn: 'root' })\nexport class NgEntityServiceLoader {\n  private dispatcher = new Subject<Event>();\n  loading$ = this.dispatcher.asObservable();\n\n  dispatch(event: Event) {\n    this.dispatcher.next(event);\n  }\n\n  loadersFor(name?: string) {\n    const filterStore = filter(({ storeName }: Event) => (name ? storeName === name : true));\n    const filterMethod = mthd =>\n      filter(({ method }: Event) => {\n        return isFunction(mthd) ? mthd(method) : method === mthd;\n      });\n\n    const actionBased = (current: ((method) => boolean) | HttpMethod) =>\n      this.loading$.pipe(\n        filterStore,\n        filterMethod(current),\n        map(action => action.loading)\n      );\n\n    const idBased = (id: any, mthd: ((method) => boolean) | HttpMethod) =>\n      this.loading$.pipe(\n        filterStore,\n        filterMethod(mthd),\n        filter(action => action.entityId === id),\n        map(action => action.loading)\n      );\n\n    return {\n      get$: actionBased(HttpMethod.GET),\n      add$: actionBased(HttpMethod.POST),\n      update$: actionBased(method => method === HttpMethod.PUT || method === HttpMethod.PATCH),\n      delete$: actionBased(HttpMethod.DELETE),\n      getEntity: (id: any) => idBased(id, HttpMethod.GET),\n      updateEntity: (id: any) => idBased(id, method => method === HttpMethod.PUT || method === HttpMethod.PATCH),\n      deleteEntity: (id: any) => idBased(id, HttpMethod.DELETE)\n    };\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { NgEntityServiceParams } from './types';\nimport { HttpMethod } from './ng-entity-service-notifier';\nimport { isObject } from '@datorama/akita';\n\nexport interface NgEntityServiceGlobalConfig {\n  baseUrl?: string;\n  httpMethods?: Partial<{\n    GET: HttpMethod;\n    POST: HttpMethod;\n    PATCH: HttpMethod;\n    PUT: HttpMethod;\n    DELETE: HttpMethod;\n  }>;\n}\n\nexport const NG_ENTITY_SERVICE_CONFIG = new InjectionToken<NgEntityServiceGlobalConfig>('NgEntityServiceGlobalConfig');\n\nexport const defaultConfig: NgEntityServiceGlobalConfig = {\n  httpMethods: {\n    GET: HttpMethod.GET,\n    POST: HttpMethod.POST,\n    PATCH: HttpMethod.PATCH,\n    PUT: HttpMethod.PUT,\n    DELETE: HttpMethod.DELETE\n  }\n};\n\nexport function mergeDeep(target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n}\n\nexport function NgEntityServiceConfig(config: NgEntityServiceParams = {}) {\n  return function(constructor) {\n    if (config.baseUrl) {\n      constructor['baseUrl'] = config.baseUrl;\n    }\n\n    if (config.resourceName) {\n      constructor['resourceName'] = config.resourceName;\n    }\n  };\n}\n","import { isNumber, isString } from '@datorama/akita';\n\nexport function isID(idOrConfig: any) {\n  return isNumber(idOrConfig) || isString(idOrConfig);\n}\n","import { EntityServiceAction, NgEntityServiceNotifier } from './ng-entity-service-notifier';\n\nexport function successAction(\n  storeName: string,\n  notifier: NgEntityServiceNotifier\n): (params: Partial<EntityServiceAction>) => void {\n  return function({ payload, method, successMsg }) {\n    notifier.dispatch({\n      type: 'success',\n      storeName,\n      payload,\n      method,\n      successMsg\n    });\n  };\n}\n\nexport function errorAction(\n  storeName: string,\n  notifier: NgEntityServiceNotifier\n): (params: Partial<EntityServiceAction>) => void {\n  return function({ payload, method, errorMsg }) {\n    notifier.dispatch({\n      type: 'error',\n      storeName,\n      payload,\n      method,\n      errorMsg\n    });\n  };\n}\n","import {\n  AddEntitiesOptions,\n  EntityService,\n  EntityState,\n  EntityStore,\n  getEntityType,\n  getIDType,\n  isDefined\n} from '@datorama/akita';\nimport { Observable, throwError } from 'rxjs';\nimport { inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { catchError, finalize, map, tap } from 'rxjs/operators';\nimport { HttpConfig, Msg, NgEntityServiceParams } from './types';\nimport { EntityServiceAction, HttpMethod, NgEntityServiceNotifier } from './ng-entity-service-notifier';\nimport { NgEntityServiceLoader } from './ng-entity-service.loader';\nimport {\n  defaultConfig,\n  mergeDeep,\n  NG_ENTITY_SERVICE_CONFIG,\n  NgEntityServiceGlobalConfig\n} from './ng-entity-service.config';\nimport { isID } from './helpers';\nimport { errorAction, successAction } from './action-factory';\n\nexport const mapResponse = (config: HttpConfig) =>\n  map(res => ((config || {}).mapResponseFn ? config.mapResponseFn(res) : res));\n\nexport class NgEntityService<S extends EntityState = any> extends EntityService<S> {\n  baseUrl: string;\n  loader: NgEntityServiceLoader;\n\n  private http: HttpClient;\n  private notifier: NgEntityServiceNotifier;\n  private globalConfig: NgEntityServiceGlobalConfig = {};\n  private mergedConfig: NgEntityServiceParams & NgEntityServiceGlobalConfig;\n\n  private dispatchSuccess: (action: Partial<EntityServiceAction>) => void;\n  private dispatchError: (action: Partial<EntityServiceAction>) => void;\n\n  constructor(protected store: EntityStore<S>, private config: NgEntityServiceParams = {}) {\n    super();\n    this.http = inject(HttpClient);\n    this.loader = inject(NgEntityServiceLoader);\n    this.notifier = inject(NgEntityServiceNotifier);\n    this.globalConfig = inject(NG_ENTITY_SERVICE_CONFIG);\n\n    this.mergedConfig = mergeDeep(defaultConfig, this.globalConfig, config);\n\n    this.dispatchSuccess = successAction(this.store.storeName, this.notifier);\n    this.dispatchError = errorAction(this.store.storeName, this.notifier);\n  }\n\n  get api() {\n    return `${this.baseUrl || this.getConfigValue('baseUrl')}/${this.resourceName}`;\n  }\n\n  get resourceName() {\n    return this.getConfigValue('resourceName') || this.store.storeName;\n  }\n\n  setBaseUrl(api: string) {\n    this.baseUrl = api;\n  }\n\n  getHttp() {\n    return this.http;\n  }\n\n  getConfig() {\n    return this.mergedConfig;\n  }\n\n  /**\n   *\n   * Get all or one entity - Creates a GET request\n   *\n   * service.get().subscribe()\n   * service.get({ headers, params, url })\n   *\n   * service.get(id)\n   * service.get(id, { headers, params, url })\n   *\n   */\n  get<T>(id?: getIDType<S>, config?: HttpConfig & { append?: boolean } & Msg): Observable<T>;\n  get<T>(config?: HttpConfig & { append?: boolean } & Msg): Observable<T>;\n  get<T>(\n    idOrConfig?: getIDType<S> | HttpConfig,\n    config?: HttpConfig & { append?: boolean; upsert?: boolean } & Msg\n  ): Observable<T> {\n    let url: string;\n    const isSingle = isID(idOrConfig);\n    const _config: HttpConfig & { append?: boolean; upsert?: boolean } & Msg = (isSingle ? config : idOrConfig) || {};\n    const method = this.getHttpMethod(HttpMethod.GET);\n\n    if (_config.url) {\n      url = _config.url;\n    } else {\n      url = isSingle ? `${this.api}/${idOrConfig}` : this.api;\n    }\n\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId: isSingle ? idOrConfig : null,\n      storeName: this.store.storeName\n    });\n\n    return this.http[method.toLowerCase()](url, _config).pipe(\n      mapResponse(_config),\n      tap((data: any) => {\n        if (isSingle) {\n          this.store.upsert(idOrConfig as getIDType<S>, data);\n        } else {\n          if (_config.append) {\n            this.store.add(data);\n          } else if (_config.upsert) {\n            this.store.upsertMany(data);\n          } else {\n            this.store.set(data);\n          }\n        }\n\n        this.dispatchSuccess({\n          method,\n          payload: data,\n          successMsg: _config.successMsg\n        });\n      }),\n      catchError(error => this.handleError(method, error, _config.errorMsg)),\n      finalize(() => {\n        this.loader.dispatch({\n          method,\n          loading: false,\n          storeName: this.store.storeName\n        });\n      })\n    ) as Observable<T>;\n  }\n\n  /**\n   *\n   * Add a new entity - Creates a POST request\n   *\n   * service.add(entity)\n   * service.add(entity, config)\n   *\n   */\n  add<T>(entity: getEntityType<S>, config?: HttpConfig & Pick<AddEntitiesOptions, 'prepend'> & Msg): Observable<T> {\n    const method = this.getHttpMethod(HttpMethod.POST);\n\n    this.loader.dispatch({\n      method,\n      loading: true,\n      storeName: this.store.storeName\n    });\n    return this.http[method.toLowerCase()](this.resolveUrl(config), entity, config).pipe(\n      mapResponse(config),\n      tap((entity: any) => {\n        this.store.add(entity, config);\n        this.dispatchSuccess({\n          method,\n          payload: entity,\n          successMsg: config && config.successMsg\n        });\n      }),\n      catchError(error => this.handleError(method, error, config && config.errorMsg)),\n      finalize(() => {\n        this.loader.dispatch({\n          method,\n          loading: false,\n          storeName: this.store.storeName\n        });\n      })\n    ) as Observable<T>;\n  }\n\n  /**\n   *\n   * Update an entity - Creates a PUT/PATCH request\n   *\n   * service.update(id, entity)\n   * service.update(id, entity, config)\n   *\n   */\n  update<T>(\n    id: getIDType<S>,\n    entity: Partial<getEntityType<S>>,\n    config?: HttpConfig & { method: HttpMethod.PUT | HttpMethod.PATCH } & Msg\n  ): Observable<T> {\n    const method = config && config.method ? config.method : this.getHttpMethod(HttpMethod.PUT);\n\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId: id,\n      storeName: this.store.storeName\n    });\n\n    return this.http[method.toLocaleLowerCase()](this.resolveUrl(config, id), entity, config).pipe(\n      mapResponse(config),\n      tap(entity => {\n        this.store.update(id, entity as any);\n        this.dispatchSuccess({\n          method,\n          payload: entity,\n          successMsg: config && config.successMsg\n        });\n      }),\n      catchError(error => this.handleError(method, error, config && config.errorMsg)),\n      finalize(() => {\n        this.loader.dispatch({\n          method,\n          loading: false,\n          entityId: id,\n          storeName: this.store.storeName\n        });\n      })\n    ) as Observable<T>;\n  }\n\n  /**\n   *\n   * Delete an entity - Creates a DELETE request\n   *\n   * service.delete(id)\n   * service.delete(id, config)\n   *\n   */\n  delete<T>(id: getIDType<S>, config?: HttpConfig & Msg): Observable<T> {\n    const method = this.getHttpMethod(HttpMethod.DELETE);\n\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId: id,\n      storeName: this.store.storeName\n    });\n\n    return this.http[method.toLowerCase()](this.resolveUrl(config, id), config).pipe(\n      mapResponse(config),\n      tap(res => {\n        this.store.remove(id);\n        this.dispatchSuccess({\n          method,\n          payload: res,\n          successMsg: config && config.successMsg\n        });\n      }),\n      catchError(error => this.handleError(method, error, config && config.errorMsg)),\n      finalize(() => {\n        this.loader.dispatch({\n          method,\n          loading: false,\n          entityId: id,\n          storeName: this.store.storeName\n        });\n      })\n    ) as Observable<T>;\n  }\n\n  private getHttpMethod(type: HttpMethod) {\n    return this.mergedConfig.httpMethods[type];\n  }\n\n  private getConfigValue(key: string) {\n    return this.constructor[key] || this.mergedConfig[key];\n  }\n\n  private resolveUrl(config: HttpConfig, id?: any) {\n    const customUrl = (config || {}).url;\n    if (isDefined(id)) {\n      return customUrl || `${this.api}/${id}`;\n    }\n\n    return customUrl || this.api;\n  }\n\n  private handleError(method: HttpMethod, error: any, errorMsg: string) {\n    this.dispatchError({\n      method,\n      errorMsg,\n      payload: error\n    });\n\n    return throwError(error);\n  }\n}\n"]}