import { __decorate, __metadata } from 'tslib';
import { defineInjectable, Injectable, inject, NgModule } from '@angular/core';
import { Store, StoreConfig, Query, filterNil, setSkipAction, action } from '@datorama/akita';
import { RoutesRecognized, NavigationCancel, NavigationError, Router } from '@angular/router';
import { combineLatest, of } from 'rxjs';
import { map, distinctUntilChanged, pluck } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
function createInitialRouterState() {
    return {
        state: null,
        navigationId: null
    };
}
let RouterStore = class RouterStore extends Store {
    constructor() {
        super(createInitialRouterState());
    }
};
RouterStore.ɵfac = function RouterStore_Factory(t) { return new (t || RouterStore)(); };
RouterStore.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterStore, factory: RouterStore.ɵfac, providedIn: 'root' });
RouterStore.ngInjectableDef = defineInjectable({ factory: function RouterStore_Factory() { return new RouterStore(); }, token: RouterStore, providedIn: "root" });
RouterStore = __decorate([ StoreConfig({ name: 'router' }),
    __metadata("design:paramtypes", [])
], RouterStore);

function slice(section) {
    return (source) => {
        return source.pipe(map(data => data.state)).pipe(filterNil, map(state => state.root[section]));
    };
}
let RouterQuery = class RouterQuery extends Query {
    constructor(store) {
        super(store);
        this.store = store;
    }
    selectParams(names) {
        if (names === undefined) {
            return this.select().pipe(slice('params'), distinctUntilChanged());
        }
        const select = (p) => this.select().pipe(slice('params'), pluck(p), distinctUntilChanged());
        if (Array.isArray(names)) {
            const sources = names.map(select);
            return combineLatest(sources);
        }
        return select(names).pipe(distinctUntilChanged());
    }
    getParams(name) {
        if (this.getValue().state) {
            const params = this.getValue().state.root.params;
            if (name === undefined) {
                return params;
            }
            return params[name];
        }
        return null;
    }
    selectQueryParams(names) {
        if (names === undefined) {
            return this.select().pipe(slice('queryParams'), distinctUntilChanged());
        }
        const select = (p) => this.select().pipe(slice('queryParams'), pluck(p), distinctUntilChanged());
        if (Array.isArray(names)) {
            const sources = names.map(select);
            return combineLatest(sources);
        }
        return select(names);
    }
    getQueryParams(name) {
        if (this.getValue().state) {
            const params = this.getValue().state.root.queryParams;
            if (name === undefined) {
                return params;
            }
            return params[name];
        }
        return null;
    }
    selectFragment() {
        return this.select().pipe(slice('fragment'), distinctUntilChanged());
    }
    getFragment() {
        if (this.getValue().state) {
            return this.getValue().state.root.fragment;
        }
        return null;
    }
    selectData(name) {
        if (name === undefined) {
            return this.select().pipe(slice('data'), distinctUntilChanged());
        }
        return this.select().pipe(slice('data'), pluck(name), distinctUntilChanged());
    }
    getData(name) {
        if (this.getValue().state) {
            const data = this.getValue().state.root.data;
            if (name === undefined) {
                return data;
            }
            return data[name];
        }
        return null;
    }
};
RouterQuery.ɵfac = function RouterQuery_Factory(t) { return new (t || RouterQuery)(ɵngcc0.ɵɵinject(RouterStore)); };
RouterQuery.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterQuery, factory: RouterQuery.ɵfac });
RouterQuery = __decorate([ __metadata("design:paramtypes", [RouterStore])
], RouterQuery);

let RouterService = class RouterService {
    constructor(routerStore, routerQuery, router) {
        this.routerStore = routerStore;
        this.routerQuery = routerQuery;
        this.router = router;
        this.dispatchTriggeredByRouter = false;
        this.navigationTriggeredByDispatch = false;
    }
    dispatchRouterCancel(event) {
        this.update();
    }
    dispatchRouterError(event) {
        this.update();
    }
    dispatchRouterNavigation() {
        this.update();
    }
    init() {
        this.setUpRouterHook();
        this.setUpStoreListener();
        this.setUpStateRollbackEvents();
    }
    update() {
        this.dispatchTriggeredByRouter = true;
        this.routerStore.update((state) => {
            return Object.assign({}, state, { state: this.routerStateSnapshot, navigationId: this.lastRoutesRecognized ? this.lastRoutesRecognized.id : null });
        });
        this.dispatchTriggeredByRouter = false;
        this.navigationTriggeredByDispatch = false;
    }
    /**
     * Hook into the angular router before each navigation action is performed
     * since the route tree can be large, we serialize it into something more manageable
     */
    setUpRouterHook() {
        this.router.hooks.beforePreactivation = (routerStateSnapshot) => {
            this.routerStateSnapshot = {
                root: this.serializeRoute(routerStateSnapshot.root),
                url: routerStateSnapshot.url
            };
            if (this.shouldDispatchRouterNavigation())
                this.dispatchRouterNavigation();
            return of(true);
        };
    }
    setUpStoreListener() {
        this.routerQuery
            .select(state => state)
            .subscribe(s => {
            this.routerState = s;
            this.navigateIfNeeded();
        });
    }
    shouldDispatchRouterNavigation() {
        if (!this.routerState)
            return true;
        return !this.navigationTriggeredByDispatch;
    }
    navigateIfNeeded() {
        if (!this.routerState || !this.routerState.state) {
            return;
        }
        if (this.dispatchTriggeredByRouter)
            return;
        if (this.router.url !== this.routerState.state.url) {
            this.navigationTriggeredByDispatch = true;
            setSkipAction();
            this.router.navigateByUrl(this.routerState.state.url);
        }
    }
    setUpStateRollbackEvents() {
        this.router.events.subscribe(e => {
            if (e instanceof RoutesRecognized) {
                this.lastRoutesRecognized = e;
            }
            else if (e instanceof NavigationCancel) {
                this.dispatchRouterCancel(e);
            }
            else if (e instanceof NavigationError) {
                this.dispatchRouterError(e);
            }
        });
    }
    serializeRoute(route) {
        let state = route.root;
        while (state.firstChild) {
            state = state.firstChild;
        }
        const { params, data, paramMap, queryParamMap, queryParams, fragment } = state;
        return {
            url: route.url,
            params,
            queryParams,
            fragment,
            data,
            paramMap,
            queryParamMap
        };
    }
};
RouterService.ɵfac = function RouterService_Factory(t) { return new (t || RouterService)(ɵngcc0.ɵɵinject(RouterStore), ɵngcc0.ɵɵinject(RouterQuery), ɵngcc0.ɵɵinject(ɵngcc1.Router)); };
RouterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterService, factory: RouterService.ɵfac, providedIn: 'root' });
RouterService.ngInjectableDef = defineInjectable({ factory: function RouterService_Factory() { return new RouterService(inject(RouterStore), inject(RouterQuery), inject(Router)); }, token: RouterService, providedIn: "root" });
__decorate([
    action('Navigation Cancelled'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [NavigationCancel]),
    __metadata("design:returntype", void 0)
], RouterService.prototype, "dispatchRouterCancel", null);
__decorate([
    action('Navigation Error'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [NavigationError]),
    __metadata("design:returntype", void 0)
], RouterService.prototype, "dispatchRouterError", null);
__decorate([
    action('Navigation'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], RouterService.prototype, "dispatchRouterNavigation", null);
RouterService = __decorate([ __metadata("design:paramtypes", [RouterStore, RouterQuery, Router])
], RouterService);

var AkitaNgRouterStoreModule_1;
let AkitaNgRouterStoreModule = AkitaNgRouterStoreModule_1 = class AkitaNgRouterStoreModule {
    constructor(routerService) {
        this.routerService = routerService;
        this.routerService.init();
    }
    static forRoot() {
        return {
            ngModule: AkitaNgRouterStoreModule_1,
            providers: [RouterStore, RouterService, RouterQuery]
        };
    }
};
AkitaNgRouterStoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AkitaNgRouterStoreModule });
AkitaNgRouterStoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AkitaNgRouterStoreModule_Factory(t) { return new (t || AkitaNgRouterStoreModule)(ɵngcc0.ɵɵinject(RouterService)); } });
AkitaNgRouterStoreModule = AkitaNgRouterStoreModule_1 = __decorate([ __metadata("design:paramtypes", [RouterService])
], AkitaNgRouterStoreModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterQuery, [{
        type: Injectable
    }], function () { return [{ type: RouterStore }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RouterStore }, { type: RouterQuery }, { type: ɵngcc1.Router }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AkitaNgRouterStoreModule, [{
        type: NgModule,
        args: [{}]
    }], function () { return [{ type: RouterService }]; }, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AkitaNgRouterStoreModule, RouterQuery, RouterService, RouterStore, createInitialRouterState };

//# sourceMappingURL=datorama-akita-ng-router-store.js.map