{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@datorama/akita/src/isArray.ts","ng://@datorama/akita/src/isEmpty.ts","ng://@datorama/akita/src/toEntitiesObject.ts","ng://@datorama/akita/src/hasEntity.ts","ng://@datorama/akita/src/activeState.ts","ng://@datorama/akita/src/setEntities.ts","ng://@datorama/akita/src/actions.ts","ng://@datorama/akita/src/config.ts","ng://@datorama/akita/src/deepFreeze.ts","ng://@datorama/akita/src/dispatchers.ts","ng://@datorama/akita/src/env.ts","ng://@datorama/akita/src/errors.ts","ng://@datorama/akita/src/isNil.ts","ng://@datorama/akita/src/isDefined.ts","ng://@datorama/akita/src/isFunction.ts","ng://@datorama/akita/src/toBoolean.ts","ng://@datorama/akita/src/isPlainObject.ts","ng://@datorama/akita/src/root.ts","ng://@datorama/akita/src/storeConfig.ts","ng://@datorama/akita/src/stores.ts","ng://@datorama/akita/src/transaction.ts","ng://@datorama/akita/src/store.ts","ng://@datorama/akita/src/isObject.ts","ng://@datorama/akita/src/getActiveEntities.ts","ng://@datorama/akita/src/addEntities.ts","ng://@datorama/akita/src/coerceArray.ts","ng://@datorama/akita/src/removeEntities.ts","ng://@datorama/akita/src/getInitialEntitiesState.ts","ng://@datorama/akita/src/updateEntities.ts","ng://@datorama/akita/src/isUndefined.ts","ng://@datorama/akita/src/entityActions.ts","ng://@datorama/akita/src/defaultIDKey.ts","ng://@datorama/akita/src/entityStore.ts","ng://@datorama/akita/src/arrayFind.ts","ng://@datorama/akita/src/sort.ts","ng://@datorama/akita/src/entitiesToArray.ts","ng://@datorama/akita/src/entitiesToMap.ts","ng://@datorama/akita/src/isString.ts","ng://@datorama/akita/src/getEntity.ts","ng://@datorama/akita/src/queryConfig.ts","ng://@datorama/akita/src/query.ts","ng://@datorama/akita/src/compareKeys.ts","ng://@datorama/akita/src/sortByOptions.ts","ng://@datorama/akita/src/queryEntity.ts","ng://@datorama/akita/src/mapSkipUndefined.ts","ng://@datorama/akita/src/filterNil.ts","ng://@datorama/akita/src/getValueByString.ts","ng://@datorama/akita/src/setValueByString.ts","ng://@datorama/akita/src/persistState.ts","ng://@datorama/akita/src/snapshotManager.ts","ng://@datorama/akita/src/plugins/plugin.ts","ng://@datorama/akita/src/plugins/paginator/paginatorPlugin.ts","ng://@datorama/akita/src/plugins/persistForm/persistNgFormPlugin.ts","ng://@datorama/akita/src/captialize.ts","ng://@datorama/akita/src/devtools.ts","ng://@datorama/akita/src/plugins/entityCollectionPlugin.ts","ng://@datorama/akita/src/plugins/stateHistory/stateHistoryPlugin.ts","ng://@datorama/akita/src/plugins/stateHistory/entityStateHistoryPlugin.ts","ng://@datorama/akita/src/plugins/dirtyCheck/dirtyCheckPlugin.ts","ng://@datorama/akita/src/plugins/dirtyCheck/entityDirtyCheckPlugin.ts","ng://@datorama/akita/src/runStoreAction.ts","ng://@datorama/akita/src/arrayUpdate.ts","ng://@datorama/akita/src/arrayAdd.ts","ng://@datorama/akita/src/entityService.ts","ng://@datorama/akita/src/guid.ts","ng://@datorama/akita/src/toEntitiesIds.ts","ng://@datorama/akita/src/resetStores.ts","ng://@datorama/akita/src/isNumber.ts","ng://@datorama/akita/src/arrayUpsert.ts","ng://@datorama/akita/src/arrayRemove.ts","ng://@datorama/akita/src/not.ts","ng://@datorama/akita/src/fp.ts","ng://@datorama/akita/src/cacheable.ts","ng://@datorama/akita/src/combineQueries.ts","ng://@datorama/akita/src/setLoading.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","isArray","isEmpty","arr","toEntitiesObject","entities","idKey","preAddEntity","acc","ids","entities_1","tslib_1.__values","entities_1_1","current","hasEntity","id","hasActiveState","state","isMultiActiveState","active","resolveActiveEntity","_a","getExitingActives","currentActivesIds","newIds","filtered","filter","indexOf","isEntityState","applyMiddleware","mapped","_b","keys","_c","setEntities","newEntities","isNativePreAdd","resolve","map","isNaN","Number","newState","loading","currentAction","type","entityIds","skip","customActionActive","resetCustomAction","logAction","setAction","setSkipAction","action","propertyKey","descriptor","originalMethod","args","_i","CONFIG","resettable","ttl","producerFn","undefined","getAkitaConfig","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","prop","isFrozen","$$deleteStore","Subject","$$addStore","ReplaySubject","$$updateStore","dispatchDeleted","storeName","dispatchAdded","dispatchUpdate","isDev","__DEV__","exports","tslib_1.__extends","Error","AkitaError","message","_super","isNil","v","isDefined","val","isFunction","toBoolean","isPlainObject","name","hasLocalStorage","localStorage","isBrowser","window","isNotBrowser","configKey","global","__runtimeVersion","__stores__","__queries__","$$stores","$$queries","transactionFinished","transactionInProcess","BehaviorSubject","transactionManager","activeTransactions","batchTransaction","startBatch","isTransactionInProcess","endBatch","complete","commit","asObservable","of","applyTransaction","thisArg","transaction","_this","Store","setLoading","_value","_setState","setHasCache","hasCache","options","restartTTL","cache","ttlConfig","getCacheTTL","clearTimeout","setTimeout","getValue","storeValue","setError","_select","project","store","pipe","distinctUntilChanged","_cache","config","deepFreezeFn","getGlobalProducerFn","_dispatchAction","_newState","handleTransaction","dispatch","reset","isResettable","_initialState","console","warn","update","stateOrCallback","currentState","_producerFn","withHook","akitaPreUpdate","resolved","updateStoreConfig","newOptions","_","nextState","ngOnDestroy","destroy","hmrEnabled","onInit","initialState","assertStoreHasName","className","watchTransaction","subscribe","inTransaction","cacheConfig","isObject","getActiveEntities","idOrOptions","currentActive","result","wrap","currentIdIndex","prev","isFirst","isLast","addEntities","hasNewEntities","entity","entityId","prepend","unshift","coerceArray","removeEntities","removeAllEntities","_d","includes","getInitialEntitiesState","updateEntities","idToUpdate","newStateOrFn","preUpdateEntity","updatedEntities","isUpdatingIdKey","ids_1","ids_1_1","oldEntity","isIdChanged","newEntity","merged","updatedIds","stateEntities","id_1","_e","__rest","getOwnPropertySymbols","isUndefined","Set","Add","Update","Remove","DEFAULT_ID_KEY","EntityStore","entityActions","set","akitaPreAddEntity","activeId","hasInitialUIState","handleUICreation","EntityActions","add","collection","data","idsOrFnOrState","akitaPreUpdateEntity","upsert","predicate","isUpdate","toArray","isClassBased","baseClass","updateIds","withId","upsertMany","addedIds","withPreCheckHook","akitaPreCheckEntity","nextId","hasUIStore","replace","replaced","toArray_1","toArray_1_1","move","from","to","slice","splice","remove","idsOrFn","idPassed","handleUIRemove","updateActive","newStateOrCallback","setActive","_setActive","addActive","every","uniques","removeActive","some","currentId","toggleActive","filterExists","createUIStore","storeConfig","defaults","ui","EntityUIStore","nextEntity","createFn","isFunc","_akitaCreateEntityFn","uiEntities","tslib_1.__decorate","T","setInitialEntityState","find","idsOrPredicate","collection_1","collection_1_1","toSet","reduce","collection_2","collection_2_1","has","distinctUntilArrayItemChanged","prevCollection","currentCollection","hasChange","first","second","currentItem","prevItem","ASC","DESC","compareValues","order","Order","a","varA","toUpperCase","varB","comparison","entitiesToArray","filterBy","limitTo","sortBy","sortByOrder","fn","_sortBy_1","sort","Math","min","entitiesToMap","hasLimit","count","length_1","finalLength","isString","getEntity","queryConfigKey","Query","select","mapFn","compareKeys","keysOrFuncs","prevState","currState","isFns","keyOrFunc","func","k","selectLoading","selectError","selectHasCache","getHasCache","__store__","sortByOptions","QueryEntity","selectAll","asObject","getAll","selectMany","mapSkipUndefined","callbackFn","index","array","selectEntity","idOrPredicate","findEntityByPredicate","selectActiveId","getActiveId","selectActive","getActive","switchMap","selectCount","getCount","selectLast","selectAt","selectFirst","selectEntityAction","selectEntityAction$","ac","projectOrIds","hasActive","isIdProvided","createUIQuery","EntityUIQuery","filterNil","source","obj","split","join","part","setValue","lastIndex","skipStorageUpdate","_persistStateInit","setSkipStorageUpdate","getSkipStorageUpdate","observify","asyncOrValue","isPromise","then","isObservable","SnapshotManager","getStoresSnapshot","stores","setStoresSnapshot","mergedOptions","lazy","normalizedStores","JSON","parse","size","take","snapshotManager","AkitaPlugin","getQuery","query","getStore","isEntityBased","selectSource","property","withStoreName","getSource","updateStore","onReset","original","params","resetFn","paginatorDefaults","pagesControls","range","startWith","cacheTimeout","clearStoreWithCache","PaginatorPlugin","page","pagination","currentPage","lastPage","withControls","withRange","response","addPage","pages","clearCache","initial","clearStore","Map","clearPage","delete","clearCacheSubscription","unsubscribe","setPage","isPageActive","hasPage","nextPage","prevPage","setLastPage","setFirstPage","getPage","req","selectPage","refreshCurrentPage","getFrom","perPage","getTo","total","get","pageControls","generatePages","len","ceil","isLoading$","delay","Paginator","PersistNgFormPlugin","setForm","form","builder","activate","isKeyBased","initialValue","factoryFnOrPath","stateKey","formArray","controls","cleanArray","insert","patchValue","emitEvent","formKey","control","removeAt","resolveInitialValue","formValue","root","factory_1","arrControlFactory","path","isRootKeys","formChanges","valueChanges","debounceTime","capitalize","charAt","subs","EntityCollectionPlugin","removeEntity","createEntity","plugin","getIds","resolvedIds","rebase","actions","beforeAdd","instantiatePlugin","afterAdd","beforeRemove","_ids","selectIds","forEachId","cb","StateHistoryPlugin","_hasPast$","_hasFuture$","history","past","future","watchProperty","updateHasHistory","hasFutureSubject","hasFuture","hasPastSubject","hasPast","present","_entityId","subscription","pairwise","shouldUpdate","comparator","skipUpdate","maxAge","undo","previous","redo","newFuture","jumpToPast","newPast","newPresent","jumpToFuture","jump","clear","customUpdateFn","clearHistory","ignoreNext","action$$1","EntityStateHistoryPlugin","dirtyCheckDefaultParams","head","stringify","getNestedPath","nestedObj","DirtyCheckPlugin","currentValue","updateFn","_reset","setHead","_getHead","updateDirtiness","isDirty","dirty","hasHead","getHead","isPathDirty","currentPathValue","headPathValue","__akitaKey","combineLatest","isChange","compareTo","getWatchedValues","watched","isDirty$","reset$","watchProp","EntityDirtyCheckPlugin","_someDirty","someDirty","checkSomeDirty","entitiesIds","entitiesIds_1","entitiesIds_1_1","someDirty$","merge","auditTime","AddEntities","SetEntities","UpdateEntities","RemoveEntities","UpsertEntities","arrayUpdate","keyOrRoot","predicateOrIds","condition","item","arrayAdd","addFn","withTransaction","tap","StoreConfig","QueryConfig","akitaConfig","persistState","enableInNonBrowser","storage","deserialize","serialize","include","exclude","persistOnDestroy","preStorageUpdate","preStoreUpdate","preStorageUpdateOperator","includeStores","hasInclude","hasExclude","fns","subscriptions","buffer","isLocalStorage","sessionStorage","hasSessionStorage","getItem","storageState","save","storeCache","setItem","_save","shift","Promise","setInitial","selectPersistStateInit","akitaDevtools","ngZoneOrOptions","__REDUX_DEVTOOLS_EXTENSION__","run","shallow","storesWhitelist","devTools","connect","appState","isAllowed","send","normalize","msg","logTrace","group","trace","groupEnd","sortAlphabetically","sortedAppState","payload","init","rootState_1","guid","random","toString","toEntitiesIds","resetStores","stores_1","stores_1_1","isNumber","parseFloat","enableAkitaProdMode","runStoreAction","StoreActions","arrayUpsert","entityIsObject","arrayFind","arrayRemove","identifier","identifiers","filterFn","not","pred","createEntityQuery","createEntityStore","createQuery","createStore","cacheable","request$","emitNext","EMPTY","combineQueries","observables","defer","finalize"],"mappings":"6UAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAG5B,SAAgBO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAG5E,IAAIK,EAAW,WAQlB,OAPAA,EAAWZ,OAAOa,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIZ,KADTW,EAAIG,UAAUF,GACOhB,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,KAAIU,EAAEV,GAAKW,EAAEX,IAE9E,OAAOU,IAEKO,MAAMb,KAAMU,YAahC,SAAgBI,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2H5B,EAAvH6B,EAAIT,UAAUC,OAAQS,EAAID,EAAI,EAAIH,EAAkB,OAATE,EAAgBA,EAAO1B,OAAO6B,yBAAyBL,EAAQC,GAAOC,EACrH,GAAuB,iBAAZI,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASR,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIV,EAAIO,EAAWJ,OAAS,EAAQ,GAALH,EAAQA,KAASlB,EAAIyB,EAAWP,MAAIY,GAAKD,EAAI,EAAI7B,EAAE8B,GAAS,EAAJD,EAAQ7B,EAAE0B,EAAQC,EAAKG,GAAK9B,EAAE0B,EAAQC,KAASG,GAChJ,OAAW,EAAJD,GAASC,GAAK5B,OAAOgC,eAAeR,EAAQC,EAAKG,GAAIA,EAGhE,SAIgBK,EAAWC,EAAaC,GACpC,GAAuB,iBAAZL,SAAoD,mBAArBA,QAAQM,SAAyB,OAAON,QAAQM,SAASF,EAAaC,GAGpH,SAyCgBE,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UAAWzB,EAAI,EAChE,OAAIuB,EAAUA,EAAEnB,KAAKkB,GACd,CACHI,KAAM,WAEF,OADIJ,GAAKtB,GAAKsB,EAAEnB,SAAQmB,OAAI,GACrB,CAAEK,MAAOL,GAAKA,EAAEtB,KAAM4B,MAAON,KAKhD,SAAgBO,EAAOP,EAAGrB,GACtB,IAAIsB,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UACjD,IAAKF,EAAG,OAAOD,EACf,IAAmBV,EAAYkB,EAA3B9B,EAAIuB,EAAEnB,KAAKkB,GAAOS,EAAK,GAC3B,IACI,WAAc,IAAN9B,GAAsB,EAANA,QAAcW,EAAIZ,EAAE0B,QAAQE,MAAMG,EAAGC,KAAKpB,EAAEe,OAExE,MAAOM,GAASH,EAAI,CAAEG,MAAOA,WAEzB,IACQrB,IAAMA,EAAEgB,OAASL,EAAIvB,EAAU,YAAIuB,EAAEnB,KAAKJ,WAExC,GAAI8B,EAAG,MAAMA,EAAEG,OAE7B,OAAOF,EAGX,SAAgBG,IACZ,IAAK,IAAIH,EAAK,GAAI/B,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAC3C+B,EAAKA,EAAGI,OAAON,EAAO3B,UAAUF,KACpC,OAAO+B,ECxIX,SAAgBK,EAAWT,GACzB,OAAOxC,MAAMiD,QAAQT,GCCvB,SAAgBU,EAAWC,GACzB,QAAIF,EAAQE,IACY,IAAfA,EAAInC,OCFf,SAAgBoC,EAAoBC,EAAeC,EAAeC,WAC1DC,EAAM,CACVH,SAAU,GACVI,IAAK,QAGP,IAAqB,IAAAC,EAAAC,EAAAN,GAAQO,EAAAF,EAAAnB,QAAAqB,EAAAnB,KAAAmB,EAAAF,EAAAnB,OAAE,CAA1B,IAEGsB,EAAUN,EAFDK,EAAApB,OAGfgB,EAAIH,SAASQ,EAAQP,IAAUO,EAC/BL,EAAIC,IAAIZ,KAAKgB,EAAQP,yGAGvB,OAAOE,ECbT,SAAgBM,EAAaT,EAA0BU,GACrD,OAAOV,EAASnD,eAAe6D,GCCjC,SAAgBC,EAAkBC,GAChC,OAAOA,EAAM/D,eAAe,UAI9B,SAAgBgE,EAAmBC,GACjC,OAAOlB,EAAQkB,GAIjB,SAAgBC,EAAuBC,OAAEF,EAAAE,EAAAF,OAAQV,EAAAY,EAAAZ,IAAKJ,EAAAgB,EAAAhB,SACpD,OAAIa,EAAmBC,GACdG,EAAkBH,EAAQV,IAGC,IAAhCK,EAAUT,EAAUc,GACf,KAGFA,EAIT,SAAgBG,EAAkBC,EAAyBC,OACnDC,EAAWF,EAAkBG,OAAM,SAACX,GAAM,OAAsB,EAAtBS,EAAOG,QAAQZ,KAE/D,OAAIU,EAASzD,SAAWuD,EAAkBvD,OACjCuD,EAGFE,ECnBT,SAAgBG,EAAsBX,GACpC,OAAOA,EAAMZ,UAAYY,EAAMR,IAIjC,SAASoB,EAAmBxB,EAAsBE,WAC5CuB,EAAS,OACb,IAAiB,IAAAC,EAAApB,EAAA9D,OAAOmF,KAAK3B,IAAS4B,EAAAF,EAAAxC,QAAA0C,EAAAxC,KAAAwC,EAAAF,EAAAxC,OAAE,CAAnC,IAAMwB,EAAEkB,EAAAzC,MACXsC,EAAOf,GAAMR,EAAaF,EAASU,yGAGrC,OAAOe,EAIT,SAAgBI,EAAyCb,OACnDc,EACAX,EAFqDP,EAAAI,EAAAJ,MAAOZ,EAAAgB,EAAAhB,SAAUC,EAAAe,EAAAf,MAAOC,EAAAc,EAAAd,aAAc6B,EAAAf,EAAAe,eAI/F,GAAInC,EAAQI,GAAW,KACfgC,EAAUjC,EAAiBC,EAAUC,EAAOC,GAClD4B,EAAcE,EAAQhC,SACtBmB,EAASa,EAAQ5B,SAGjBe,EAFSI,EAAcvB,IACvB8B,EAAcC,EAAiB/B,EAASA,SAAWwB,EAAgBxB,EAASA,SAAUE,GAC7EF,EAASI,MAGlB0B,EAAcC,EAAiB/B,EAAWwB,EAAgBxB,EAAUE,GAC3D1D,OAAOmF,KAAKG,GAAaG,IAAG,SAACvB,GAAM,OAACwB,MAAK,GAAcxB,EAAKyB,OAAOzB,UAGxE0B,EAAQhF,EAAA,GACTwD,EAAK,CACRZ,SAAU8B,EACV1B,IAAKe,EACLkB,SAAS,IAOX,OAJI1B,EAAeC,KACjBwB,EAAStB,OAASC,EAAmB,IAGhCqB,EC3DT,IAAaE,EAAgB,CAC3BC,KAAM,KACNC,UAAW,KACXC,MAAM,GAGJC,GAAqB,EAEzB,SAAgBC,IACdD,GAAqB,EAIvB,SAAgBE,EAAUL,EAAcC,GACtCK,EAAUN,EAAMC,GAChBE,GAAqB,EAGvB,SAAgBG,EAAUN,EAAcC,IACX,IAAvBE,IACFJ,EAAcC,KAAOA,EACrBD,EAAcE,UAAYA,GAI9B,SAAgBM,EAAcL,QAAA,IAAAA,IAAAA,GAAA,GAC5BH,EAAcG,KAAOA,EAGvB,SAAgBM,EAAOA,EAAgBP,GACrC,OAAA,SAAgBxE,EAAagF,EAAqBC,OAC1CC,EAAiBD,EAAW9D,MAMlC,OALA8D,EAAW9D,MAAK,eAAY,IAAAgE,EAAA,GAAAC,EAAA,EAAAA,EAAA1F,UAAAC,OAAAyF,IAAAD,EAAAC,GAAA1F,UAAA0F,GAE1B,OADAR,EAAUG,EAAQP,GACXU,EAAerF,MAAMb,KAAMmG,IAG7BF,OC5BPI,EAAsB,CACxBC,YAAY,EACZC,IAAK,KACLC,WAAYC,WAQd,SAAgBC,IACd,OAAOL,ECpBT,SAAgBM,EAAW7E,GACzBtC,OAAOoH,OAAO9E,OAER+E,EAA2B,mBAAN/E,EACrBgF,EAAatH,OAAOU,UAAUL,eAcpC,OAZAL,OAAOuH,oBAAoBjF,GAAGkF,QAAO,SAAUC,IAE3CH,EAAWlG,KAAKkB,EAAGmF,IAClBJ,IAAuB,WAATI,GAA8B,WAATA,GAA8B,cAATA,IAC7C,OAAZnF,EAAEmF,IACkB,iBAAZnF,EAAEmF,IAAyC,mBAAZnF,EAAEmF,IACxCzH,OAAO0H,SAASpF,EAAEmF,KAEnBN,EAAW7E,EAAEmF,MAIVnF,EChBT,IAAaqF,EAAgB,IAAIC,EAAAA,QAEpBC,EAAa,IAAIC,EAAAA,cAAsB,GAAI,KAE3CC,EAAgB,IAAIH,EAAAA,QAGjC,SAAgBI,EAAgBC,GAC9BN,EAAcjF,KAAKuF,GAIrB,SAAgBC,EAAcD,GAC5BJ,EAAWnF,KAAKuF,GAIlB,SAAgBE,EAAeF,GAC7BF,EAAcrF,KAAKuF,GCdrB,SAAgBG,IACd,OAAOC,EAAAA,QARTC,EAAAD,SAAqB,ECCrB,SAAgCE,EAAAA,IAAAC,OAIhCC,GAHE,SAAAA,EAAYC,UACVC,EAAAvH,KAAAZ,KAAMkI,IAAQlI,KCFlB,SAAgBoI,EAAMC,GACpB,OAAa,OAANA,GAAcA,IAAM5B,UCC7B,SAAgB6B,EAAUC,GACxB,OAAsB,IAAfH,EAAMG,GCHf,SAAgBC,EAAWrG,GACzB,MAAwB,mBAAVA,ECDhB,SAAgBsG,EAAUtG,GACxB,OAAgB,MAATA,GAAiB,GAAGA,GAAY,QCCzC,SAAgBuG,EAAcvG,GAC5B,OAAOsG,EAAUtG,IAAqC,WAA3BA,EAAMlC,YAAY0I,KCDnB,SAAfC,IACX,IACE,MAA+B,oBAAjBC,aACd,MAAA7E,GACA,OAAO,GAPX,IAAa8E,EAA8B,oBAAXC,OACnBC,GAAgBF,ECchBG,GDbmC,oBAAXC,QAA0B,OAAcC,iBCapD,eCTzB,IAAaC,EAAkD,GAGlDC,EAAmD,GAE5DP,GAAalB,MACf,OAAgB0B,SAAWF,EAC3B,OAAgBG,UAAYF,OCRxBG,GAAsB,IAAIpC,EAAAA,QAG1BqC,GAAuB,IAAIC,EAAAA,iBAAgB,GAQpCC,GAAyC,CACpDC,mBAAoB,EACpBC,iBAAkB,MAIpB,SAAgBC,KACTC,OACHJ,GAAmBE,iBAAmB,IAAIzC,EAAAA,SAE5CuC,GAAmBC,qBACnBH,GAAqBvH,MAAK,GAI5B,SAAgB8H,KACkC,KAA1CL,GAAmBC,qBACvBD,GAAmBE,iBAAiB3H,MAAK,GACzCyH,GAAmBE,iBAAiBI,WACpCR,GAAqBvH,MAAK,GAC1BsH,GAAoBtH,MAAK,IAK7B,SAAgB6H,KACd,OAA+C,EAAxCJ,GAAmBC,mBAI5B,SAAgBM,KACd,OAAOP,GAAmBE,iBAAmBF,GAAmBE,iBAAiBM,eAAiBC,EAAAA,IAAG,GAevG,SAAgBC,GAAoBtE,EAAiBuE,QAAA,IAAAA,IAAAA,EAAA7D,WACnDqD,KACA,IACE,OAAO/D,EAAOlF,MAAMyJ,WAEpB1E,EAAU,gBACVoE,MAmBJ,SAAgBO,KACd,OAAA,SAAgBvJ,EAAagF,EAAqBC,OAC1CC,EAAiBD,EAAW9D,MAQlC,OANA8D,EAAW9D,MAAK,eAAG,IAAAqI,EAAAxK,KAASmG,EAAA,GAAAC,EAAA,EAAAA,EAAA1F,UAAAC,OAAAyF,IAAAD,EAAAC,GAAA1F,UAAA0F,GAC1B,OAAOiE,GAAgB,WACrB,OAAOnE,EAAerF,MAAM2J,EAAMrE,IACjCnG,OAGEiG,GCvDX,QAsBEwE,GAAAvK,UAAAwK,WAAA,SAAWrF,QAAA,IAAAA,IAAAA,GAAA,GACLA,IAAarF,KAAK2K,SAAsCtF,UAC1DuC,KAAW/B,EAAU,eACrB7F,KAAK4K,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GAAMwD,EAAK,CAAEyB,QAAOA,QAehDoF,GAAAvK,UAAA2K,YAAA,SAAYC,EAAmBC,GAA/B,IAAAP,EAAAxK,KAKE,QAL6B,IAAA+K,IAAAA,EAAA,CAAqCC,YAAY,IAC1EF,IAAa9K,KAAKiL,MAAMnH,OAAO3B,OACjCnC,KAAKiL,MAAMnH,OAAO5B,KAAK4I,GAGrBC,EAAQC,WAAY,KAChBE,EAAYlL,KAAKmL,cACnBD,IACqB,OAAnBlL,KAAKiL,MAAM1E,KACb6E,aAAapL,KAAKiL,MAAM1E,KAE1BvG,KAAKiL,MAAM1E,IAAW8E,WAAU,WAAO,OAAAb,EAAKK,aAAY,IAAQK,MAYtET,GAAAvK,UAAAoL,SAAA,WACE,OAAOtL,KAAKuL,YAWdd,GAAAvK,UAAAsL,SAAA,SAAY/I,GACNA,IAAWzC,KAAK2K,SAAgClI,QAClDmF,KAAW/B,EAAU,aACrB7F,KAAK4K,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GAAMwD,EAAK,CAAEnB,MAAKA,QAK9CgI,GAAAvK,UAAAuL,QAAA,SAAWC,GACT,OAAO1L,KAAK2L,MAAMxB,eAAeyB,KAC/B3G,EAAAA,IAAIyG,GACJG,EAAAA,yBAKJpB,GAAAvK,UAAAyK,OAAA,WACE,OAAO3K,KAAKuL,YAIdd,GAAAvK,UAAA4L,OAAA,WACE,OAAO9L,KAAKiL,MAAMnH,QAIpBtE,OAAAgC,eAAIiJ,GAAAvK,UAAA,SAAM,KAAV,WACE,OAAOF,KAAKC,YAAYgJ,IAAc,oCAIxCzJ,OAAAgC,eAAIiJ,GAAAvK,UAAA,YAAS,KAAb,WACE,OAAQF,KAAW,OAAgDyH,WAAczH,KAAY,QAAgDyH,WAAazH,KAAK+K,QAAQpC,sCAIzKnJ,OAAAgC,eAAIiJ,GAAAvK,UAAA,aAAU,KAAd,WACE,OAAOF,KAAK+L,OAAOC,cAAgBhM,KAAK+K,QAAQiB,cAAgBrF,mCAIlEnH,OAAAgC,eAAIiJ,GAAAvK,UAAA,cAAW,KAAf,WACE,OAAOF,KAAK+L,OAAOd,OAASjL,KAAK+K,QAAQE,uCAG3CzL,OAAAgC,eAAIiJ,GAAAvK,UAAA,cAAW,KAAf,WACE,OAAOF,KAAK+L,OAAOvF,YAAcxG,KAAK+K,QAAQvE,Yd3IlD,SAAgByF,IACd,OAAO5F,EAAOG,Wc0IgDyF,oCAI9DzM,OAAAgC,eAAIiJ,GAAAvK,UAAA,aAAU,KAAd,WACE,OAAOoI,EAAUtI,KAAK+L,OAAOzF,YAActG,KAAK+L,OAAOzF,WAAatG,KAAK+K,QAAQzE,4CAInFmE,GAAAvK,UAAA0K,UAAA,SAAUxF,EAA2C8G,GACnD,QADmD,IAAAA,IAAAA,GAAA,GAC/C1D,EAAWpD,GAAW,KAClB+G,EAAY/G,EAASpF,KAAK2K,UAChC3K,KAAKuL,WAAa1D,EAAAA,QAAU7H,KAAK2G,WAAWwF,GAAaA,OAEzDnM,KAAKuL,WAAanG,EAGfpF,KAAK2L,MAKN5B,KACF/J,KAAKoM,oBAIPpM,KAAKqM,SAASrM,KAAKuL,WAAYW,GAT7BlM,KAAK2L,MAAQ,IAAIjC,EAAAA,gBAAgB1J,KAAKuL,aAqB1Cd,GAAAvK,UAAAoM,MAAA,WAAA,IAAA9B,EAAAxK,KACMA,KAAKuM,gBACP3E,KAAW/B,EAAU,SACrB7F,KAAK4K,UAAS,WAAO,OAAApL,OAAOa,OAAO,GAAImK,EAAKgC,iBAC5CxM,KAAK6K,aAAY,IAEjBjD,KAAW6E,QAAQC,KAAK,+CAsB5BjC,GAAAvK,UAAAyM,OAAA,SAAOC,OAGDxH,EAFJwC,KAAW/B,EAAU,cAGfgH,EAAe7M,KAAK2K,SAExBvF,EADEoD,EAAWoE,GACFpE,EAAWxI,KAAK8M,aAAe9M,KAAK8M,YAAYD,EAAcD,GAAmBA,EAAgBC,GAEjGD,MAGPG,EAAW/M,KAAKgN,eAAeH,EAAYzM,EAAA,GAAOyM,EAAiBzH,IACnE6H,EAAWvE,EAAcmE,GAAgBE,EAAW,IAAI,EAAsB9M,YAAY8M,GAChG/M,KAAK4K,UAAUqC,IAGjBxC,GAAAvK,UAAAgN,kBAAA,SAAkBC,GAChBnN,KAAK+K,QAAO3K,EAAA,GAAQJ,KAAK+K,QAAYoC,IAIvC1C,GAAAvK,UAAA8M,eAAA,SAAeI,EAAgBC,GAC7B,OAAOA,GAGT5C,GAAAvK,UAAAoN,YAAA,WACEtN,KAAKuN,WAYP9C,GAAAvK,UAAAqN,QAAA,WACqBzE,GAAY,OAAgB0E,YAC5BxN,OAASoJ,EAAWpJ,KAAKyH,oBACnC2B,EAAWpJ,KAAKyH,WACvBD,EAAgBxH,KAAKyH,WACrBzH,KAAK6K,aAAY,GACjB7K,KAAKiL,MAAMnH,OAAOmG,aAIdQ,GAAAvK,UAAAuN,OAAR,SAAeC,IACbtE,EAAWpJ,KAAKyH,WAAazH,MACxB4K,UAAS,WAAO,OAAA8C,IACrBhG,EAAc1H,KAAKyH,WACfzH,KAAKuM,iBACPvM,KAAKwM,cAAgBkB,GAEvB9F,KVrRJ,SAAgB+F,EAAmBhF,EAAciF,GAC1CjF,GACH8D,QAAQhK,MAAM,wCAAwCmL,GUmR3CD,CAAmB3N,KAAKyH,UAAWzH,KAAKC,YAAY0I,OAGzD8B,GAAAvK,UAAAmM,SAAR,SAAiBzI,EAAUsI,QAAA,IAAAA,IAAAA,GAAA,GACzBlM,KAAK2L,MAAMzJ,KAAK0B,GACZsI,IACFvE,EAAe3H,KAAKyH,WACpB9B,MAII8E,GAAAvK,UAAA2N,iBAAR,WAAA,IAAArD,EAAAxK,KACEkK,KAAS4D,UAAS,WAChBtD,EAAKuD,eAAgB,EACrBvD,EAAK6B,SAAS7B,EAAKG,aAIfF,GAAAvK,UAAAqM,aAAR,WACE,OAAwB,IAApBvM,KAAKsG,aAGFtG,KAAKsG,YAAcI,IAAiBJ,aAGrCmE,GAAAvK,UAAAkM,kBAAR,WACOpM,KAAK+N,gBACR/N,KAAK6N,mBACL7N,KAAK+N,eAAgB,IAIjBtD,GAAAvK,UAAAiL,YAAR,WACE,OAAQnL,KAAKgO,aAAehO,KAAKgO,YAAYzH,KAAQG,IAAiBH,KAE1EkE,IA5QE,SAAAA,GAAYiD,EAAoC3C,QAAA,IAAAA,IAAAA,EAAA,IAAA/K,KAAA+K,QAAAA,EAPxC/K,KAAA+N,eAAgB,EAEd/N,KAAAiL,MAAoB,CAC5BnH,OAAQ,IAAI4F,EAAAA,iBAAyB,GACrCnD,IAAK,MAILvG,KAAKyN,OAAM,GCpDf,SAAgBQ,GAAS9L,OACjBoD,SAAcpD,EACpB,OAAgB,MAATA,IAA0B,UAARoD,GAA4B,YAARA,GCK/C,SAAgB2I,GAAkBC,EAA4C/K,EAAWgL,OACnFC,EAEJ,GAAIzL,EAAQuL,GACVE,EAASF,OAET,GAAIF,GAASE,GAAc,CACzB,GAAI/F,EAAMgG,GAAgB,OAC1B,EAAoC5O,OAAOa,OAAO,CAAEiO,MAAM,GAAQH,OAC5DI,EAAiBnL,EAAIkB,QAAO,GAClC,GAAI,EAAkCkK,KAAM,KACpCC,EAA6B,IAAnBF,EAChB,GAAIE,IAAY,EAAkCH,KAAM,OACxDD,EAASI,EAAUrL,EAAIA,EAAIzC,OAAS,GAAMyC,EAAImL,EAAiB,QAC1D,GAAI,EAAkCrM,KAAM,KAC3CwM,EAAStL,EAAIzC,SAAW4N,EAAiB,EAC/C,GAAIG,IAAW,EAAkCJ,KAAM,OACvDD,EAASK,EAAStL,EAAI,GAAMA,EAAImL,EAAiB,QAE9C,CACL,GAAIJ,IAAgBC,EAAe,OACnCC,EAAM,EAIV,OAAOA,ECnBT,SAAgBM,GAAyC3K,WAAEJ,EAAAI,EAAAJ,MAAOZ,EAAAgB,EAAAhB,SAAUC,EAAAe,EAAAf,MAAOyB,EAAAV,EAAA+G,QAAAA,OAAA,IAAArG,EAAA,GAAAA,EAAcxB,EAAAc,EAAAd,aAC3F4B,EAAc,GACdX,EAAS,GACTyK,GAAiB,MAErB,IAAqB,IAAAvL,EAAAC,EAAAN,GAAQO,EAAAF,EAAAnB,QAAAqB,EAAAnB,KAAAmB,EAAAF,EAAAnB,OAAE,CAA1B,IAAM2M,EAAMtL,EAAApB,MACf,IAAiD,IAA7CsB,EAAUG,EAAMZ,SAAU6L,EAAO5L,IAAmB,KAEhDO,EAAUN,EAAa2L,GACvBC,EAAWtL,EAAQP,GACzB6B,EAAYgK,GAAYtL,EACpBuH,EAAQgE,QAAS5K,EAAO6K,QAAQF,GAC/B3K,EAAO3B,KAAKsM,GAEjBF,GAAiB,wGAIrB,OAAOA,EACH,CACExJ,SAAQhF,EAAA,GACHwD,EAAK,CACRZ,SAAQ5C,EAAA,GACHwD,EAAMZ,SACN8B,GAEL1B,IAAK2H,EAAQgE,QAAOrM,EAAOyB,EAAWP,EAAMR,KAAGV,EAAQkB,EAAMR,IAAQe,KAEvEA,OAAMA,GAER,KCzCN,SAAgB8K,GAAe9M,GAC7B,OAAIiG,EAAMjG,GACD,GAEFxC,MAAMiD,QAAQT,GAASA,EAAQ,CAACA,GCGzC,SAAgB+M,GAA4ClL,WAAEJ,EAAAI,EAAAJ,MAAOR,EAAAY,EAAAZ,IACnE,GAAIgF,EAAMhF,GAAM,OAAO+L,GAAkBvL,OACnCZ,EAAWY,EAAMZ,SACnB8B,EAAc,OAElB,IAAiB,IAAAF,EAAAtB,EAAAM,EAAMR,KAAGgM,EAAAxK,EAAA1C,QAAAkN,EAAAhN,KAAAgN,EAAAxK,EAAA1C,OAAE,CAAvB,IAAMwB,EAAE0L,EAAAjN,OACc,IAArBiB,EAAIiM,SAAS3L,KACfoB,EAAYpB,GAAMV,EAASU,6GAIzB0B,EAAQhF,EAAA,GACTwD,EAAK,CACRZ,SAAU8B,EACV1B,IAAKQ,EAAMR,IAAIiB,OAAM,SAACb,GAAW,OAA0B,IAA1BJ,EAAIiM,SAAS7L,OAOhD,OAJIG,EAAeC,KACjBwB,EAAStB,OAASC,EAAoBqB,IAGjCA,EAIT,SAAgB+J,GAAqBvL,GACnC,OAAAxD,EAAA,GACKwD,EAAK,CACRZ,SAAU,GACVI,IAAK,GACLU,OAAQD,EAAmBD,EAAME,QAAU,GAAK,OCrChB,SAAvBwL,KACX,MAAA,CACEtM,SAAU,GACVI,IAAK,GACLiC,SAAS,EACT5C,MAAO,MCOX,SAAgB8M,GAA4CvL,WAItDwL,EAJwD5L,EAAAI,EAAAJ,MAAOR,EAAAY,EAAAZ,IAAKH,EAAAe,EAAAf,MAAOwM,EAAAzL,EAAAyL,aAAcC,EAAA1L,EAAA0L,gBAAiBlJ,EAAAxC,EAAAwC,WACxGmJ,EAAkB,GAEpBC,GAAkB,MAGtB,IAAiB,IAAAC,EAAAvM,EAAAF,GAAG0M,EAAAD,EAAA3N,QAAA4N,EAAA1N,KAAA0N,EAAAD,EAAA3N,OAAE,CAAjB,IAAMwB,EAAEoM,EAAA3N,MAEX,IAAsC,IAAlCsB,EAAUG,EAAMZ,SAAUU,GAA9B,KAIMqM,EAAYnM,EAAMZ,SAASU,GAC7B0B,OAAQ,EAON4K,GALJ5K,EADEoD,EAAWiH,GACFjH,EAAWhC,GAAcA,EAAWuJ,EAAWN,GAAgBA,EAAaM,GAE5EN,GAGgB5P,eAAeoD,IAAUmC,EAASnC,KAAW8M,EAAU9M,GAChFgN,OAAS,EACbT,EAAa9L,EAETsM,IACFJ,GAAkB,EAClBJ,EAAapK,EAASnC,QAGlBiN,EAAM9P,EAAA,GACP2P,EACA3K,GAIH6K,EADEvH,EAAcqH,GACJG,EAYRxH,EAActD,GACJ,IAAI,EAAmBnF,YAAYiQ,GAEnC,IAAI,EAAkBjQ,YAAYiQ,GAIlDP,EAAgBH,GAAcE,EAAgBK,EAAWE,6GAGvDE,EAAavM,EAAMR,IACnBgN,EAAgBxM,EAAMZ,SAE1B,GAAI4M,EAAiB,CACb,IAACS,EAADhO,EAAAe,EAAA,GAAC,GACDgM,EAAAxL,EAAAZ,SAAEsN,EAAAD,EAAAjB,EAAAkB,GACRF,E7BtCJ,SAAgBG,EAAOhQ,EAAG+B,GACtB,IAAIhC,EAAI,GACR,IAAK,IAAIV,KAAKW,EAAOf,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,IAAM0C,EAAEgC,QAAQ1E,GAAK,IAC9EU,EAAEV,GAAKW,EAAEX,IACb,GAAS,MAALW,GAAqD,mBAAjCf,OAAOgR,sBACtB,CAAA,IAAIhQ,EAAI,EAAb,IAAgBZ,EAAIJ,OAAOgR,sBAAsBjQ,GAAIC,EAAIZ,EAAEe,OAAQH,IAAS8B,EAAEgC,QAAQ1E,EAAEY,IAAM,IAC1FF,EAAEV,EAAEY,IAAMD,EAAEX,EAAEY,KACtB,OAAOF,E6B8BsBiQ,CAAAnB,EAAA,CAAA,iBAAAkB,EAAAA,EAAAA,EAAA,KAE7BH,EAAavM,EAAMR,IAAI6B,IAAG,SAACzB,GAAW,OAACA,IAAY6M,EAAKb,EAAahM,IAGvE,OAAApD,EAAA,GACKwD,EAAK,CACRZ,SAAQ5C,EAAA,GACHgQ,EACAT,GAELvM,IAAK+M,ICvFT,SAAgBM,GAAYtO,GAC1B,OAAOA,IAAUsE,kBCDjBiK,IAAA,EACAC,IAAA,EACAC,OAAA,EACAC,OAAA,mFCJF,ICwCA1I,MDxCa2I,GAAiB,KCwC9BC,IAAoHhJ,EAAAA,GAApHI,GAAoHsC,IASlHjL,OAAAgC,eAAIuP,GAAA7Q,UAAA,sBAAmB,KAAvB,WACE,OAAOF,KAAKgR,cAAc7G,gDAI5B3K,OAAAgC,eAAIuP,GAAA7Q,UAAA,QAAK,KAAT,WACE,OAAQF,KAAW,OAAwBiD,OAASjD,KAAK+K,QAAQ9H,OAAS6N,oCAc5EC,GAAA7Q,UAAA+Q,IAAA,SAAIjO,EAAmC+H,GAAvC,IAAAP,EAAAxK,KACE,QADqC,IAAA+K,IAAAA,EAAA,KACjC3C,EAAMpF,GAAV,CAEA4E,KAAW/B,EAAU,kBAEfd,EAAiB/E,KAAKkR,oBAAsBH,GAAY7Q,UAAUgR,kBAExElR,KAAK4K,UAAS,SAAChH,OACPwB,EAAWP,EAAY,CAC3BjB,MAAKA,EACLZ,SAAQA,EACRC,MAAOuH,EAAKvH,MACZC,aAAcsH,EAAK0G,kBACnBnM,eAAcA,IAOhB,OAJsC,IAAlC0L,GAAY1F,EAAQoG,YACtB,EAAkBrN,OAASiH,EAAQoG,UAG9B/L,IAGTpF,KAAK6K,aAAY,EAAM,CAAEG,YAAY,IAEjChL,KAAKoR,qBACPpR,KAAKqR,mBAGPrR,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcZ,IAAKtN,IAAKpD,KAAKoD,QAc/D2N,GAAA7Q,UAAAqR,IAAA,SAAIvO,EAA+B+H,QAAA,IAAAA,IAAAA,EAAA,CAAgC1F,SAAS,QACpEmM,EAAavC,GAAYjM,GAE/B,IAAIH,EAAQ2O,GAAZ,KAEMC,EAAO9C,GAAY,CACvB/K,MAAO5D,KAAK2K,SACZzH,aAAclD,KAAKkR,kBACnBlO,SAAUwO,EACVvO,MAAOjD,KAAKiD,MACZ8H,QAAOA,IAGL0G,IACF7J,KAAW/B,EAAU,cACrB4L,EAAKrM,SAASC,QAAU0F,EAAQ1F,QAEhCrF,KAAK4K,UAAS,WAAO,OAAA6G,EAAKrM,WAEtBpF,KAAKoR,qBACPpR,KAAKqR,kBAAiB,GAGxBrR,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcX,IAAKvN,IAAKqO,EAAKtN,YA8BjE4M,GAAA7Q,UAAAyM,OAAA,SACE+E,EACAjC,GAFF,IAAAjF,EAAAxK,KAIE,GAAIyQ,GAAYhB,GACdtH,GAAAjI,UAAMyM,OAAM/L,KAAAZ,KAAA,OADd,KAIIoD,EAAgB,GAUhBP,EANFO,EAFEoF,EAAWkJ,GAEP1R,KAAKoD,IAAIiB,OAAM,SAACX,GAAM,OAAA,EAAsD8G,EAAKxH,SAASU,MAG1F0E,EAAMsJ,GAAkB1R,KAAKoD,IAAM6L,GAAW,MAKtDrH,KAAW/B,EAAU,gBAAiBzC,GACtCpD,KAAK4K,UAAS,SAAChH,GACb,OAAA2L,GAAe,CACbtM,MAAOuH,EAAKvH,MACZG,IAAGA,EACHsM,gBAAiBlF,EAAKmH,qBACtB/N,MAAKA,EACL6L,aAAYA,EACZjJ,WAAYgE,EAAKsC,gBAIrB9M,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcV,OAAQxN,IAAGA,OAe3D2N,GAAA7Q,UAAA0R,OAAA,SAAOxO,EAAsBgC,EAA6F2F,GAD1H,IAAAP,EAAAxK,KAGiB,SAAT6R,EAAYC,mBAAYpO,GAAM,OAAAD,EAAU+G,EAAKxH,SAAUU,KAAQoO,QAFmD,IAAA/G,IAAAA,EAAA,QAClHgH,EAAU9C,GAAY7L,GAEtB4O,EAAexJ,EAAWuC,EAAQkH,WAClCC,EAAYH,EAAQ1N,OAAOwN,GAAU,IACrC/M,EAAciN,EAAQ1N,OAAOwN,GAAU,IAAQ5M,IAAG,SAACvB,SACnDmL,EAASrG,EAAWpD,GAAYA,EAAQ,IAAqBA,EAC3D+M,EAAM/R,EAAA,GAAA,IAAe4D,EAAA,IAAkBwG,EAAKvH,OAAQS,EAAEM,IAC5D,OAAIgO,EACK,IAAIjH,EAAQkH,UAAUE,GAExBA,IAITnS,KAAK2M,OAAM,EAAU,GACrB3M,KAAKuR,IAAIzM,GACT8C,KAAWhC,EAAU,kBAevBmL,GAAA7Q,UAAAkS,WAAA,SAAWpP,EAAwB+H,gBAAA,IAAAA,IAAAA,EAAA,QAC3BsH,EAAW,GACXlC,EAAa,GACbR,EAAkB,OAGxB,IAAqB,IAAAtM,EAAAC,EAAAN,GAAQO,EAAAF,EAAAnB,QAAAqB,EAAAnB,KAAAmB,EAAAF,EAAAnB,OAAE,CAA1B,IAAM2M,EAAMtL,EAAApB,MACTmQ,EAAmBtS,KAAKuS,oBAAoB1D,GAC5CnL,EAAK4O,EAAiBtS,KAAKiD,OACjC,GAAIQ,EAAUzD,KAAKgD,SAAUU,GAAK,KAC1B8K,EAAOxO,KAAK2K,SAAS3H,SAASU,GAC9BwM,EAAM9P,EAAA,GAAQJ,KAAK2K,SAAS3H,SAASU,GAAQ4O,GAC7CpQ,EAAO6I,EAAQkH,UAAY,IAAIlH,EAAQkH,UAAU/B,GAAUA,EAE3DsC,GADAzF,EAAW/M,KAAK2R,qBAAqBnD,EAAMtM,IACzBlC,KAAKiD,OAC7B0M,EAAgB6C,GAAUzF,EAC1BoD,EAAW3N,KAAKgQ,OACX,KAECzF,EADAkD,EAAYlF,EAAQkH,UAAY,IAAIlH,EAAQkH,UAAUK,GAAoBA,EAE1EE,GADAzF,EAAW/M,KAAKkR,kBAAkBjB,IAChBjQ,KAAKiD,OAC7BoP,EAAS7P,KAAKgQ,GACd7C,EAAgB6C,GAAUzF,wGAI9BnF,KAAWhC,EAAU,eAErB5F,KAAK4K,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GACnBwD,EAAK,CACRR,IAAKiP,EAAS1R,OAAM+B,EAAOkB,EAAMR,IAAQiP,GAAYzO,EAAMR,IAC3DJ,SAAQ5C,EAAA,GACHwD,EAAMZ,SACN2M,GAELtK,UAAW0F,EAAQ1F,YAGrB8K,EAAWxP,QAAUX,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcV,OAAQxN,IAAK+M,IAChFkC,EAAS1R,QAAUX,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcX,IAAKvN,IAAKiP,IACvEA,EAAS1R,QAAUX,KAAKyS,cAC1BzS,KAAKqR,kBAAiB,IAc1BN,GAAA7Q,UAAAwS,QAAA,SAAQtP,EAAUgC,WACV2M,EAAU9C,GAAY7L,GAC5B,IAAIP,EAAQkP,GAAZ,KACIY,EAAW,OACf,IAAiB,IAAAC,EAAAtP,EAAAyO,GAAOc,EAAAD,EAAA1Q,QAAA2Q,EAAAzQ,KAAAyQ,EAAAD,EAAA1Q,OAAE,CAArB,IAAMwB,EAAEmP,EAAA1Q,MACXiD,EAASpF,KAAKiD,OAASS,EACvBiP,EAASjP,GAAM0B,uGAEjBwC,KAAW/B,EAAU,iBAAkBzC,GACvCpD,KAAK4K,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GACnBwD,EAAK,CACRZ,SAAQ5C,EAAA,GACHwD,EAAMZ,SACN2P,SAcT5B,GAAA7Q,UAAA4S,KAAA,SAAKC,EAAcC,OACX5P,EAAMpD,KAAKoD,IAAI6P,QACrB7P,EAAI8P,OAAOF,EAAK,EAAI5P,EAAIzC,OAASqS,EAAKA,EAAI,EAAG5P,EAAI8P,OAAOH,EAAM,GAAG,IAEjEnL,KAAW/B,EAAU,eACrB7F,KAAK4K,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GACnBwD,EAAK,CAERZ,SAAQ5C,EAAA,GACHwD,EAAMZ,UAEXI,IAAGA,OAmBP2N,GAAA7Q,UAAAiT,OAAA,SAAOC,GAAP,IAAA5I,EAAAxK,KACE,IAAI6C,EAAQ7C,KAAKoD,KAAjB,KAEMiQ,EAAW/K,EAAU8K,GAGvBhQ,EAAuB,GAQvBP,EALFO,EADEoF,EAAW4K,GACPpT,KAAKoD,IAAIiB,OAAM,SAACyK,GAAY,OAAAsE,EAAQ5I,EAAKxH,SAAS8L,MAElDuE,EAAWpE,GAAYmE,GAAW,QAK1CxL,KAAW/B,EAAU,gBAAiBzC,GACtCpD,KAAK4K,UAAS,SAAEhH,GAA8B,OAAAsL,GAAe,CAAEtL,MAAKA,EAAER,IAAGA,MAC7D,OAARA,GACFpD,KAAK6K,aAAY,GAGnB7K,KAAKsT,eAAelQ,GACpBpD,KAAKgR,cAAc9O,KAAK,CAAEqD,KAAM+L,GAAcT,OAAQzN,IAAGA,OAmB3D2N,GAAA7Q,UAAAqT,aAAA,SAAaC,OACLpQ,EAAM6L,GAAYjP,KAAK8D,QAC7B8D,KAAW/B,EAAU,gBAAiBzC,GACtCpD,KAAK2M,OAAOvJ,EAAG,IAYjB2N,GAAA7Q,UAAAuT,UAAA,SAAUtF,OACFrK,EAASoK,GAAkBC,EAAanO,KAAKoD,IAAKpD,KAAK8D,QAEzDA,IAAW2C,YAIfmB,KAAW/B,EAAU,aAAc/B,GACnC9D,KAAK0T,WAAW5P,KAWlBiN,GAAA7Q,UAAAyT,UAAA,SAA+BvQ,GAA/B,IAAAoH,EAAAxK,KACQ+R,EAAU9C,GAAY7L,GACxBP,EAAQkP,IACOA,EAAQ6B,MAAK,SAAClQ,GAAM,OAA2B,EAA3B8G,EAAK1G,OAAOQ,QAAQZ,OAG3DkE,KAAW/B,EAAU,aAAczC,GACnCpD,KAAK4K,UAAS,SAAChH,OAEPiQ,EAAUlU,MAAMoT,KAAK,IAAIrC,IAAGhO,EAAMkB,EAAY,OAAkBmO,KACtE,OAAA3R,EAAA,GACKwD,EAAK,CACRE,OAAQ+P,QAad9C,GAAA7Q,UAAA4T,aAAA,SAAkC1Q,GAAlC,IAAAoH,EAAAxK,KACQ+R,EAAU9C,GAAY7L,GACxBP,EAAQkP,IACMA,EAAQgC,KAAI,SAACrQ,GAAM,OAA2B,EAA3B8G,EAAK1G,OAAOQ,QAAQZ,OAGzDkE,KAAW/B,EAAU,gBAAiBzC,GACtCpD,KAAK4K,UAAS,SAAChH,GACb,OAAAxD,EAAA,GACKwD,EAAK,CACRE,OAAQnE,MAAMiD,QAAQgB,EAAME,QAAUF,EAAME,OAAOO,OAAM,SAAC2P,GAAa,OAAgC,IAAhCjC,EAAQzN,QAAQ0P,KAAqB,WAclHjD,GAAA7Q,UAAA+T,aAAA,SAAkC7Q,GAEd,SAAZ8Q,EAAef,mBAAUzP,GAAM,OAAA8G,EAAK1G,OAAOuL,SAAS3L,KAAQyP,GAHpE,IAAA3I,EAAAxK,KAEQ+R,EAAU9C,GAAY7L,GAEtB+P,EAASpB,EAAQ1N,OAAO6P,GAAa,IACrC3C,EAAMQ,EAAQ1N,OAAO6P,GAAa,IACxClU,KAAK8T,aAAaX,GAClBnT,KAAK2T,UAAUpC,GACf3J,KAAWhC,EAAU,kBA0BvBmL,GAAA7Q,UAAAiU,cAAA,SAAczG,EAAmB0G,QAAnB,IAAA1G,IAAAA,EAAA,SAAmB,IAAA0G,IAAAA,EAAA,QACzBC,EAAwC,CAAE1L,KAAM,MAAM3I,KAAKyH,UAAaxE,MAAOjD,KAAKiD,OAE1F,OADAjD,KAAKsU,GAAK,IAAIC,GAAc7G,EAAYtN,EAAA,GAAOiU,EAAaD,IACrDpU,KAAKsU,IAIdvD,GAAA7Q,UAAAqN,QAAA,WACEpF,GAAAjI,UAAMqN,QAAO3M,KAAAZ,MACTA,KAAKsU,cAAcvD,IACrB/Q,KAAKsU,GAAG/G,UAEVvN,KAAKgR,cAAc/G,YAIrB8G,GAAA7Q,UAAAyR,qBAAA,SAAqBvE,EAAyBoH,GAC5C,OAAA,GAIFzD,GAAA7Q,UAAAgR,kBAAA,SAAkBjB,GAChB,OAAA,GAIFc,GAAA7Q,UAAAqS,oBAAA,SAAoBtC,GAClB,OAAOA,GAGTzQ,OAAAgC,eAAYuP,GAAA7Q,UAAA,MAAG,KAAf,WACE,OAAOF,KAAK2K,SAASvH,qCAGvB5D,OAAAgC,eAAYuP,GAAA7Q,UAAA,WAAQ,KAApB,WACE,OAAOF,KAAK2K,SAAS3H,0CAGvBxD,OAAAgC,eAAYuP,GAAA7Q,UAAA,SAAM,KAAlB,WACE,OAAOF,KAAK2K,SAAS7G,wCAGfiN,GAAA7Q,UAAAwT,WAAR,SAAmBtQ,GACjBpD,KAAK4K,UAAS,SAAChH,GACb,OAAAxD,EAAA,GACKwD,EAAK,CACRE,OAAQV,OAKN2N,GAAA7Q,UAAAmR,iBAAR,SAAyBE,GAAzB,IAAA/G,EAAAxK,KAIgB,SAARyU,EAAW/Q,SACTF,EAAUgH,EAAKxH,SAASU,GACxB4Q,EAAKI,EAASlK,EAAK8J,GAAGK,qBAAqBnR,GAAWgH,EAAK8J,GAAGK,qBACpE,OAAAvU,IAAA4D,EAAA,IACGwG,EAAKvH,OAAQO,EAAQgH,EAAKvH,OAAMe,GAC9BsQ,QATgB,IAAA/C,IAAAA,GAAA,OAGnBqD,EAFExR,EAAMpD,KAAKoD,IACXsR,EAASlM,EAAWxI,KAAKsU,GAAGK,sBAYhCC,EADErD,EACWvR,KAAKoD,IAAIiB,OAAM,SAACX,GAAM,OAAA+M,GAAYjG,EAAK8J,GAAGtR,SAASU,MAAMuB,IAAIwP,GAE7DrR,EAAI6B,IAAIwP,GAGvBlD,EAAMvR,KAAKsU,GAAG/C,IAAIqD,GAAc5U,KAAKsU,GAAGrD,IAAI2D,IAGtC7D,GAAA7Q,UAAAkR,kBAAR,WACE,OAAOpR,KAAKyS,eAA8D,IAA9ChC,GAAYzQ,KAAKsU,GAAGK,uBAG1C5D,GAAA7Q,UAAAoT,eAAR,SAAuBlQ,GACjBpD,KAAKyS,cACPzS,KAAKsU,GAAGnB,OAAO/P,IAIX2N,GAAA7Q,UAAAuS,WAAR,WACE,OAAOzS,KAAKsU,cAAcC,IAlY5BM,EAAAA,CADCtK,wIA8QDsK,EAAAA,CADCtK,sDACuC,sBAAA,oBAADuK,GAAAA,GAAC9Q,GAAAxE,0EAuH1CuR,IA5iBE,SAAAA,GAAYrD,EAAyC3C,QAAzC,IAAA2C,IAAAA,EAAA,SAAyC,IAAA3C,IAAAA,EAAA,IAArD,IAAAP,EACErC,GAAAvH,KAAAZ,KAAAI,EAAA,GLzCF,CACE4C,SAAU,GACVI,IAAK,GACLiC,SAAS,EACT5C,MAAO,MKqCkCiL,GAAgB3C,IAAQ/K,YADdwK,EAAAO,QAAAA,EAF7CP,EAAAwG,cAAgB,IAAI5J,EAAAA,UAijB9B,WAA8DW,EAAAA,MAAAgJ,IAqB5DwD,GAAArU,UAAA6U,sBAAA,SAAoDN,GAClDzU,KAAK2U,qBAAuBF,GAEhCF,IArBE,SAAAA,GAAY7G,EAAmB0G,eAAnB,IAAA1G,IAAAA,EAAA,SAAmB,IAAA0G,IAAAA,EAAA,IAC7BjM,GAAAvH,KAAAZ,KAAM0N,EAAc0G,IAAYpU,KCrlBpC,SAAgBgV,GAAQxD,EAAiByD,EAAqChS,eACtEoL,EAAS,GACf,GAAI7F,EAAWyM,OACb,IAAqB,IAAAC,EAAA5R,EAAAkO,GAAU2D,EAAAD,EAAAhT,QAAAiT,EAAA/S,KAAA+S,EAAAD,EAAAhT,OAAE,EACA,IAA3B+S,EADKpG,EAAMsG,EAAAhT,QAEbkM,EAAO7L,KAAKqM,4GAGX,KACCuG,EAAQnG,GAAYgG,GAAgBI,OAAM,SAAElS,EAAKK,GAAY,OAAAL,EAAIoO,IAAI/N,IAAU,IAAIkN,SAEzF,IAAqB,IAAA4E,EAAAhS,EAAAkO,GAAU+D,EAAAD,EAAApT,QAAAqT,EAAAnT,KAAAmT,EAAAD,EAAApT,OAAE,CAA5B,IAAM2M,EAAM0G,EAAApT,MACXiT,EAAMI,IAAI3G,EAAO5L,KACnBoL,EAAO7L,KAAKqM,yGAKlB,OAAOR,EAIT,SAAgBoH,KACd,OAAO5J,EAAAA,qBAAoB,SAAE6J,EAAqBC,GAChD,OAAID,IAAmBC,IAIS,IAA5B/S,EAAQ8S,KAA4D,IAA/B9S,EAAQ+S,QAI7C9S,EAAQ6S,KAAmB7S,EAAQ8S,MAKpBC,GAAUD,EAAmBD,KAST,IAHHE,GAAUF,EAAgBC,MAQlE,SAASC,GAAaC,EAAYC,GAMhC,OALkBA,EAAO/B,KAAI,SAACgC,GAE5B,OADgBF,EAAMb,KAAI,SAACgB,GAAY,OAAAA,IAAaD,MACjCtP,oBC/DrBwP,IAAM,MACNC,KAAO,QAIT,SAAgBC,GAAclV,EAAKmV,GACjC,YADiC,IAAAA,IAAAA,EAAeC,GAAMJ,KACtD,SAAgBK,EAAG/W,GACjB,IAAK+W,EAAEzW,eAAeoB,KAAS1B,EAAEM,eAAeoB,GAC9C,OAAO,MAGHsV,EAAyB,iBAAXD,EAAErV,GAAoBqV,EAAErV,GAAKuV,cAAgBF,EAAErV,GAC7DwV,EAAyB,iBAAXlX,EAAE0B,GAAoB1B,EAAE0B,GAAKuV,cAAgBjX,EAAE0B,GAE/DyV,EAAa,EAMjB,OALWD,EAAPF,EACFG,EAAa,EACJH,EAAOE,IAChBC,GAAc,GAETN,GAASC,GAAMH,MAAqB,EAAdQ,EAAkBA,GCfnD,SAAgBC,GAA0C/S,EAAUmH,GAKlE,QAJIjI,EAAM,GACFM,EAAAQ,EAAAR,IAAKJ,EAAAY,EAAAZ,SACL4T,EAAA7L,EAAA6L,SAAUC,EAAA9L,EAAA8L,QAASC,EAAA/L,EAAA+L,OAAQC,EAAAhM,EAAAgM,uBAE1BvW,OACDqO,EAAS7L,EAASI,EAAI5C,IAC5B,IAAKoW,SACH9T,EAAIN,KAAKqM,cAIKI,GAAY2H,GACJhD,MAAK,SAACoD,GAAM,OAAAA,EAAGnI,EAAQrO,MAE7CsC,EAAIN,KAAKqM,IAVJrO,EAAI,EAAGA,EAAI4C,EAAIzC,OAAQH,MAAvBA,GAcT,GAAIsW,EAAQ,KACNG,EAAezO,EAAWsO,GAAUA,EAASX,GAAcW,EAAQC,GACvEjU,EAAMA,EAAIoU,KAAI,SAAEZ,EAAG/W,GAAM,OAAA0X,EAAQX,EAAG/W,EAAGqE,SAGnCjD,EAASwW,KAAKC,IAAIP,GAAW/T,EAAInC,OAAQmC,EAAInC,QAEnD,OAAOA,IAAWmC,EAAInC,OAASmC,EAAMA,EAAImQ,MAAM,EAAGtS,GC3BpD,SAAgB0W,GAA2CzT,EAAUmH,OAC7D9F,EAAM,GACJ2R,EAAA7L,EAAA6L,SAAUC,EAAA9L,EAAA8L,QACVzT,EAAAQ,EAAAR,IAAKJ,EAAAY,EAAAZ,SAEb,IAAK4T,IAAaC,EAChB,OAAO7T,MAEHsU,GAA8B,IAAnBlP,EAAMyO,GAEvB,GAAID,GAAYU,EAEd,QADIC,EAAQ,aACH/W,EAAOgX,GACd,GAAID,IAAUV,oBACRnT,EAAKN,EAAI5C,GACTqO,EAAS7L,EAASU,GACRuL,GAAY2H,GAAUhD,MAAK,SAACoD,GAAM,OAAAA,EAAGnI,EAAQrO,OAE3DyE,EAAIvB,GAAMmL,EACV0I,MAPK/W,EAAI,EAAGgX,EAASpU,EAAIzC,OAAQH,EAAIgX,EAAQhX,IAAG,gBAA3CA,kBAWHiX,EAAcN,KAAKC,IAAIP,GAAWzT,EAAIzC,OAAQyC,EAAIzC,mBAE/CH,OACDkD,EAAKN,EAAI5C,GACTqO,EAAS7L,EAASU,GAExB,IAAKkT,SACH3R,EAAIvB,GAAMmL,aAIII,GAAY2H,GAAUhD,MAAK,SAACoD,GAAM,OAAAA,EAAGnI,EAAQrO,OAE3DyE,EAAIvB,GAAMmL,IAXd,IAASrO,EAAI,EAAGA,EAAIiX,EAAajX,MAAxBA,GAgBX,OAAOyE,EC7CT,SAAgByS,GAASvV,GACvB,MAAwB,iBAAVA,ECchB,SAAgBwV,GAAWjU,EAAIgI,GAC7B,OAAA,SAAgB1I,OACR6L,EAAS7L,EAASU,GAExB,OAAG+M,GAAY5B,GACNpI,UAGLiF,EAIDgM,GAAShM,GACHmD,EAAOnD,GAGT,EAAsBmD,GAPpBA,GCdb,IAAa+I,GAAiB,mBCA9B,QA6BEC,GAAA3X,UAAA4X,OAAA,SAAUpM,OACJqM,EACJ,GAAIvP,EAAWkD,GACbqM,EAAQrM,OACH,GAAIgM,GAAShM,GAClBqM,EAAK,SAAGnU,GAAS,OAAAA,EAAM8H,QAClB,CAAA,GAAI/L,MAAMiD,QAAQ8I,GACvB,OAAO1L,KAAK2L,MACTF,QAAO,SAAC7H,GAAS,OAAAA,IACjBgI,KACCC,EAAAA,qBChDV,SAAgBmM,EAAeC,GAC7B,OAAA,SAAoBC,EAAWC,OACvBC,EAAQ5P,EAAWyP,EAAY,IAErC,OAKO,IALAA,EAAYlE,KAAI,SAACsE,GACtB,OAAGD,EACMC,EAAUH,KAAeG,EAAUF,GAErCD,EAAUG,KAAeF,EAAUE,MDwCjBL,CAAYtM,IACjCzG,EAAAA,IAAG,SAACrB,GACF,OAAI4E,EAAWkD,EAAQ,IACd,EAAmCzG,IAAG,SAACqT,GAAQ,OAAAA,EAAK1U,KAGtD,EAAyByR,OAAM,SAAElS,EAAKoV,GAE3C,OADApV,EAAG,GAAaS,EAAM2U,GACfpV,GACN,OAIT4U,EAAK,SAAGnU,GAAS,OAAAA,GAGnB,OAAO5D,KAAK2L,MAAMF,QAAQsM,IAU5BF,GAAA3X,UAAAsY,cAAA,WACE,OAAOxY,KAAK8X,OAAM,SAAClU,GAAS,OAAA,EAAoCyB,WAUlEwS,GAAA3X,UAAAuY,YAAA,WACE,OAAOzY,KAAK8X,OAAM,SAAClU,GAAS,OAAA,EAAoCnB,SAWlEoV,GAAA3X,UAAAoL,SAAA,WACE,OAAOtL,KAAK2L,MAAMhB,UAcpBkN,GAAA3X,UAAAwY,eAAA,WACE,OAAO1Y,KAAK2L,MAAMG,SAAS3B,gBAW7B0N,GAAA3X,UAAAyY,YAAA,WACE,OAAO3Y,KAAK2L,MAAMG,SAAS3J,OAI7B3C,OAAAgC,eAAIqW,GAAA3X,UAAA,SAAM,KAAV,WACE,OAAOF,KAAKC,YAAY2X,qCAE5BC,IAvHE,SAAAA,GAAsBlM,GAAA3L,KAAA2L,MAAAA,EACpB3L,KAAK4Y,UAAYjN,EACb/D,MAEFyB,EAAYsC,EAAMlE,WAAazH,MElBrC,SAAgB6Y,GAAc9N,EAASgB,GACrChB,EAAQ+L,OAAS/L,EAAQ+L,QAAW/K,GAAUA,EAAO+K,OACrD/L,EAAQgM,YAAchM,EAAQgM,aAAgBhL,GAAUA,EAAOgL,YC+BjE,WAA8GhP,EAAAA,MAAA8P,IAyC5GiB,GAAA5Y,UAAA6Y,UAAA,SACEhO,GADF,IAAAP,EAAAxK,KAKE,YAJA,IAAA+K,IAAAA,EAAA,CACEiO,UAAU,IAGLhZ,KAAK8X,OAAM,SAAClU,GAAS,OAAAA,EAAMZ,WAAU4I,KAAK3G,EAAAA,IAAG,WAAO,OAAAuF,EAAKyO,OAAOlO,OA+BzE+N,GAAA5Y,UAAA+Y,OAAA,SAAOlO,GACL,YADK,IAAAA,IAAAA,EAAA,CAAuCiO,UAAU,EAAOpC,SAAUnQ,UAAWoQ,QAASpQ,YACvFsE,EAAQiO,SACH3B,GAAcrX,KAAKsL,WAAYP,IAExC8N,GAAc9N,EAAS/K,KAAK+L,QAAU/L,KAAK+K,SAEpC4L,GAAgB3W,KAAKsL,WAAYP,KAa1C+N,GAAA5Y,UAAAgZ,WAAA,SAAc9V,EAAesI,GAC3B,OAAKtI,GAAQA,EAAIzC,OAEVX,KAAK8X,OAAM,SAAClU,GAAS,OAAAA,EAAMZ,WAAU4I,KAC1C3G,EAAAA,IAAG,SAACjC,GAAY,OCrItB,SAAgBmW,EAAuBrW,EAAUsW,GAC/C,OAAOtW,EAAIuS,OAAM,SAAEhH,EAAQlM,EAAOkX,EAAOC,OACjC/Q,EAAM6Q,EAAWjX,EAAOkX,EAAOC,GAIrC,OAHI/Q,IAAQ9B,WACV4H,EAAO7L,KAAK+F,GAEP8F,GACN,ID8HiB8K,CAAiB/V,EAAG,SAAEM,GAAM,OAAAiU,GAAUjU,EAAIgI,EAAdiM,CAAuB3U,OACnEyS,MAJ8BrL,EAAAA,GAAG,KAuBrC0O,GAAA5Y,UAAAqZ,aAAA,SAAgBC,EAAmD9N,OAC7DhI,EAAK8V,EAOT,OALIhR,EAAWgR,KAEb,EL1JN,SAAgBC,EAAyB5H,EAA6B7O,eAClE,IAAsB,IAAA0B,EAAApB,EAAA9D,OAAOmF,KAAK3B,IAAS4B,EAAAF,EAAAxC,QAAA0C,EAAAxC,KAAAwC,EAAAF,EAAAxC,OAAE,CAAzC,IAAM4M,EAAQlK,EAAAzC,MAChB,IAAqC,IAAlC0P,EAAU7O,EAAS8L,IACpB,OAAOA,uGAIX,OAAOrI,UKmJSgT,CAAsBD,EAAexZ,KAAKsL,WAAWtI,WAG9DhD,KAAK8X,OAAM,SAAClU,GAAS,OAAAA,EAAMZ,WAAU4I,KAC1C3G,EAAAA,IAAI0S,GAAUjU,EAAIgI,IAClBG,EAAAA,yBAWJiN,GAAA5Y,UAAAyX,UAAA,SAAUjU,GACR,OAAO1D,KAAKsL,WAAWtI,SAAQ,IAUjC8V,GAAA5Y,UAAAwZ,eAAA,WACE,OAAO1Z,KAAK8X,OAAM,SAAClU,GAAS,OAAA,EAAuCE,UAUrEgV,GAAA5Y,UAAAyZ,YAAA,WACE,OAAO3Z,KAAKsL,WAAWxH,QAazBgV,GAAA5Y,UAAA0Z,aAAA,SAAgBlO,GAAhB,IAAAlB,EAAAxK,KACE,OAAI4C,EAAQ5C,KAAK6Z,aACR7Z,KAAK0Z,iBAAiB9N,KAAKkO,EAAAA,UAAS,SAAC1W,GAAO,OAAAoH,EAAK0O,WAAW9V,EAAKsI,MAEnE1L,KAAK0Z,iBAAiB9N,KAAKkO,EAAAA,UAAS,SAAC1W,GAAO,OAAAoH,EAAK+O,aAAanW,EAAKsI,OAW5EoN,GAAA5Y,UAAA2Z,UAAA,WAAA,IAAArP,EAAAxK,KACQmR,EAAWnR,KAAK2Z,cACtB,OAAI/W,EAAQuO,GACHA,EAASlM,IAAG,SAACvB,GAAM,OAAA8G,EAAKc,WAAWtI,SAAQ,KAE7CyF,EAAU0I,GAAYnR,KAAK2X,UAAUxG,GAAY1K,WAW1DqS,GAAA5Y,UAAA6Z,YAAA,SAAYlI,GAAZ,IAAArH,EAAAxK,KACE,OAAOA,KAAK8X,OAAM,SAAClU,GAAS,OAAAA,EAAMZ,WAAU4I,KAAK3G,EAAAA,IAAG,WAAO,OAAAuF,EAAKwP,SAASnI,OAW3EiH,GAAA5Y,UAAA8Z,SAAA,SAASnI,GACP,OAAIrJ,EAAWqJ,GACN7R,KAAKiZ,SAAS5U,OAAOwN,GAAWlR,OAElCX,KAAKsL,WAAWlI,IAAIzC,QAc7BmY,GAAA5Y,UAAA+Z,WAAA,SAAcvO,GACZ,OAAO1L,KAAKka,SAAQ,SAAC9W,GAAO,OAAAA,EAAIA,EAAIzC,OAAS,IAAI+K,IAcnDoN,GAAA5Y,UAAAia,YAAA,SAAezO,GACb,OAAO1L,KAAKka,SAAQ,SAAC9W,GAAO,OAAAA,EAAI,IAAIsI,IAiBtCoN,GAAA5Y,UAAAka,mBAAA,SAAmBrU,GACjB,OAAI0K,GAAY1K,GACP/F,KAAK2L,MAAM0O,oBAEbra,KAAK2L,MAAM0O,oBAAoBzO,KACpCvH,EAAAA,OAAM,SAACiW,GAAM,OAAAA,EAAG/U,OAASQ,IACzBd,EAAAA,IAAG,SAACc,GAAU,OAAAA,EAAO3C,QAkBzB0V,GAAA5Y,UAAAuD,UAAA,SAAU8W,GAAV,IAAA/P,EAAAxK,KACE,OAAIoI,EAAMmS,GAC4B,EAA7Bva,KAAKsL,WAAWlI,IAAIzC,OAGzB6H,EAAW+R,GACNva,KAAKiZ,SAASlF,KAAKwG,GAGxB3X,EAAQ2X,GACHA,EAAa3G,MAAK,SAAClQ,GAAM,OAAA,KAAe8G,EAAKc,WAAWtI,WAG1D,KAAyBhD,KAAKsL,WAAWtI,UAYlD8V,GAAA5Y,UAAAsa,UAAA,SAAU9W,OACFI,EAAS9D,KAAKsL,WAAWxH,OACzB2W,EAAenS,EAAU5E,GAC/B,OAAI/D,MAAMiD,QAAQkB,GACZ2W,EACK3W,EAAOuL,SAAS3L,GAEF,EAAhBI,EAAOnD,OAET8Z,EAAe3W,IAAWJ,EAAK4E,EAAUxE,IAoBlDgV,GAAA5Y,UAAAwa,cAAA,WACE1a,KAAKsU,GAAK,IAAIqG,GAAc3a,KAAK4Y,UAAUtE,KAGrCwE,GAAA5Y,UAAAga,SAAR,SAAoBnC,EAAkCrM,GAAtD,IAAAlB,EAAAxK,KACE,OAAOA,KAAK8X,OAAM,SAAClU,GAAK,OAAIA,EAAS,MAAWgI,KAC9C3G,EAAAA,IAAI8S,GACJlM,EAAAA,uBACAiO,EAAAA,UAAS,SAAEpW,GAAe,OAAA8G,EAAK+O,aAAa7V,EAAIgI,OAGtDoN,IAjWE,SAAAA,GAAYnN,EAA+BZ,QAAA,IAAAA,IAAAA,EAAA,IAA3C,IAAAP,EACErC,GAAAvH,KAAAZ,KAAM2L,IAAM3L,YAD6BwK,EAAAO,QAAAA,EAEzCP,EAAKoO,UAAYjN,IAkWrB,WAA8D5D,EAAAA,MAAA+Q,IAI9D6B,IAHE,SAAAA,GAAYhP,UACVxD,GAAAvH,KAAAZ,KAAM2L,IAAM3L,KEtYM,SAAT4a,GAAgBC,GAA6C,OAAAA,EAAOjP,KAAKvH,EAAAA,OAAM,SAAElC,GAA8C,OAAAA,MAAAA,KCD5I,SAAgBmJ,GAAUwP,EAAU7T,GAElC,OAA+B,IAA3BA,EAAK8T,MAAM,KAAKpa,OACXma,EAEe7T,EACrB8T,MAAM,KACN9H,MAAM,GACN+H,KAAK,KACeD,MAAM,KAAK1F,OAAM,SAAGlS,EAAU8X,GAAkB,OAAA9X,GAAOA,EAAI8X,IAAOH,GCT3F,SAAgBI,GAASJ,EAAU7T,EAAcsB,OACzCwS,EAAQ9T,EAAK8T,MAAM,KAEzB,GAAqB,IAAjBA,EAAMpa,OACR,OAAAP,EAAA,GAAY0a,EAAQvS,GAGtBuS,EAAG1a,EAAA,GAAQ0a,OAELK,EAAYJ,EAAMpa,OAAS,EAiBjC,OAhBwBsG,EAAK8T,MAAM,KAAK9H,MAAM,GAE9BoC,OAAM,SAAElS,EAAK8X,EAAM5B,GAWjC,OAVIA,IAAU8B,EACRlN,GAAS9K,EAAI8X,IACf9X,EAAI8X,GAAK7a,EAAA,GAAQ+C,EAAI8X,GAAU1S,GAE/BpF,EAAI8X,GAAQ1S,EAGdpF,EAAI8X,GAAK7a,EAAA,GAAQ+C,EAAI8X,IAGhB9X,GAAOA,EAAI8X,IACjBH,GAEIA,MCpBLM,IAAoB,EAElBC,GAAoB,IAAI/T,EAAAA,cAAc,GAM5C,SAAgBgU,GAAqB7V,GACnC2V,GAAoB3V,EAGtB,SAAgB8V,KACd,OAAOH,GAeT,SAASI,GAAUC,GACjB,OALF,SAASC,EAAUrT,GACjB,OAAOA,GAAKG,EAAWH,EAAEsT,MAIrBD,CAAUD,IAAiBG,EAAAA,aAAaH,GACnC1I,EAAAA,KAAK0I,GAGPrR,EAAAA,GAAGqR,WCpCVI,GAAA3b,UAAA4b,kBAAA,SAAkBC,QAAA,IAAAA,IAAAA,EAAA,IAIhB,QAHI5Y,EAAM,GAEJwB,EAD6B,EAAhBoX,EAAOpb,OACAob,EAASvc,OAAOmF,KAAKyE,GACtC5I,EAAI,EAAGA,EAAImE,EAAKhE,OAAQH,IAAK,KAChCiH,EAAY9C,EAAKnE,GACH,WAAdiH,IACFtE,EAAIsE,GAAa2B,EAAW3B,GAAWkD,UAI3C,OAAOxH,GAGT0Y,GAAA3b,UAAA8b,kBAAA,SAAkBD,EAA+ChR,OACzDkR,EAAa7b,EAAQ,CAAEgb,mBAAmB,EAAOc,MAAM,GAAYnR,GACzEkR,EAAcb,mBAAqBE,IAAqB,OAEpDa,EAAmBJ,EAEnBrE,GAASqE,KACXI,EAAmBC,KAAKC,MAAK,QAGzBC,EAAO9c,OAAOmF,KAAKwX,GAAkBxb,OAE3C,GAAIsb,EAAcC,KAChB7U,EACGuE,KACCvH,EAAAA,OAAM,SAACsE,GAAQ,OAAAwT,EAAiBtc,eAAe8I,KAC/C4T,EAAAA,KAAKD,IAENxO,UAAS,SAACnF,GAAQ,OAAAS,EAAWT,GAAMiC,UAAS,WAAO,OAAAuR,EAAiBxT,YAEvE,mBAASnI,EAAOmE,OACR8C,EAAY9C,EAAKnE,GACnB4I,EAAW3B,IACb2B,EAAW3B,GAAWmD,UAAS,WAAO,OAAAuR,EAAiB1U,MAHlDjH,EAAI,EAAGmE,EAAOnF,OAAOmF,KAAKwX,GAAmB3b,EAAImE,EAAKhE,OAAQH,MAA9DA,EAAOmE,GAQlBsX,EAAcb,mBAAqBE,IAAqB,IAE5DO,IAjDA,SAAAA,MAmDA,IAAaW,GAAkB,IAAIX,OCrCvBY,GAAAvc,UAAAwc,SAAV,WACE,OAAO1c,KAAK2c,OAIJF,GAAAvc,UAAA0c,SAAV,WACE,OAAO5c,KAAK0c,WAAW9D,WAOf6D,GAAAvc,UAAA2c,cAAV,SAAwB/N,GACtB,OAAOrG,EAAUqG,IAIT2N,GAAAvc,UAAA4c,aAAV,SAAuBhO,EAAeiO,GAAtC,IAAAvS,EAAAxK,KACE,OAAIA,KAAK6c,cAAc/N,GACb9O,KAAK0c,WAAkCnD,aAAazK,GAAUlD,KAAKgP,IAGzEmC,EACK/c,KAAK0c,WAAW5E,OAAM,SAAClU,GAAS,OAAA0H,GAAS1H,EAAO4G,EAAKwS,cAAcD,MAGrE/c,KAAK0c,WAAW5E,UAGf2E,GAAAvc,UAAA+c,UAAV,SAAoBnO,EAAeiO,GACjC,GAAI/c,KAAK6c,cAAc/N,GACrB,OAAQ9O,KAAK0c,WAAkC/E,UAAU7I,OAGrDlL,EAAQ5D,KAAK0c,WAAWpR,WAE9B,OAAIyR,EACKzR,GAAS1H,EAAO5D,KAAKgd,cAAcD,IAGrCnZ,GAGC6Y,GAAAvc,UAAA8c,cAAV,SAAwB/V,GACtB,OAAUjH,KAAKyH,UAAS,IAAIR,GAG9BzH,OAAAgC,eAAcib,GAAAvc,UAAA,YAAS,KAAvB,WACE,OAAOF,KAAK4c,WAAWnV,2CAIfgV,GAAAvc,UAAAgd,YAAV,SAAsB9X,EAAU0J,EAAWiO,GAA3C,IAAAvS,EAAAxK,KACE,GAAIA,KAAK6c,cAAc/N,GACrB9O,KAAK4c,WAAWjQ,OAAOmC,EAAU1J,OAC5B,CACL,GAAI2X,EAIF,YAHA/c,KAAK4c,WAAWhS,UAAS,SAAChH,GACxB,OAAOsX,GAAStX,EAAO4G,EAAKwS,cAAcD,GAAW3X,KAIzDpF,KAAK4c,WAAWhS,UAAS,SAAChH,GAAS,OAAAxD,EAAA,GAAMwD,EAAUwB,OAO/CqX,GAAAvc,UAAAid,QAAR,SAAgBnG,GAAhB,IAAAxM,EAAAxK,KACQod,EAAWpd,KAAK4c,WAAWtQ,MACjCtM,KAAK4c,WAAWtQ,MAAK,eAAI,IAAA+Q,EAAA,GAAAjX,EAAA,EAAAA,EAAA1F,UAAAC,OAAAyF,IAAAiX,EAAAjX,GAAA1F,UAAA0F,GAEvBiF,WAAU,WACR+R,EAASvc,MAAM2J,EAAKoS,WAAYS,GAChCrG,QAIRyF,IAzFE,SAAAA,GAAgCE,EAAuB5Q,GAAvB/L,KAAA2c,MAAAA,EAC1B5Q,GAAUA,EAAOuR,SACf5W,IAAiBJ,YACnBtG,KAAKmd,QAAQpR,EAAOuR,aCuB5BnV,GARMoV,GAAqC,CACzCC,eAAe,EACfC,OAAO,EACPC,UAAW,EACXC,aAAclX,UACdmX,qBAAqB,GAGvBC,IAAgE9V,EAAAA,GAAhEI,GAAgEsU,IA6C9Djd,OAAAgC,eAAIqc,GAAA3d,UAAA,cAAW,KAAf,WACE,OAAOF,KAAK8d,KAAK3T,gDAMnB3K,OAAAgC,eAAIqc,GAAA3d,UAAA,cAAW,KAAf,WACE,OAAOF,KAAK+d,WAAWC,6CAMzBxe,OAAAgC,eAAIqc,GAAA3d,UAAA,UAAO,KAAX,WACE,OAA4B,IAArBF,KAAKge,6CAMdxe,OAAAgC,eAAIqc,GAAA3d,UAAA,SAAM,KAAV,WACE,OAAOF,KAAKge,cAAgBhe,KAAK+d,WAAWE,0CAO9CJ,GAAA3d,UAAAge,aAAA,WAEE,OADA,KAAKnS,OAAOyR,eAAgB,EAC5B,MAOFK,GAAA3d,UAAAie,UAAA,WAEE,OADA,KAAKpS,OAAO0R,OAAQ,EACpB,MAMFI,GAAA3d,UAAAwK,WAAA,SAAWvI,QAAA,IAAAA,IAAAA,GAAA,GACTnC,KAAK4c,WAAWlS,WAAWvI,IAO7B0b,GAAA3d,UAAAyM,OAAA,SAAOyR,GACLpe,KAAK+d,WAAaK,EAClBpe,KAAKqe,QAAQD,EAAS3M,OAOxBoM,GAAA3d,UAAAme,QAAA,SAAQ5M,GAAR,IAAAjH,EAAAxK,KACEA,KAAKse,MAAMrN,IAAIjR,KAAKge,YAAa,CAAE5a,IAAKqO,EAAKxM,IAAG,SAAC4J,GAAU,OAAAA,EAAOrE,EAAKoS,WAAW3Z,WAClFjD,KAAK4c,WAAWrL,IAAIE,IAMtBoM,GAAA3d,UAAAqe,WAAA,SAAWxT,QAAA,IAAAA,IAAAA,EAAA,IACJ/K,KAAKwe,UACR5Y,EAAU,8BAEiB,IAAvBmF,EAAQ0T,aAAyBze,KAAK+L,OAAO6R,qBAAuB7S,EAAQ0T,aAC9Eze,KAAK4c,WAAWzJ,SAGlBnT,KAAKse,MAAQ,IAAII,IACjB1e,KAAK4B,SAAW,IAAI8c,KAEtB1e,KAAKwe,SAAU,GAGjBX,GAAA3d,UAAAye,UAAA,SAAUb,GACR9d,KAAKse,MAAMM,UAAOd,IAMpBD,GAAA3d,UAAAqN,QAAA,SAAQvJ,OAAAU,OAAA,IAAAV,EAAA,GAAAA,EAAEua,EAAA7Z,EAAA6Z,WAAYP,EAAAtZ,EAAAsZ,YAChBhe,KAAK6e,wBACP7e,KAAK6e,uBAAuBC,cAE1BP,GACFve,KAAKue,aAEF9N,GAAYuN,IACfhe,KAAK+e,QAAQf,GAEfhe,KAAKwe,SAAU,GAMjBX,GAAA3d,UAAA8e,aAAA,SAAalB,GACX,OAAO9d,KAAKge,cAAgBF,GAM9BD,GAAA3d,UAAA6e,QAAA,SAAQjB,GACFA,IAAS9d,KAAKge,aAAgBhe,KAAKif,QAAQnB,IAC7C9d,KAAK8d,KAAK5b,KAAMlC,KAAK+d,WAAWC,YAAcF,IAOlDD,GAAA3d,UAAAgf,SAAA,WACMlf,KAAKge,cAAgBhe,KAAK+d,WAAWE,UACvCje,KAAK+e,QAAQ/e,KAAK+d,WAAWC,YAAc,IAO/CH,GAAA3d,UAAAif,SAAA,WACoC,EAA9Bnf,KAAK+d,WAAWC,aAClBhe,KAAK+e,QAAQ/e,KAAK+d,WAAWC,YAAc,IAO/CH,GAAA3d,UAAAkf,YAAA,WACEpf,KAAK+e,QAAQ/e,KAAK+d,WAAWE,WAM/BJ,GAAA3d,UAAAmf,aAAA,WACErf,KAAK+e,QAAQ,IAMflB,GAAA3d,UAAA+e,QAAA,SAAQnB,GACN,OAAO9d,KAAKse,MAAM9I,IAAIsI,IAMxBD,GAAA3d,UAAAof,QAAA,SAAQC,GAAR,IAAA/U,EAAAxK,KACM8d,EAAO9d,KAAK+d,WAAWC,YAC3B,OAAIhe,KAAKif,QAAQnB,GACR9d,KAAKwf,WAAW1B,IAEvB9d,KAAK0K,YAAW,GACTqI,EAAAA,KAAKwM,KAAO3T,KACjBkO,EAAAA,UAAS,SAAE/N,GAMT,OALA+R,EAAO/R,EAAOiS,YACd3T,GAAgB,WACdG,EAAKE,YAAW,GAChBF,EAAKmC,OAAOZ,KAEPvB,EAAKgV,WAAW1B,QAM/BD,GAAA3d,UAAAwc,SAAA,WACE,OAAO1c,KAAK2c,OAGdkB,GAAA3d,UAAAuf,mBAAA,YACkC,IAA5BrX,EAAMpI,KAAKge,eACbhe,KAAK2e,UAAU3e,KAAKge,aACpBhe,KAAK+e,QAAQ/e,KAAKge,eAIdH,GAAA3d,UAAAwf,QAAR,WACE,OAAI1f,KAAKyO,QACA,GAEDzO,KAAKge,YAAc,GAAKhe,KAAK+d,WAAW4B,QAAU,GAGpD9B,GAAA3d,UAAA0f,MAAR,WACE,OAAI5f,KAAK0O,OACA1O,KAAK+d,WAAW8B,MAElB7f,KAAKge,YAAche,KAAK+d,WAAW4B,SAMpC9B,GAAA3d,UAAAsf,WAAR,SAAmB1B,GAAnB,IAAAtT,EAAAxK,KACE,OAAOA,KAAK2c,MAAM5D,UAAU,CAAEC,UAAU,IAAQpN,KAC9C2Q,EAAAA,KAAK,GACLtX,EAAAA,IAAG,SAACjC,OACEob,EAAQhe,EAAA,GACPoK,EAAKuT,WAAU,CAClBtM,KAAMjH,EAAK8T,MAAMwB,IAAIhC,GAAM1a,IAAI6B,IAAG,SAACvB,GAAM,OAAAV,EAASU,OAG9CM,EAAAwG,EAAAuB,OAAE0R,EAAAzZ,EAAAyZ,MAAOD,EAAAxZ,EAAAwZ,cAqBf,OAlBItY,MAAMsF,EAAKuT,WAAW8B,SACE,IAAtBzB,EAASH,SACXG,EAASyB,MAAQzB,EAAS3M,KAAO2M,EAAS3M,KAAK9Q,OAAS,EAExDyd,EAASyB,MAAQzB,EAASuB,QAAUvB,EAASH,SAE/CzT,EAAKuT,WAAW8B,MAAQzB,EAASyB,OAG/BpC,IACFW,EAASrL,KAAOvI,EAAKkV,UACrBtB,EAASpL,GAAKxI,EAAKoV,SAGjBpC,IACFY,EAAS2B,aAYnB,SAASC,EAAcH,EAAeF,GAGpC,QAFMM,EAAM9I,KAAK+I,KAAKL,EAAQF,GAC1B7c,EAAM,GACDtC,EAAI,EAAGA,EAAIyf,EAAKzf,IACvBsC,EAAIN,KAAKhC,EAAI,GAEf,OAAOsC,EAlByBkd,CAAcxV,EAAKuT,WAAW8B,MAAOrV,EAAKuT,WAAW4B,UAGxEvB,MA1LbvJ,EAAAA,CADC9O,EAAO,+IA+LV8X,IA3QE,SAAAA,GAAsBlB,EAAkC5Q,QAAA,IAAAA,IAAAA,EAAA,IAAxD,IAAAvB,EACErC,GAAAvH,KAAAZ,KAAM2c,EAAO,CACXW,QAAO,WACL9S,EAAKgU,SAAU,EACfhU,EAAK+C,QAAQ,CAAEgR,YAAY,EAAMP,YAAa,QAEhDhe,KANkBwK,EAAAmS,MAAAA,EAAkCnS,EAAAuB,OAAAA,EApBxDvB,EAAA5I,SAAW,IAAI8c,IAGPlU,EAAA8T,MAAQ,IAAII,IAGZlU,EAAAuT,WAAuD,CAC7DC,YAAa,EACb2B,QAAS,EACTE,MAAO,EACP5B,SAAU,EACVxM,KAAM,IAOAjH,EAAAgU,SAAU,EAoBlBhU,EAAA2V,WAAa3V,EAAKmS,MAAMnE,gBAAgB5M,KAAKwU,EAAAA,MAAM,IAXjD5V,EAAKuB,OAASvM,OAAOa,OAAOkd,GAAmBxR,GACzC,IAAA/H,EAAAwG,EAAAuB,OAAE2R,EAAA1Z,EAAA0Z,UAAWC,EAAA3Z,EAAA2Z,oBACnBnT,EAAKsT,KAAO,IAAIpU,EAAAA,gBAAgBgU,GAC5B9B,EAAAA,aAAa+B,KACfnT,EAAKqU,uBAAyBlB,EAAa7P,UAAS,WAAO,OAAAtD,EAAK+T,kBA+QtE,OAAa8B,GAAYxC,OCrTyB9V,EAAAA,MAAA0U,IAehD6D,GAAApgB,UAAAqgB,QAAA,SAAQC,EAAqBC,GAI3B,OAHA,KAAKD,KAAOA,EACZ,KAAKC,QAAUA,EACf,KAAKC,WACL,MAGFJ,GAAApgB,UAAAoM,MAAA,SAAMoB,GAAN,MACMvL,EADNqI,EAAAxK,KAGImC,EADEuL,IAGM1N,KAAK2gB,WAAa3gB,KAAK4gB,aAAe,KAAcC,mBAG1D7gB,KAAK2gB,YACPnhB,OAAOmF,KAAK3E,KAAK4gB,cAAc5Z,QAAO,SAAC8Z,OAC/B3e,EAAQqI,EAAKoW,aAAaE,GAChC,GAAInhB,MAAMiD,QAAQT,IAAUqI,EAAKiW,QAAS,KAClCM,EAAYvW,EAAKgW,KAAKQ,SAASF,GACrCtW,EAAKyW,WAAWF,GAChB5e,EAAM6E,QAAO,SAAEqB,EAAG7H,GAChBgK,EAAKgW,KAAKV,IAAIgB,GAAUI,OAAO1gB,EAAIgK,EAAK6S,OAAwB,kBAAchV,SAKtFrI,KAAKwgB,KAAKW,WAAWhf,EAAO,CAAEif,UAAWphB,KAAKqd,OAAO+D,gBAE/C7V,EAAavL,KAAK2gB,WAAazF,GAASlb,KAAK0c,WAAWpR,WAAetL,KAAK4c,WAAWnV,UAAS,IAAIzH,KAAK6gB,gBAAmB1e,KAAM6B,EAAA,IAAMhE,KAAKqd,OAAOgE,SAAUlf,EAAK6B,GACzKhE,KAAKkd,YAAY3R,IAGX+U,GAAApgB,UAAA+gB,WAAR,SAAmBK,GACjB,KAA0B,IAAnBA,EAAQ3gB,QACb2gB,EAAQC,SAAS,IAIbjB,GAAApgB,UAAAshB,oBAAR,SAA4BC,EAAWC,GAAvC,IAAAlX,EAAAxK,KACE,GAAKyhB,EACL,OAAOjiB,OAAOmF,KAAK8c,GAAWpM,OAAM,SAAElS,EAAK2d,OACnC3e,EAAQuf,EAAKZ,GACnB,GAAInhB,MAAMiD,QAAQT,IAAUqI,EAAKiW,QAAS,KAClCkB,EAAUnX,EAAK6S,OAAOuE,kBAC5BpX,EAAKyW,WAAWzW,EAAKgW,KAAKV,IAAIgB,IAC9B3e,EAAM6E,QAAO,SAAEqB,EAAG7H,GAChBgK,EAAKgW,KAAKV,IAAIgB,GAAUI,OAAO1gB,EAAG,EAAsB6H,MAI5D,OADAlF,EAAI2d,GAAYY,EAAKZ,GACd3d,GACN,KAGGmd,GAAApgB,UAAAwgB,SAAR,WAAA,MACMmB,EADNrX,EAAAxK,KAGE,GAAIA,KAAK2gB,WACP,GAAI3gB,KAAK8hB,WACP9hB,KAAK4gB,aAAe5gB,KAAKwhB,oBAAoBxhB,KAAKwgB,KAAKre,MAAOnC,KAAK0c,WAAWpR,YAC9EtL,KAAKwgB,KAAKW,WAAWnhB,KAAK4gB,aAAc,CAAEQ,UAAWphB,KAAKqd,OAAO+D,gBAC5D,CACLS,EAAU7hB,KAAK4c,WAAWnV,UAAS,IAAIzH,KAAK6gB,oBACtCa,EAAOpW,GAAStL,KAAK0c,WAAWpR,WAAYuW,GAClD7hB,KAAK4gB,aAAe5gB,KAAKwhB,oBAAoBE,EAAMA,GACnD1hB,KAAKwgB,KAAKW,WAAWnhB,KAAK4gB,aAAc,CAAEQ,UAAWphB,KAAKqd,OAAO+D,gBAE9D,CACCphB,KAAK0c,WAAWpR,WAAgCtL,KAAKqd,OAAOgE,WAChEzb,EAAU,iCACV5F,KAAKkd,cAAWlZ,EAAA,IAAIhE,KAAKqd,OAAOgE,SAAU,KAAcR,kBAAiB7c,SAGrE7B,EAAQnC,KAAK0c,WAAWpR,WAAWtL,KAAKqd,OAAOgE,SACrDrhB,KAAKwgB,KAAKW,WAAWhf,GAGvBnC,KAAK+hB,YAAc/hB,KAAKwgB,KAAKwB,aAAapW,KAAKqW,EAAAA,aAAajiB,KAAKqd,OAAO4E,eAAenU,UAAS,SAAC3L,OAE3FiD,EADJQ,EAAU,yBAINR,EAFAoF,EAAKmW,WACHnW,EAAKsX,WACC,SAAGle,GAAS,OAAAxD,EAAA,GAAMwD,EAAUzB,IAE5B,SAAGyB,GAAS,OAAAsX,GAAStX,EAAOie,EAAM1f,IAGpC,iBAAS,OAAA6B,EAAA,IAAIwG,EAAK6S,OAAOgE,SAAUlf,EAAK6B,GAElDwG,EAAK0S,YAAY9X,EAASoF,EAAKkS,WAAWpR,gBAI9CgV,GAAApgB,UAAAqN,QAAA,WACEvN,KAAK+hB,aAAe/hB,KAAK+hB,YAAYjD,cACrC9e,KAAKwgB,KAAO,KACZxgB,KAAKygB,QAAU,MAEnBH,IA1GE,SAAAA,GAAsB3D,EAA2BkE,EAA6CxD,QAAA,IAAAA,IAAAA,EAAA,IAA9F,IAAA7S,EACErC,GAAAvH,KAAAZ,KAAM2c,IAAM3c,YADQwK,EAAAmS,MAAAA,EAA2BnS,EAAAqW,gBAAAA,EAA6CrW,EAAA6S,OAAAA,EAE5F7S,EAAK6S,OAAMjd,EAAQ,CAAE6hB,aAAc,IAAKZ,QAAS,YAAaD,WAAW,EAAOQ,kBAAiB,SAAEvZ,GAAK,OAAAmC,EAAKiW,QAAQa,QAAQjZ,KAASgV,GACtI7S,EAAKsX,YAA4C,IAA/BrZ,EAAUoY,GAC5BrW,EAAKmW,WAAajJ,GAASmJ,IAAoBrW,EAAKsX,aC3CxD,SAAgBI,GAAW/f,GACzB,OAAOA,GAASA,EAAMggB,OAAO,GAAG3L,cAAgBrU,EAAM8Q,MAAM,OCoB1DmP,GAAO,GCPX,QAQYC,GAAAniB,UAAAyX,UAAV,SAAoBjU,GAClB,OAAO1D,KAAKgD,SAAS8c,IAAIpc,IAMjB2e,GAAAniB,UAAAuD,UAAV,SAAoBC,GAClB,OAAO1D,KAAKgD,SAASwS,IAAI9R,IAMjB2e,GAAAniB,UAAAoiB,aAAV,SAAuB5e,GAErB,OADA1D,KAAKuN,QAAQ7J,GACN1D,KAAKgD,SAAS4b,UAAOlb,IAMpB2e,GAAAniB,UAAAqiB,aAAV,SAAuB7e,EAAsB8e,GAC3C,OAAOxiB,KAAKgD,SAASiO,IAAIvN,EAAI8e,IAMrBH,GAAAniB,UAAAuiB,OAAV,WACE,OAAOhS,GAAYzQ,KAAKwF,WAAaxF,KAAK2c,MAAMrR,WAAWlI,IAAM6L,GAAYjP,KAAKwF,YAM1E6c,GAAAniB,UAAAwiB,YAAV,SAAsBtf,GACpB,OAAOqN,GAAYrN,GAAOpD,KAAKyiB,SAAWxT,GAAY7L,IAU9Cif,GAAAniB,UAAAyiB,OAAV,SAAiBvf,EAAyBwf,GAA1C,IAAApY,EAAAxK,KAOE,QAPwC,IAAA4iB,IAAAA,EAAA,IAOpCna,EAAUrF,GAIZ,GAAIqN,GAAYzQ,KAAKwF,WAAY,CAC/B,IAAK,IAAIhF,EAAI,EAAGyf,EAAM7c,EAAIzC,OAAQH,EAAIyf,EAAKzf,IAAK,KACxCsO,EAAW1L,EAAI5C,GACrB,IAAiC,IAA7BR,KAAKyD,UAAUqL,GAAqB,CACtCtG,EAAWoa,EAAQC,YAAcD,EAAQC,UAAU/T,OAC7C0T,EAASxiB,KAAK8iB,kBAAkBhU,GACtC9O,KAAKgD,SAASiO,IAAInC,EAAU0T,GAC5Bha,EAAWoa,EAAQG,WAAaH,EAAQG,SAASP,IAIrDxiB,KAAKgD,SAASgE,QAAO,SAAEwb,EAAQ1T,IACE,IAA3B1L,EAAIkB,QAAQwK,KACdtG,EAAWoa,EAAQI,eAAiBJ,EAAQI,aAAaR,GACzDhY,EAAK8X,aAAaxT,eAOhBmU,EAAOhU,GAAYjP,KAAKwF,WAC9B,IAAShF,EAAI,EAAGyf,EAAMgD,EAAKtiB,OAAQH,EAAIyf,EAAKzf,IACpCsO,EAAWmU,EAAKziB,IAEO,EAAzB4C,EAAIkB,QAAQwK,KAA+C,IAA7B9O,KAAKyD,UAAUqL,IAC/CtG,EAAWoa,EAAQC,YAAcD,EAAQC,UAAU/T,GAC7C0T,EAASxiB,KAAK8iB,kBAAkBhU,GACtC9O,KAAKgD,SAASiO,IAAInC,EAAU0T,GAC5Bha,EAAWoa,EAAQG,WAAaH,EAAQG,SAASP,IAEjDxiB,KAAKgD,SAASgE,QAAO,SAAEwb,EAAQ1T,IAEE,IAA3B1L,EAAIkB,QAAQwK,KAAiD,IAA7BtE,EAAK/G,UAAUqL,KACjDtG,EAAWoa,EAAQI,eAAiBJ,EAAQI,aAAaR,GACzDhY,EAAK8X,aAAaxT,WAU5B9O,KAAKyiB,SAASzb,QAAO,SAACtD,GACf8G,EAAK/G,UAAUC,IAAK8G,EAAK+X,aAAa7e,EAAI8G,EAAKsY,kBAAkBpf,OAQlE2e,GAAAniB,UAAAgjB,UAAV,WACE,OAAOljB,KAAK2c,MAAM7E,OAAM,SAAClU,GAAS,OAAAA,EAAMR,OAMhCif,GAAAniB,UAAAwgB,SAAV,SAAmBtd,GACjBpD,KAAK2iB,OAAOvf,IAmBJif,GAAAniB,UAAAijB,UAAV,SAAoB/f,EAAgCggB,GAGlD,QAFMH,EAAOjjB,KAAK0iB,YAAYtf,GAErB5C,EAAI,EAAGyf,EAAMgD,EAAKtiB,OAAQH,EAAIyf,EAAKzf,IAAK,KACzCkD,EAAKuf,EAAKziB,GACZR,KAAKyD,UAAUC,IACjB0f,EAAGpjB,KAAK2X,UAAUjU,MAI1B2e,IA1JE,SAAAA,GAAgC1F,EAAmCnX,GAAnCxF,KAAA2c,MAAAA,EAAmC3c,KAAAwF,UAAAA,EAFzDxF,KAAAgD,SAAW,IAAI0b,ICE3B,WAAqD3W,EAAAA,MAAA0U,IAkCnDjd,OAAAgC,eAAI6hB,GAAAnjB,UAAA,WAAQ,KAAZ,WACE,OAAOF,KAAKsjB,2CAOd9jB,OAAAgC,eAAI6hB,GAAAnjB,UAAA,aAAU,KAAd,WACE,OAAOF,KAAKujB,6CAGd/jB,OAAAgC,eAAI6hB,GAAAnjB,UAAA,UAAO,KAAX,WACE,OAAkC,EAA3BF,KAAKwjB,QAAQC,KAAK9iB,wCAG3BnB,OAAAgC,eAAI6hB,GAAAnjB,UAAA,YAAS,KAAb,WACE,OAAoC,EAA7BF,KAAKwjB,QAAQE,OAAO/iB,wCAG7BnB,OAAAgC,eAAY6hB,GAAAnjB,UAAA,WAAQ,KAApB,WACE,OAAOF,KAAKqd,OAAOsG,+CAIbN,GAAAnjB,UAAA0jB,iBAAR,WACE5jB,KAAK6jB,iBAAiB3hB,KAAKlC,KAAK8jB,WAChC9jB,KAAK+jB,eAAe7hB,KAAKlC,KAAKgkB,UAGhCX,GAAAnjB,UAAAwgB,SAAA,WAAA,IAAAlW,EAAAxK,KACEA,KAAK+jB,eAAiB,IAAIra,EAAAA,iBAAgB,GAC1C1J,KAAKsjB,UAAYtjB,KAAK+jB,eAAe5Z,eAAeyB,KAAKC,EAAAA,wBACzD7L,KAAK6jB,iBAAmB,IAAIna,EAAAA,iBAAgB,GAC5C1J,KAAKujB,YAAcvjB,KAAK6jB,iBAAiB1Z,eAAeyB,KAAKC,EAAAA,wBAE7D7L,KAAKwjB,QAAQS,QAAUjkB,KAAKid,UAAUjd,KAAKkkB,UAAWlkB,KAAK+c,UAC3D/c,KAAKmkB,aAAe,KACjBrH,aAAa9c,KAAKkkB,UAAWlkB,KAAK+c,UAClCnR,KAAKwY,EAAAA,YACLtW,UAAS,SAAE9J,OAAAU,EAAArC,EAAA2B,EAAA,GAACyf,EAAA/e,EAAA,GAAMuf,EAAAvf,EAAA,GACjB,GAAI8F,EAAK/E,KACP+E,EAAK/E,MAAO,MADd,KAOM4e,EAAe7Z,EAAK6S,OAAOiH,WAAWb,EAAMQ,IAE7CzZ,EAAK+Z,YAAcF,IAClB7Z,EAAKgZ,QAAQC,KAAK9iB,SAAW6J,EAAK6S,OAAOmH,SAC3Cha,EAAKgZ,QAAQC,KAAOjZ,EAAKgZ,QAAQC,KAAKxQ,MAAM,IAE9CzI,EAAKgZ,QAAQC,KAAI/gB,EAAO8H,EAAKgZ,QAAQC,KAAI,CAAEA,IAC3CjZ,EAAKgZ,QAAQS,QAAUA,EACvBzZ,EAAKoZ,wBAKbP,GAAAnjB,UAAAukB,KAAA,WACE,GAA+B,EAA3BzkB,KAAKwjB,QAAQC,KAAK9iB,OAAY,CAC1B,IAAAqD,EAAAhE,KAAAwjB,QAAEC,EAAAzf,EAAAyf,KAAMQ,EAAAjgB,EAAAigB,QACRS,EAAWjB,EAAKA,EAAK9iB,OAAS,GACpCX,KAAKwjB,QAAQC,KAAOA,EAAKxQ,MAAM,EAAGwQ,EAAK9iB,OAAS,GAChDX,KAAKwjB,QAAQS,QAAUS,EACvB1kB,KAAKwjB,QAAQE,OAAMhhB,EAAA,CAAIuhB,GAAYjkB,KAAKwjB,QAAQE,QAChD1jB,KAAK2M,WAIT0W,GAAAnjB,UAAAykB,KAAA,WACE,GAAiC,EAA7B3kB,KAAKwjB,QAAQE,OAAO/iB,OAAY,CAC5B,IAAAqD,EAAAhE,KAAAwjB,QAAEC,EAAAzf,EAAAyf,KAAMQ,EAAAjgB,EAAAigB,QACR/hB,EAAOlC,KAAKwjB,QAAQE,OAAO,GAC3BkB,EAAY5kB,KAAKwjB,QAAQE,OAAOzQ,MAAM,GAC5CjT,KAAKwjB,QAAQC,KAAI/gB,EAAO+gB,EAAI,CAAEQ,IAC9BjkB,KAAKwjB,QAAQS,QAAU/hB,EACvBlC,KAAKwjB,QAAQE,OAASkB,EACtB5kB,KAAK2M,OAAO,UAIhB0W,GAAAnjB,UAAA2kB,WAAA,SAAWxL,GACT,KAAIA,EAAQ,GAAKA,GAASrZ,KAAKwjB,QAAQC,KAAK9iB,QAA5C,CAEM,IAAAqD,EAAAhE,KAAAwjB,QAAEC,EAAAzf,EAAAyf,KAAMC,EAAA1f,EAAA0f,OAAQO,EAAAjgB,EAAAigB,QAahBa,EAAUrB,EAAKxQ,MAAM,EAAGoG,GACxBuL,EAASliB,EAAO+gB,EAAKxQ,MAAMoG,EAAQ,GAAE,CAAE4K,GAAYP,GACnDqB,EAAatB,EAAKpK,GACxBrZ,KAAKwjB,QAAQC,KAAOqB,EACpB9kB,KAAKwjB,QAAQS,QAAUc,EACvB/kB,KAAKwjB,QAAQE,OAASkB,EACtB5kB,KAAK2M,WAGP0W,GAAAnjB,UAAA8kB,aAAA,SAAa3L,GACX,KAAIA,EAAQ,GAAKA,GAASrZ,KAAKwjB,QAAQE,OAAO/iB,QAA9C,CAEM,IAAAqD,EAAAhE,KAAAwjB,QAAEC,EAAAzf,EAAAyf,KAAMC,EAAA1f,EAAA0f,OAcRoB,EAAOpiB,EAAO+gB,EAAI,CAdFzf,EAAAigB,SAcgBP,EAAOzQ,MAAM,EAAGoG,IAChD0L,EAAarB,EAAOrK,GACpBuL,EAAYlB,EAAOzQ,MAAMoG,EAAQ,GACvCrZ,KAAKwjB,QAAQC,KAAOqB,EACpB9kB,KAAKwjB,QAAQS,QAAUc,EACvB/kB,KAAKwjB,QAAQE,OAASkB,EACtB5kB,KAAK2M,OAAO,UAQd0W,GAAAnjB,UAAA+kB,KAAA,SAAKxkB,GACH,OAAQ,EAAJA,EAAcT,KAAKglB,aAAavkB,EAAI,GACpCA,EAAI,EAAUT,KAAK6kB,WAAW7kB,KAAKwjB,QAAQC,KAAK9iB,OAASF,QAA7D,GAkBF4iB,GAAAnjB,UAAAglB,MAAA,SAAMC,GACJnlB,KAAKwjB,QAAUhb,EAAW2c,GACtBA,EAAenlB,KAAKwjB,SACpB,CACEC,KAAM,GACNQ,QAAS,KACTP,OAAQ,IAEd1jB,KAAK4jB,oBAGPP,GAAAnjB,UAAAqN,QAAA,SAAQ6X,QAAA,IAAAA,IAAAA,GAAA,GACFA,GACFplB,KAAKklB,QAEPllB,KAAKmkB,aAAarF,eAGpBuE,GAAAnjB,UAAAmlB,WAAA,WACErlB,KAAKyF,MAAO,GAGN4d,GAAAnjB,UAAAyM,OAAR,SAAe5G,QAAA,IAAAuf,IAAAvf,EAAAA,QACb/F,KAAKukB,YAAa,EAClB3e,EAAU,mBAAmBG,GAC7B/F,KAAKkd,YAAYld,KAAKwjB,QAAQS,QAASjkB,KAAKkkB,UAAWlkB,KAAK+c,UAC5D/c,KAAK4jB,mBACL5jB,KAAKukB,YAAa,GAEtBlB,IA3ME,SAAAA,GAAsB1G,EAA+BU,EAAyC6G,QAAzC,IAAA7G,IAAAA,EAAA,IAArD,IAAA7S,EACErC,GAAAvH,KAAAZ,KAAM2c,EAAO,CACXW,QAAO,WAAQ,OAAA9S,EAAK0a,YACpBllB,YAHkBwK,EAAAmS,MAAAA,EAA+BnS,EAAA6S,OAAAA,EAAyC7S,EAAA0Z,UAAAA,EAlBtF1Z,EAAA/E,MAAO,EAEP+E,EAAAgZ,QAAU,CAChBC,KAAM,GACNQ,QAAS,KACTP,OAAQ,IAIFlZ,EAAA+Z,YAAa,EAanBlH,EAAOmH,OAAWnH,EAAOmH,OAASnH,EAAOmH,OAAS,GAClDnH,EAAOiH,WAAajH,EAAOiH,YAAU,WAAW,OAAA,GAEhD9Z,EAAKkW,aClCT,WAAgJ3Y,EAAAA,MAAAsa,IAU9IkD,GAAArlB,UAAAykB,KAAA,SAAKvhB,GACHpD,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEqiB,UAG7BY,GAAArlB,UAAAukB,KAAA,SAAKrhB,GACHpD,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEmiB,UAG7Bc,GAAArlB,UAAA8jB,QAAA,SAAQtgB,GACN,GAAI1D,KAAKyD,UAAUC,GACjB,OAAO1D,KAAK2X,UAAUjU,GAAIsgB,SAI9BuB,GAAArlB,UAAA4jB,UAAA,SAAUpgB,GACR,GAAI1D,KAAKyD,UAAUC,GACjB,OAAO1D,KAAK2X,UAAUjU,GAAIogB,WAI9ByB,GAAArlB,UAAA8kB,aAAA,SAAa5hB,EAAgCiW,GAC3CrZ,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAE0iB,aAAa3L,MAG1CkM,GAAArlB,UAAA2kB,WAAA,SAAWzhB,EAAgCiW,GACzCrZ,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEuiB,WAAWxL,MAGxCkM,GAAArlB,UAAAglB,MAAA,SAAM9hB,GACJpD,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAE4iB,WAG7BK,GAAArlB,UAAAqN,QAAA,SAAQnK,EAAiCgiB,QAAA,IAAAA,IAAAA,GAAA,GACvCplB,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEiL,QAAQ6X,MAGrCG,GAAArlB,UAAAmlB,WAAA,SAAWjiB,GACTpD,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAE+iB,gBAGnBE,GAAArlB,UAAA4iB,kBAAV,SAA4Bpf,GAC1B,OAAA,IAAW2f,GAA0BrjB,KAAK2c,MAAO3c,KAAKqd,OAAQ3Z,IAElE6hB,IApDE,SAAAA,GAAsB5I,EAA8CU,QAAA,IAAAA,IAAAA,EAAA,IAApE,IAAA7S,EACErC,GAAAvH,KAAAZ,KAAM2c,EAAOU,EAAO7X,YAAUxF,YADVwK,EAAAmS,MAAAA,GAA8CnS,EAAA6S,OAAAA,GAE3DmH,OAAS/b,EAAU4U,EAAOmH,QAAUnH,EAAOmH,OAAS,GAC3Dha,EAAKkW,WACLlW,EAAK0Y,YACFtX,KAAKnG,EAAAA,KAAK,IACVqI,UAAS,SAAC1K,GAAO,OAAAoH,EAAKkW,SAAStd,OCCtC,IAAaoiB,GAA0B,CACrClB,WAAU,SAAGmB,EAAMjiB,GAAY,OAAA4Y,KAAKsJ,UAAUD,KAAUrJ,KAAKsJ,UAAUliB,KAGzE,SAAgBmiB,GAAcC,EAAW/D,GAEvC,OAD8BA,EAAK9G,MAAM,KACtB1F,OAAM,SAAEyF,EAAK7Z,GAAQ,OAAC6Z,GAAoB,cAAbA,EAAI7Z,GAAuB6Z,EAAI7Z,GAAOwF,WAAYmf,GAOpG,WAAmD7d,EAAAA,MAAA0U,IAsBjDoJ,GAAA3lB,UAAAoM,MAAA,SAAM+Q,QAAA,IAAAA,IAAAA,EAAA,QACAyI,EAAe9lB,KAAKylB,KACpBjd,EAAW6U,EAAO0I,YAElBD,EADE9lB,KAAK6c,cAAc7c,KAAKkkB,WACX7G,EAAO0I,SAAS/lB,KAAKylB,KAAOzlB,KAAK0c,WAAkC/E,UAAU3X,KAAKkkB,YAElF7G,EAAO0I,SAAS/lB,KAAKylB,KAAOzlB,KAAK0c,WAA4BpR,aAGhF1F,EAAU,wBACV5F,KAAKkd,YAAY4I,EAAc9lB,KAAKkkB,WACpClkB,KAAKgmB,OAAO9jB,QAGd2jB,GAAA3lB,UAAA+lB,QAAA,WAQE,OAPK,KAAKniB,OAIR,KAAK2hB,KAAO,KAAKS,YAHjB,KAAKxF,WACL,KAAK5c,QAAS,GAIhB,KAAKqiB,iBAAgB,GACrB,MAGFN,GAAA3lB,UAAAkmB,QAAA,WACE,QAASpmB,KAAKqmB,MAAMlkB,OAGtB0jB,GAAA3lB,UAAAomB,QAAA,WACE,QAAStmB,KAAKumB,WAGhBV,GAAA3lB,UAAAqN,QAAA,WACEvN,KAAKylB,KAAO,KACZzlB,KAAKmkB,cAAgBnkB,KAAKmkB,aAAarF,cACvC9e,KAAKgmB,QAAUhmB,KAAKgmB,OAAO/b,YAG7B4b,GAAA3lB,UAAAsmB,YAAA,SAAY3E,OACJ4D,EAAOzlB,KAAKumB,UAEZE,EAAmBd,GADR3lB,KAAK0c,WAA4BpR,WACFuW,GAC1C6E,EAAgBf,GAAcF,EAAM5D,GAE1C,OAAO7hB,KAAKqd,OAAOiH,WAAWmC,EAAkBC,IAGxCb,GAAA3lB,UAAAqmB,QAAV,WACE,OAAOvmB,KAAKylB,MAGNI,GAAA3lB,UAAAwgB,SAAR,WAAA,IAAAlW,EAAAxK,KACEA,KAAKylB,KAAOzlB,KAAKkmB,eAEXrL,EAAS7a,KAAKqd,OAAOsG,cACtB3jB,KAAKqd,OAAoB,cAAqBpY,IAAG,SAACgC,GACjD,OAAAuD,EAAKmS,MACF7E,OAAM,SAAClU,GAAS,OAAAA,EAAMqD,KACtB2E,KACC3G,EAAAA,IAAG,SAACsD,GAAO,MAAA,CACTA,IAAGA,EACHoe,WAAY1f,QAIpB,CAACjH,KAAK8c,aAAa9c,KAAKkkB,YAC5BlkB,KAAKmkB,aAAeyC,EAAAA,cAAa/lB,WAAA,EAAA6B,EAAImY,IAClCjP,KAAKnG,EAAAA,KAAK,IACVqI,UAAS,SAAEjB,GACV,IAAI4D,GAAYjG,EAAKib,MAArB,KAEMoB,EAAWha,EAAakH,KAAI,SAACnQ,OAC3B6hB,EAAO7hB,EAAM+iB,WAAanc,EAAKib,KAAK7hB,EAAgB,YAAW4G,EAAKib,KACpEqB,EAAYljB,EAAM+iB,WAAa/iB,EAAM2E,IAAM3E,EAEjD,OAAO4G,EAAK6S,OAAOiH,WAAWmB,EAAMqB,KAGtCtc,EAAK2b,gBAAgBU,OAInBhB,GAAA3lB,UAAAimB,gBAAR,SAAwBC,GACtBpmB,KAAKqmB,MAAMnkB,KAAKkkB,IAGVP,GAAA3lB,UAAAgmB,SAAR,eACMT,EAAoBzlB,KAAKid,UAAUjd,KAAKkkB,WAI5C,OAHIlkB,KAAKqd,OAAOsG,gBACd8B,EAAOzlB,KAAK+mB,iBAAgB,IAEvBtB,GAGDI,GAAA3lB,UAAA6mB,iBAAR,SAAyBlM,GACvB,OAAQ7a,KAAKqd,OAAoB,cAAqBhI,OAAM,SACzD2R,EAAS/f,GAER,OADA+f,EAAQ/f,GAAQ4T,EAAO5T,GAChB+f,GACR,KAIPnB,IApHE,SAAAA,GAAsBlJ,EAA+BU,EAA0C6G,GAA/F,IAAA1Z,EACErC,GAAAvH,KAAAZ,KAAM2c,IAAM3c,KAEZ,GAHoBwK,EAAAmS,MAAAA,EAA+BnS,EAAA6S,OAAAA,EAA0C7S,EAAA0Z,UAAAA,EARvF1Z,EAAA6b,MAAQ,IAAI3c,EAAAA,iBAAgB,GAE5Bc,EAAA1G,QAAS,EACT0G,EAAAwb,OAAS,IAAI5e,EAAAA,QAErBoD,EAAAyc,SAAgCzc,EAAK6b,MAAMlc,eAAeyB,KAAKC,EAAAA,wBAC/DrB,EAAA0c,OAAS1c,EAAKwb,OAAO7b,eAInBK,EAAK6S,OAAMjd,EAAA,GAAQolB,GAA4BnI,GAC3C7S,EAAK6S,OAAOsG,cAAe,KACzBwD,EAAYlY,GAAYzE,EAAK6S,OAAOsG,eACpChH,aAAiB7D,IAAeqO,EAAU9X,SAAS,cAAgB8X,EAAU9X,SAAS,QACxF8X,EAAU3kB,KAAK,OAEjBgI,EAAK6S,OAAOsG,cAAgBwD,WCrClC,WAA0Ipf,EAAAA,MAAAsa,IAmBxI+E,GAAAlnB,UAAA+lB,QAAA,SAAQ7iB,GACN,GAAI,KAAKia,OAAO7X,WAAapC,EAAK,KAC1BwP,EAAU3D,GAAY7L,GAE5B,IAAuB,IADA6L,GAAY,KAAKoO,OAAO7X,WAAWuO,KAAI,SAACrQ,GAAM,OAAuB,EAAvBkP,EAAQtO,QAAQZ,KAEnF,OAAA,KAKJ,OAFA,KAAKyf,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAE2jB,YAC3B,KAAKoB,WAAWnlB,OAChB,MAGFklB,GAAAlnB,UAAAomB,QAAA,SAAQ5iB,GACN,QAAI1D,KAAKgD,SAASwS,IAAI9R,IACL1D,KAAK2X,UAAUjU,GAChB4iB,WAMlBc,GAAAlnB,UAAAoM,MAAA,SAAMlJ,EAAiCia,QAAA,IAAAA,IAAAA,EAAA,IACrCrd,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEgK,MAAM+Q,MAMnC+J,GAAAlnB,UAAAkmB,QAAA,SAAQ1iB,EAAsByG,GAC5B,QAD4B,IAAAA,IAAAA,GAAA,GACxBnK,KAAKgD,SAASwS,IAAI9R,GAAK,KACnBmL,EAAS7O,KAAK2X,UAAUjU,GAC9B,OAAOyG,EAAe0E,EAAOoY,SAAWpY,EAAOuX,UAGjD,OAAO,GAGTgB,GAAAlnB,UAAAonB,UAAA,WACE,OAAOtnB,KAAKunB,kBAGdH,GAAAlnB,UAAAsmB,YAAA,SAAY9iB,EAAsBme,GAChC,GAAI7hB,KAAKgD,SAASwS,IAAI9R,GAAK,KACnB+hB,EAAQzlB,KAAK2X,UAAUjU,GAAY6iB,UAEnCE,EAAmBd,GADT3lB,KAAK2c,MAAMhF,UAAUjU,GACWme,GAC1C6E,EAAgBf,GAAcF,EAAM5D,GAE1C,OAAO7hB,KAAKqd,OAAOiH,WAAWmC,EAAkBC,GAGlD,OAAO,MAGTU,GAAAlnB,UAAAqN,QAAA,SAAQnK,GACNpD,KAAKmjB,UAAU/f,EAAG,SAAEd,GAAK,OAAAA,EAAEiL,YAEtBnK,GACHpD,KAAKqnB,WAAWpd,YAIVmd,GAAAlnB,UAAA4iB,kBAAV,SAA4Bpf,GAC1B,OAAA,IAAWmiB,GAAiB7lB,KAAK2c,MAAO3c,KAAKqd,OAAQ3Z,IAG/C0jB,GAAAlnB,UAAAqnB,eAAR,mBACQC,EAAcxnB,KAAK0iB,kBACzB,IAAiB,IAAA+E,EAAAnkB,EAAAkkB,GAAWE,EAAAD,EAAAvlB,QAAAwlB,EAAAtlB,KAAAslB,EAAAD,EAAAvlB,OAAE,CAAzB,IAAMwB,EAAEgkB,EAAAvlB,MACX,GAAInC,KAAK2X,UAAUjU,GAAI0iB,UACrB,OAAO,uGAGX,OAAO,GAEXgB,IAxFE,SAAAA,GAAsBzK,EAA4CU,QAAA,IAAAA,IAAAA,EAAA,IAAlE,IAAA7S,EACErC,GAAAvH,KAAAZ,KAAM2c,EAAOU,EAAO7X,YAAUxF,YADVwK,EAAAmS,MAAAA,EAA4CnS,EAAA6S,OAAAA,EAN1D7S,EAAA6c,WAAa,IAAIjgB,EAAAA,QACzBoD,EAAAmd,WAAkCC,EAAAA,MAAMpd,EAAKmS,MAAM7E,OAAM,SAAClU,GAAS,OAAAA,EAAMZ,WAAWwH,EAAK6c,WAAWld,gBAAgByB,KAClHic,EAAAA,UAAU,GACV5iB,EAAAA,IAAG,WAAO,OAAAuF,EAAK+c,oBAKf/c,EAAK6S,OAAMjd,EAAA,GAAQolB,GAA4BnI,GAE/C7S,EAAKkW,WACLlW,EAAK0Y,YACFtX,KAAKnG,EAAAA,KAAK,IACVqI,UAAS,SAAC1K,GACT+E,GAAAjI,UAAMyiB,OAAM/hB,KAAA4J,EAACpH,EAAK,CAAE2f,SAAQ,SAAEP,GAAU,OAAAA,EAAOyD,yBCnBrDrV,OAAA,EACAkX,YAAA,EACAC,YAAA,EACAC,eAAA,EACAC,eAAA,EACAC,eAAA,GCQF,SAAgBC,GAAgCC,EAAyCC,EAA6CvN,EAAsB7X,OACtJqlB,EAEJ,QAH0J,IAAArlB,IAAAA,EAAA6N,IAGtJtI,EAAW6f,GACbC,EAAYD,MACP,KACCxY,EAAMZ,GAAYoZ,GACxBC,EAAS,SAAGC,GAAQ,OAAsD,IAAtD1Y,EAAIR,SAASpB,GAASsa,GAAQA,EAAKtlB,GAASslB,IAGpD,SAARxC,EAAWniB,GACf,OAAAA,EAAMqB,IAAG,SAAC4J,GACR,OAA0B,IAAtByZ,EAAUzZ,GACLZ,GAASY,QAEPA,EACAiM,GAELA,EAGCjM,IAGX,OAAIjM,EAAQwlB,GACHrC,EAASqC,GAGlB,SAAO1G,SACL,OAAA1d,EAAA,IACE,GAAuB+hB,EAASrE,EAAK0G,OC/B3C,SAAgBI,GAA6BJ,EAAyCnY,EAA4BlF,QAAA,IAAAA,IAAAA,EAAA,IAGrG,SAAL0d,EAAQ7kB,GAAS,OAACmH,EAAQgE,QAAOrM,EAAOoC,EAAiBlB,GAAS,IAAElB,EAAUkB,GAAS,GAAQkB,OAF/FA,EAAcmK,GAAYgB,GAIhC,OAAIrN,EAAQwlB,GACHK,EAAML,GAGf,SAAOxkB,SACL,OAAAI,EAAA,IACE,GAAsCykB,EAAM7kB,EAAMwkB,qNC7BxD,oQ3CiHA,SAAgBM,GAAmBxmB,GACjC,OAAA,SAAgB2Y,GACd,OAAOA,EAAOjP,KAAK+c,EAAAA,IAAG,SAACxmB,GAAS,OAAAkI,GAAgB,WAAO,OAAAnI,EAAKC,oNFrGhE,SAAgBymB,GAAYhnB,GAC1B,OAAA,SAAgB3B,GACdA,EAAYgJ,GAAa,CAAEhG,MAAO,MAElC,IAAK,IAAIzC,EAAI,EAAGmE,EAAOnF,OAAOmF,KAAK/C,GAAWpB,EAAImE,EAAKhE,OAAQH,IAAK,KAC5DS,EAAM0D,EAAKnE,GAEL,SAARS,EACFhB,EAAYgJ,GAAsB,UAAIrH,EAASX,GAE/ChB,EAAYgJ,GAAWhI,GAAOW,EAASX,oBqBd/C,SAAgB4nB,GAAejnB,GAC7B,OAAA,SAAgB3B,GACdA,EAAY2X,IAAkB,GAC9B,IAAK,IAAIpX,EAAI,EAAGmE,EAAOnF,OAAOmF,KAAK/C,GAAWpB,EAAImE,EAAKhE,OAAQH,IAAK,KAC5DS,EAAM0D,EAAKnE,GACjBP,EAAY2X,IAAgB3W,GAAOW,EAASX,wChCHlD,SAAgB6nB,GAAY/c,GAC1B1F,EAAMjG,EAAA,GAAQiG,EAAW0F,kJyCkE3B,SAAgBgd,GAAa1L,OACrBhJ,EAA+B,CACnCpT,IAAK,cACL+nB,oBAAoB,EACpBC,QAAUrgB,IAAqCC,aAAjBwU,EAAO4L,QACrCC,YAAa9M,KAAKC,MAClB8M,UAAW/M,KAAKsJ,UAChB0D,QAAS,GAITC,QAAS,GACTC,kBAAkB,EAClBC,iBAAgB,SAAW9hB,EAAW7D,GACpC,OAAOA,GAET4lB,eAAc,SAAW/hB,EAAW7D,GAClC,OAAOA,GAETwX,kBAAmBG,GACnBkO,yBAAwB,2BAAQ5O,GAAU,OAAAA,KAGtC7W,EAAAxE,OAAAa,OAAA,GAAAgU,EAAAgJ,GAAE4L,EAAAjlB,EAAAilB,QAASD,EAAAhlB,EAAAglB,mBAAoBE,EAAAllB,EAAAklB,YAAaC,EAAAnlB,EAAAmlB,UAAWC,EAAAplB,EAAAolB,QAASC,EAAArlB,EAAAqlB,QAASpoB,EAAA+C,EAAA/C,IAAKsoB,EAAAvlB,EAAAulB,iBAAkBD,EAAAtlB,EAAAslB,iBAAkBG,EAAAzlB,EAAAylB,yBAA0BD,EAAAxlB,EAAAwlB,eAAgBpO,EAAApX,EAAAoX,kBAMlK,KAAKpS,GAAiBggB,IAAwBC,EAA9C,KAIIS,EAFEC,EAA8B,EAAjBP,EAAQzoB,OACrBipB,EAA8B,EAAjBP,EAAQ1oB,OAG3B,GAAIgpB,GAAcC,EAChB,MAAM,IAAI3hB,EAAW,0CAGnB0hB,IACFD,EAAgBN,EAAQ/T,OAAM,SAC3BlS,EAAK0e,GACArZ,EAAWqZ,GACb1e,EAAI0mB,IAAIrnB,KAAKqf,GAGb1e,EADkB0e,EAAK9G,MAAM,KAAK,IACjB8G,EAEnB,OAAO1e,GAET,CAAE0mB,IAAK,UAIP9N,EAAgC,GAChC5Y,EAAM,GACN2mB,EAAgC,GAE9BC,EAAS,GAUTC,EAAkBphB,KAAqBqgB,IAAYpgB,c/B5I7B,WAC5B,IACE,MAAiC,oBAAnBohB,eACd,MAAAjmB,GACA,OAAO,G+BwIkEkmB,IAAuBjB,IAAYgB,eAgF9G,OA9EAzO,GAAUyN,EAAQkB,QAAQlpB,IAAM6M,UAAS,SAAE3L,OACrCioB,EAAenc,GAAS9L,GAASA,EAAQ+mB,EAAY/mB,GAAS,MAElE,SAASkoB,EAAKC,GACZF,EAAqB,OAAChqB,EAAA,GAASgqB,EAAqB,QAAK,GAAQE,GACjEF,EAAe5qB,OAAOa,OAAO,GAAI+pB,EAAcjnB,GAE/C4mB,EAAOvnB,KAAKymB,EAAQsB,QAAQtpB,EAAK+oB,EAAiBb,EAAUiB,GAAgBA,IAjBhF,SAASI,EAAMniB,GACbmT,GAAUnT,GAAGyF,UAAS,eACd5L,EAAO6nB,EAAOU,QACpBvoB,GAAQsoB,EAAMtoB,KAedsoB,CAAMT,EAAOU,SAGf,SAAS3c,EAAUrG,EAAWoa,GAC5B9F,EAAOtU,GAAa2B,EAAW3B,GAC5BgE,QAAO,SAAC7H,GAAS,OAAA0H,GAAS1H,EAAOie,KACjCjW,KACCnG,EAAAA,KAAK,GACLpB,EAAAA,OAAM,WAAO,OAAwB,IAAxB+W,MACbqO,KAED3b,UAAS,SAAC2D,GACTtO,EAAIsE,GAAa8hB,EAAiB9hB,EAAWgK,GAC7CiZ,QAAQ1lB,UAAU2W,KAAI,iBAAO,OAAA0O,IAAIrmB,EAAA,IAAIyD,GAAY2B,EAAW3B,GAAWqE,SAASR,WAAUtH,QAIhG,SAAS2mB,EAAWljB,EAAWkE,EAAOkW,GACpC,GAAIpa,KAAa2iB,EAAc,CAC7BvkB,EAAU,iBACV8F,EAAMf,UAAS,SAAChH,GACd,OAAOsX,GAAStX,EAAOie,EAAM2H,EAAe/hB,EAAW2iB,EAAa3iB,WAEhEqD,IAAWsf,EAAqB,QAAIA,EAAqB,OAAE3iB,GACjE2B,EAAW3B,GAAWoD,YAAYC,EAAU,CAAEE,YAAY,KAI9D8e,EAActnB,KACZ2E,EAAc2G,UAAS,SAACrG,SAClBsU,EAAOtU,MACgB,IAArB6hB,GACFe,IAAIrmB,EAAA,IAAIyD,IAAY,EAAKzD,IAE3B+X,EAAOtU,GAAWqX,qBACX/C,EAAOtU,OAKpBqiB,EAActnB,KACZ6E,EAAWyG,UAAS,SAACrG,GACnB,KAAkB,WAAdA,GAA2BmiB,GAAcP,EAAQha,SAAS5H,IAA9D,KAIMkE,EAAQvC,EAAW3B,GACzB,GAAIkiB,EAAY,KACV9H,EAAO6H,EAAcjiB,GAEzB,IAAKoa,EAAM,CAET,IADsB6H,EAAcG,IAAI9V,KAAI,SAACiD,GAAM,OAAAA,EAAGvP,KAIpD,OAFAoa,EAAOpa,EAKXkjB,EAAWljB,EAAWkE,EAAOkW,GAC7B/T,EAAUrG,EAAWoa,QAErB8I,EAAWljB,EAAWkE,EAAOlE,GAC7BqG,EAAUrG,EAAWA,OAK3B4T,GAAkBnZ,SAGb,CACLqL,mBACEuc,EAAc9iB,QAAO,SAACzG,GAAK,OAAAA,EAAEue,gBAC7B,IAAK,IAAIte,EAAI,EAAGmE,EAAOnF,OAAOmF,KAAKoX,GAASvb,EAAImE,EAAKhE,OAAQH,IAAK,KAC1DiH,EAAY9C,EAAKnE,GACvBub,EAAOtU,GAAWqX,cAEpB/C,EAAS,IAEXmJ,iBACE+D,EAAQ/D,SAEVzG,oBAAWhX,GACLW,EAAMX,GACM+T,GAAUyN,EAAQsB,QAAQtpB,EAAK,OACvC6M,YAIR0N,GADcyN,EAAQkB,QAAQlpB,IACb6M,UAAS,SAACzF,OACnB+hB,EAAelB,EAAY7gB,GAAK,MAElC+hB,EAAa3iB,YACR2iB,EAAa3iB,GACN+T,GAAUyN,EAAQsB,QAAQtpB,EAAKkoB,EAAUiB,KACjDtc,4CA7OhB,SAAgB8c,KACd,OAAOvP,GAAkBlR,gCMS3B,SAAgB0gB,GAAcC,EAAyD/f,GACrF,QADqF,IAAAA,IAAAA,EAAA,KACjF/B,GAEC,OAAgB+hB,6BAArB,CAIA3I,GAAKzhB,QACHyhB,GAAKpb,QAAO,SAACzG,GACPA,EAAEue,YACJve,EAAEue,cAEFve,GAAKA,MAIOuqB,GAAmBA,EAAqB,OAGxDA,EAAkBA,GAAmB,IACZE,IAAG,SAAG5H,GAAM,OAAAA,KACrCrY,EAAO,OAIHmF,EAAS1Q,OAAOa,OAAO,GADuC,CAAEsI,KAAM,QAASsiB,SAAS,EAAMC,gBAAiB,IACpEngB,GAC3CmgB,EAAkBhb,EAAOgb,gBACzBC,EAAW,OAAgBJ,6BAA6BK,QAAQlb,GAClEmb,EAAW,GAETC,EAAS,SAAG7jB,GAChB,OAAKyjB,EAAgBvqB,SAIwB,EAAtCuqB,EAAgB5mB,QAAQmD,IAGjC2a,GAAK5f,KACH6E,EAAWyG,UAAS,SAACrG,UACU,IAAzB6jB,EAAU7jB,KACd4jB,EAAQjrB,EAAA,GACHirB,IAAQrnB,EAAA,IACVyD,GAAY2B,EAAW3B,GAAWkD,SAAQ3G,IAE7CmnB,EAASI,KAAK,CAAEhmB,KAAM,IAAI2c,GAAWza,GAAU,cAAgB4jB,OAInEjJ,GAAK5f,KACH2E,EAAc2G,UAAS,SAACrG,IACO,IAAzB6jB,EAAU7jB,YACP4jB,EAAS5jB,GAChB0jB,EAASI,KAAK,CAAEhmB,KAAM,IAAIkC,EAAS,oBAAsB4jB,OAI7DjJ,GAAK5f,KACH+E,EAAcuG,UAAS,SAACrG,SACtB,IAA6B,IAAzB6jB,EAAU7jB,GAAd,CACQ,IAAAlC,EAAAD,EAAAC,KAAMC,EAAAF,EAAAE,UAEd,GAFyBF,EAAAG,KAGvBK,GAAc,OADhB,KAKM6F,EAAQvC,EAAW3B,GACzB,GAAKkE,EAAL,CAIA,IAAwB,IAApBZ,EAAQkgB,SAAqBI,EAAS5jB,GAExC,GADgB2U,KAAKsJ,UAAU/Z,EAAMhB,YAAcyR,KAAKsJ,UAAU2F,EAAS5jB,IAC9D,OAGf4jB,EAAQjrB,EAAA,GACHirB,IAAQrnB,EAAA,IACVyD,GAAYkE,EAAMhB,SAAQ3G,QAGvBwnB,EAAYtJ,GAAWza,GACzBgkB,EAAMnjB,EAAU9C,GAAa,IAAIgmB,EAAS,OAAOjmB,EAAI,UAAUC,EAAS,IAAM,IAAIgmB,EAAS,OAAOjmB,EAQtG,GANIwF,EAAQ2gB,WACVjf,QAAQkf,MAAMF,GACdhf,QAAQmf,QACRnf,QAAQof,YAGN9gB,EAAQ+gB,mBAAZ,KACQC,EAAiBvsB,OAAOmF,KAAK0mB,GAChCnU,OACA7B,OAAM,SAAElS,EAAKsE,GAEZ,OADAtE,EAAIsE,GAAa4jB,EAAS5jB,GACnBtE,GACN,IAELgoB,EAASI,KAAK,CAAEhmB,KAAMkmB,GAAOM,QAI/BZ,EAASI,KAAK,CAAEhmB,KAAMkmB,GAAOJ,SAIjCjJ,GAAK5f,KACH2oB,EAASrd,UAAS,SAAC5F,GACjB,GAAqB,aAAjBA,EAAQ3C,KAAqB,CAG/B,GAAoB,WAFA2C,EAAQ8jB,QAAQzmB,KAIlC,YADA4lB,EAASc,KAAKZ,GAIhB,GAAInjB,EAAQtE,MAEV,QADMsoB,EAAY9P,KAAKC,MAAMnU,EAAQtE,kBAC5BpD,EAAOmE,OACR8C,EAAY9C,EAAKnE,GACnB4I,EAAW3B,IACb,EAAgCujB,IAAG,WACjC5hB,EAAW3B,GAAWmD,UAAS,WAAO,OAAAshB,EAAUzkB,KAAY,MAJzDjH,EAAI,EAAGmE,EAAOnF,OAAOmF,KAAKunB,GAAY1rB,EAAImE,EAAKhE,OAAQH,MAAvDA,EAAOmE,oMUzI1B,SAAgBwnB,KACd,MAAO,aAAazZ,QAAQ,QAAO,SAAEvR,OAC7BC,EAAqB,GAAhB+V,KAAKiV,SAAiB,EAEjC,OADW,KAALjrB,EAAWC,EAAS,EAAJA,EAAW,GACxBirB,SAAS,yDCXtB,SAAgBC,GAAiBtpB,EAAeC,gBAAA,IAAAA,IAAAA,EAAA6N,QACxC1N,EAAM,OACZ,IAAqB,IAAAC,EAAAC,EAAAN,GAAQO,EAAAF,EAAAnB,QAAAqB,EAAAnB,KAAAmB,EAAAF,EAAAnB,OAAE,CAA1B,IAAM2M,EAAMtL,EAAApB,MACfiB,EAAIZ,KAAKqM,EAAO5L,yGAElB,OAAOG,6SCST,SAAgBmpB,GAAYxhB,GAK1BA,EAAUvL,OAAOa,OAAO,GAJY,CAClCgpB,QAAS,IAG2Bte,OAChCgR,EAASvc,OAAOmF,KAAKyE,GAE3BiB,GAAgB,uBACd,IAAoB,IAAAmiB,EAAAlpB,EAAAyY,GAAM0Q,EAAAD,EAAAtqB,QAAAuqB,EAAArqB,KAAAqqB,EAAAD,EAAAtqB,OAAE,CAAvB,IAAMyJ,EAAK8gB,EAAAtqB,MACR5B,EAAI6I,EAAWuC,GAChBZ,EAAQse,SAGmC,IAA1Cte,EAAQse,QAAQ/kB,QAAQ/D,EAAEkH,YAC5BlH,EAAE+L,QAHJ/L,EAAE+L,8OC1BV,SAAgBogB,GAASvqB,GACvB,OAAQS,EAAQT,IAA2C,GAAjCA,EAAQwqB,WAAWxqB,GAAS,uJzDFxD,SAAgByqB,KACd/kB,EAAAA,SAAU,qCkDwHZ,SAAgBglB,GACdplB,EACA1B,EACAsX,OAOM1R,EAAQvC,EAAW3B,GAEzB,GAAIW,EAAMuD,GACR,MAAM,IAAI1D,EAAcR,EAAS,kBAGnC,OAAQ1B,GACN,KAAK+mB,GAAa/E,YACR,IAAAiE,EAAA,EAAAA,QAER,YADA,EAAuB/a,IAAI+a,EAAQva,MAGrC,KAAKqb,GAAahF,YACRkE,EAAA,EAAAA,QAER,YADA,EAAuBza,IAAIya,EAAQva,KAAMua,EAAQ3O,QAInD,KAAKyP,GAAa9E,eACRgE,EAAA,EAAAA,QAER,YADA,EAAuBrf,OAAOqf,EAAQxmB,UAAWwmB,EAAQva,MAI3D,KAAKqb,GAAa7E,eACR+D,EAAA,EAAAA,QAER,YADA,EAAuB7Y,OAAO6Y,EAAQxmB,WAIxC,KAAKsnB,GAAa5E,eAShB,aARQ8D,EAAA,EAAAA,SACIxmB,UACV,EAAuBoM,OAAOoa,EAAQxmB,UAAWwmB,EAAQva,MAChD9R,MAAMiD,QAAQopB,EAAQva,MAC/B,EAAuBW,WAAW4Z,EAAQva,MAE1C,EAAuBW,WAAW,CAAC4Z,EAAQva,QAK/C,KAAKqb,GAAalc,OACRob,EAAA,EAAAA,QAER,YADA,EAAuBrf,OAAOqf,EAAQva,uEQjK5C,SAAgBsb,GAAgCjqB,EAAWY,EAAQoX,EAAuB7X,cAAA,IAAAA,IAAAA,EAAA6N,QAClFkc,EAAiB/e,GAAS6M,GAEhC,OADqBhY,EAAIiR,KAAI,SAAClF,GAAU,OAACme,EAAiBne,EAAO5L,KAAWS,EAAKmL,IAAWnL,IAEnFykB,GAAYrlB,EAAKY,EAAIoX,EAAK7X,GAE1BulB,GAAS1lB,EAAKkqB,EAAc5sB,EAAA,GAAQ0a,IAAG9W,EAAA,IAAGf,GAAQS,EAAEM,IAAK8W,gBnC0EpE,SAAgBmS,GAAahY,EAA8ChS,GACzE,OAAA,SAAgB4X,GACd,OAAOA,EAAOjP,KACZ3G,EAAAA,IAAG,SAAEuM,GAEH,OAA4B,IAAxB5O,EAAQ4O,GACHA,EAEFwD,GAAKxD,EAAYyD,EAAgBhS,GAAS6N,MAEnD2E,KACAxQ,EAAAA,IAAG,SAAC9C,GACF,OAAuB,IAAnBS,EAAQT,GACHA,EAGLS,EAAQqS,IAAmBzM,EAAWyM,GACjC9S,EAGFA,EAAM,mEoC9FrB,SAAgB+qB,GAAgC9E,EAAyC+E,EAAyClqB,OAC5HmqB,EACAC,EAWJ,YAbgI,IAAApqB,IAAAA,EAAA6N,IAK9Huc,EADE7kB,EAAW2kB,GCzBjB,SAAgBG,EAAIC,GAClB,OAAA,eAAgB,IAAApnB,EAAA,GAAAC,EAAA,EAAAA,EAAA1F,UAAAC,OAAAyF,IAAAD,EAAAC,GAAA1F,UAAA0F,GACd,OAAQmnB,EAAI1sB,WAAA,EAAA6B,EAAIyD,KDwBLmnB,CAAIH,IAEfC,EAAcne,GAAW,GACjB,SAAGzL,GACT,OAA8E,IAAvE4pB,EAAY/d,SAASpB,GAASzK,GAAWA,EAAQP,GAASO,KAIjE7D,MAAMiD,QAAQwlB,GACTA,EAAU/jB,OAAOgpB,GAG1B,SAAOzpB,SACL,OAAAI,EAAA,IACE,GAAuBJ,EAAMwkB,GAAW/jB,OAAOgpB,2BErBrD,SAAgBG,GAA6C7hB,EAA2BZ,GACtF,YADsF,IAAAA,IAAAA,EAAA,IAC/E,IAAI+N,GAAmBnN,EAAOZ,wBALvC,SAAgB0iB,GAA6C/f,EAA8B3C,GACzF,OAAO,IAAIgG,GAAmBrD,EAAc3C,kBAL9C,SAAgB2iB,GAAmB/hB,GACjC,OAAO,IAAIkM,GAAalM,kBAL1B,SAAgBgiB,GAAmBjgB,EAA8B3C,GAC/D,OAAO,IAAIN,GAAaiD,EAAc3C,gBCUxC,SAAgB6iB,GAAajiB,EAAckiB,EAAyB9iB,GAClE,YADkE,IAAAA,IAAAA,EAAA,CAAmC+iB,UAAU,IAC3GniB,EAAMG,SAAS3J,MACV4I,EAAQ+iB,SAAW1jB,EAAAA,GAAG3D,WAAasnB,EAAAA,MAErCF,oBCjBT,SAAgBG,GAAsCC,GACpD,OAAOrH,EAAAA,cAAcqH,GAAariB,KAAKic,EAAAA,UAAU,qCCHnD,SAAgBnd,GAAWiB,GACzB,OAAA,SAAmBkP,GACjB,OAAOqT,EAAAA,MAAK,WAEV,OADAviB,EAAMjB,YAAW,GACVmQ,EAAOjP,KAAKuiB,EAAAA,SAAQ,WAAO,OAAAxiB,EAAMjB,YAAW","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// @internal\nexport function isArray<T>(value: any): value is T[] {\n  return Array.isArray(value);\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isEmpty<T>(arr: T) {\n  if (isArray(arr)) {\n    return arr.length === 0;\n  }\n  return false;\n}\n","import { PreAddEntity } from './types';\n\n// @internal\nexport function toEntitiesObject<E>(entities: E[], idKey: string, preAddEntity: PreAddEntity<E>) {\n  const acc = {\n    entities: {},\n    ids: []\n  };\n\n  for (const entity of entities) {\n    // evaluate the middleware first to support dynamic ids\n    const current = preAddEntity(entity);\n    acc.entities[current[idKey]] = current;\n    acc.ids.push(current[idKey]);\n  }\n\n  return acc;\n}\n","import { EntityState, ID } from './index';\n\n// @internal\nexport function hasEntity<E>(entities: EntityState<E>, id: ID) {\n  return entities.hasOwnProperty(id);\n}\n","import { ActiveState, EntityState, ID, IDS, MultiActiveState } from './types';\nimport { hasEntity } from './hasEntity';\nimport { isArray } from './isArray';\n\n// @internal\nexport function hasActiveState<E>(state: EntityState<E>): state is EntityState<E> & (ActiveState | MultiActiveState) {\n  return state.hasOwnProperty('active');\n}\n\n// @internal\nexport function isMultiActiveState(active: IDS): active is ID[] {\n  return isArray(active);\n}\n\n// @internal\nexport function resolveActiveEntity<E>({ active, ids, entities }: EntityState<E> & (ActiveState | MultiActiveState)) {\n  if (isMultiActiveState(active)) {\n    return getExitingActives(active, ids);\n  }\n\n  if (hasEntity(entities, active) === false) {\n    return null;\n  }\n\n  return active;\n}\n\n// @internal\nexport function getExitingActives(currentActivesIds: ID[], newIds: ID[]) {\n  const filtered = currentActivesIds.filter(id => newIds.indexOf(id) > -1);\n  /** Return the same reference if nothing has changed */\n  if (filtered.length === currentActivesIds.length) {\n    return currentActivesIds;\n  }\n\n  return filtered;\n}\n","import { Entities, EntityState, HashMap, ID, PreAddEntity } from './types';\nimport { toEntitiesObject } from './toEntitiesObject';\nimport { isArray } from './isArray';\nimport { hasActiveState, resolveActiveEntity } from './activeState';\n\nexport type SetEntities<Entity> = Entity[] | Entities<Entity> | HashMap<Entity>;\n\nexport type SetEntitiesParams<State, Entity> = {\n  state: State;\n  entities: SetEntities<Entity>;\n  idKey: string;\n  preAddEntity: PreAddEntity<Entity>;\n  isNativePreAdd?: boolean;\n};\n\n// @internal\nexport function isEntityState<Entity>(state): state is Entities<Entity> {\n  return state.entities && state.ids;\n}\n\n// @internal\nfunction applyMiddleware<E>(entities: HashMap<E>, preAddEntity: PreAddEntity<E>) {\n  let mapped = {};\n  for (const id of Object.keys(entities)) {\n    mapped[id] = preAddEntity(entities[id]);\n  }\n\n  return mapped;\n}\n\n// @internal\nexport function setEntities<S extends EntityState<E>, E>({ state, entities, idKey, preAddEntity, isNativePreAdd }: SetEntitiesParams<S, E>): S {\n  let newEntities: HashMap<E>;\n  let newIds: ID[];\n\n  if (isArray(entities)) {\n    const resolve = toEntitiesObject(entities, idKey, preAddEntity);\n    newEntities = resolve.entities;\n    newIds = resolve.ids;\n  } else if (isEntityState(entities)) {\n    newEntities = isNativePreAdd ? entities.entities : applyMiddleware(entities.entities, preAddEntity);\n    newIds = entities.ids;\n  } else {\n    // it's an object\n    newEntities = isNativePreAdd ? entities : applyMiddleware(entities, preAddEntity);\n    newIds = Object.keys(newEntities).map(id => (isNaN(id as any) ? id : Number(id)));\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: newIds,\n    loading: false\n  };\n\n  if (hasActiveState(state)) {\n    newState.active = resolveActiveEntity(newState as any);\n  }\n\n  return newState;\n}\n","export const currentAction = {\n  type: null,\n  entityIds: null,\n  skip: false\n};\n\nlet customActionActive = false;\n\nexport function resetCustomAction() {\n  customActionActive = false;\n}\n\n// public API for custom actions. Custom action always wins\nexport function logAction(type: string, entityIds?) {\n  setAction(type, entityIds);\n  customActionActive = true;\n}\n\nexport function setAction(type: string, entityIds?) {\n  if (customActionActive === false) {\n    currentAction.type = type;\n    currentAction.entityIds = entityIds;\n  }\n}\n\nexport function setSkipAction(skip = true) {\n  currentAction.skip = skip;\n}\n\nexport function action(action: string, entityIds?) {\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function(...args) {\n      logAction(action, entityIds);\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n","export interface AkitaConfig {\n  /**\n   * Whether to allowed the reset() stores functionality\n   */\n  resettable?: boolean;\n  ttl?: number;\n  producerFn?: (state: any, fn: any) => any;\n}\n\nlet CONFIG: AkitaConfig = {\n  resettable: false,\n  ttl: null,\n  producerFn: undefined\n};\n\nexport function akitaConfig(config: AkitaConfig) {\n  CONFIG = { ...CONFIG, ...config };\n}\n\n// @internal\nexport function getAkitaConfig() {\n  return CONFIG;\n}\n\nexport function getGlobalProducerFn() {\n  return CONFIG.producerFn;\n}\n","// @internal\nexport function deepFreeze(o) {\n  Object.freeze(o);\n\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      hasOwnProp.call(o, prop) &&\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n","import { ReplaySubject, Subject } from 'rxjs';\n\n// @internal\nexport const $$deleteStore = new Subject<string>();\n// @internal\nexport const $$addStore = new ReplaySubject<string>(50, 5000);\n// @internal\nexport const $$updateStore = new Subject<string>();\n\n// @internal\nexport function dispatchDeleted(storeName: string) {\n  $$deleteStore.next(storeName);\n}\n\n// @internal\nexport function dispatchAdded(storeName: string) {\n  $$addStore.next(storeName);\n}\n\n// @internal\nexport function dispatchUpdate(storeName: string) {\n  $$updateStore.next(storeName);\n}\n","export let __DEV__ = true;\n\nexport function enableAkitaProdMode() {\n  __DEV__ = false;\n}\n\n// @internal\nexport function isDev() {\n  return __DEV__;\n}\n","// @internal\nexport class AkitaError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n// @internal\nexport function assertStoreHasName(name: string, className: string) {\n  if (!name) {\n    console.error(`@StoreConfig({ name }) is missing in ${className}`);\n  }\n}\n","// @internal\nexport function isNil(v) {\n  return v === null || v === undefined;\n}\n","import { isNil } from './isNil';\n\n// @internal\nexport function isDefined(val: any) {\n  return isNil(val) === false;\n}\n","// @internal\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","// @internal\nexport function toBoolean(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","import { toBoolean } from './toBoolean';\n\n// @internal\nexport function isPlainObject(value) {\n  return toBoolean(value) && value.constructor.name === 'Object';\n}\n","export const isBrowser = typeof window !== 'undefined';\nexport const isNotBrowser = !isBrowser;\nexport const isNativeScript = typeof global !== 'undefined' && (<any>global).__runtimeVersion !== 'undefined';\nexport const hasLocalStorage = () => {\n  try {\n    return typeof localStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n}\nexport const hasSessionStorage = () => {\n  try {\n    return typeof sessionStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n}\n","import { AkitaConfig } from './config';\n\nexport type StoreConfigOptions = {\n  name: string;\n  resettable?: AkitaConfig['resettable'];\n  cache?: { ttl: number };\n  deepFreezeFn?: (o: any) => any;\n  idKey?: string;\n  producerFn?: AkitaConfig['producerFn'];\n};\n\nexport type UpdatableStoreConfigOptions = {\n  cache?: { ttl: number };\n};\n\nexport const configKey = 'akitaConfig';\n\nexport function StoreConfig(metadata: StoreConfigOptions) {\n  return function(constructor: Function) {\n    constructor[configKey] = { idKey: 'id' };\n\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      /* name is preserved read only key */\n      if (key === 'name') {\n        constructor[configKey]['storeName'] = metadata[key];\n      } else {\n        constructor[configKey][key] = metadata[key];\n      }\n    }\n  };\n}\n","import { Store } from './store';\nimport { isDev } from './env';\nimport { isBrowser } from './root';\nimport { Query } from './query';\n\n// @internal\nexport const __stores__: { [storeName: string]: Store<any> } = {};\n\n// @internal\nexport const __queries__: { [storeName: string]: Query<any> } = {};\n\nif (isBrowser && isDev()) {\n  (window as any).$$stores = __stores__;\n  (window as any).$$queries = __queries__;\n}\n","import { BehaviorSubject, Observable, of, Subject } from 'rxjs';\nimport { logAction } from './actions';\nimport { tap } from 'rxjs/operators';\n\n// @internal\nconst transactionFinished = new Subject();\n\n// @internal\nconst transactionInProcess = new BehaviorSubject(false);\n\nexport type TransactionManager = {\n  activeTransactions: number;\n  batchTransaction: Subject<boolean> | null;\n};\n\n// @internal\nexport const transactionManager: TransactionManager = {\n  activeTransactions: 0,\n  batchTransaction: null\n};\n\n// @internal\nexport function startBatch() {\n  if (!isTransactionInProcess()) {\n    transactionManager.batchTransaction = new Subject();\n  }\n  transactionManager.activeTransactions++;\n  transactionInProcess.next(true);\n}\n\n// @internal\nexport function endBatch() {\n  if (--transactionManager.activeTransactions === 0) {\n    transactionManager.batchTransaction.next(true);\n    transactionManager.batchTransaction.complete();\n    transactionInProcess.next(false);\n    transactionFinished.next(true);\n  }\n}\n\n// @internal\nexport function isTransactionInProcess() {\n  return transactionManager.activeTransactions > 0;\n}\n\n// @internal\nexport function commit(): Observable<boolean> {\n  return transactionManager.batchTransaction ? transactionManager.batchTransaction.asObservable() : of(true);\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *  The following code will update the store, BUT  emits only once\n *\n *  @example\n *  applyTransaction(() => {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  });\n *\n */\nexport function applyTransaction<T>(action: () => T, thisArg = undefined): T {\n  startBatch();\n  try {\n    return action.apply(thisArg);\n  } finally {\n    logAction('@Transaction');\n    endBatch();\n  }\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *\n *  The following code will update the store, BUT  emits only once.\n *\n *  @example\n *  @transaction\n *  addTodos() {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  }\n *\n *\n */\nexport function transaction() {\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function(...args) {\n      return applyTransaction(() => {\n        return originalMethod.apply(this, args);\n      }, this);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n *\n * RxJS custom operator that wraps the callback inside transaction\n *\n * @example\n *\n * return http.get().pipe(\n *    withTransaction(response > {\n *      store.setActive(1);\n *      store.update();\n *      store.updateEntity(1, {});\n *    })\n * )\n *\n */\nexport function withTransaction<T>(next: (value: T) => void) {\n  return function(source: Observable<T>): Observable<T> {\n    return source.pipe(tap(value => applyTransaction(() => next(value))));\n  };\n}\n","import { BehaviorSubject, Observable } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { resetCustomAction, setAction } from './actions';\nimport { getAkitaConfig, getGlobalProducerFn } from './config';\nimport { deepFreeze } from './deepFreeze';\nimport { dispatchAdded, dispatchDeleted, dispatchUpdate } from './dispatchers';\nimport { __DEV__, isDev } from './env';\nimport { assertStoreHasName } from './errors';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isPlainObject } from './isPlainObject';\nimport { isBrowser } from './root';\nimport { configKey, StoreConfigOptions, UpdatableStoreConfigOptions } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { commit, isTransactionInProcess } from './transaction';\nimport { StoreCache, UpdateStateCallback } from './types';\n\n/**\n *\n * Store for managing any type of data\n *\n * @example\n *\n * export interface SessionState {\n *   token: string;\n *   userDetails: UserDetails\n * }\n *\n * export function createInitialState(): SessionState {\n *  return {\n *    token: '',\n *    userDetails: null\n *  };\n * }\n *\n * @StoreConfig({ name: 'session' })\n * export class SessionStore extends Store<SessionState> {\n *   constructor() {\n *    super(createInitialState());\n *   }\n * }\n */\nexport class Store<S = any> {\n  private store: BehaviorSubject<Readonly<S>>;\n  private storeValue: S;\n  private inTransaction = false;\n  private _initialState: S;\n  protected cache: StoreCache = {\n    active: new BehaviorSubject<boolean>(false),\n    ttl: null\n  };\n\n  constructor(initialState: Partial<S>, protected options: Partial<StoreConfigOptions> = {}) {\n    this.onInit(initialState as S);\n  }\n\n  /**\n   *  Set the loading state\n   *\n   *  @example\n   *\n   *  store.setLoading(true)\n   *\n   */\n  setLoading(loading = false) {\n    if (loading !== (this._value() as S & { loading: boolean }).loading) {\n      isDev() && setAction('Set Loading');\n      this._setState(state => ({ ...state, loading } as S & { loading: boolean }));\n    }\n  }\n\n  /**\n   *\n   * Set whether the data is cached\n   *\n   * @example\n   *\n   * store.setHasCache(true)\n   * store.setHasCache(false)\n   * store.setHasCache(true, { restartTTL: true })\n   *\n   */\n  setHasCache(hasCache: boolean, options: { restartTTL: boolean } = { restartTTL: false }) {\n    if (hasCache !== this.cache.active.value) {\n      this.cache.active.next(hasCache);\n    }\n\n    if (options.restartTTL) {\n      const ttlConfig = this.getCacheTTL();\n      if (ttlConfig) {\n        if (this.cache.ttl !== null) {\n          clearTimeout(this.cache.ttl);\n        }\n        this.cache.ttl = <any>setTimeout(() => this.setHasCache(false), ttlConfig);\n      }\n    }\n  }\n\n  /**\n   *\n   * Sometimes we need to access the store value from a store\n   *\n   * @example middleware\n   *\n   */\n  getValue() {\n    return this.storeValue;\n  }\n\n  /**\n   *  Set the error state\n   *\n   *  @example\n   *\n   *  store.setError({text: 'unable to load data' })\n   *\n   */\n  setError<T>(error: T) {\n    if (error !== (this._value() as S & { error: any }).error) {\n      isDev() && setAction('Set Error');\n      this._setState(state => ({ ...state, error } as S & { error: any }));\n    }\n  }\n\n  // @internal\n  _select<R>(project: (store: S) => R): Observable<R> {\n    return this.store.asObservable().pipe(\n      map(project),\n      distinctUntilChanged()\n    );\n  }\n\n  // @internal\n  _value(): S {\n    return this.storeValue;\n  }\n\n  // @internal\n  _cache(): BehaviorSubject<boolean> {\n    return this.cache.active;\n  }\n\n  // @internal\n  get config(): StoreConfigOptions {\n    return this.constructor[configKey] || {};\n  }\n\n  // @internal\n  get storeName() {\n    return (this.config as StoreConfigOptions & { storeName: string }).storeName || (this.options as StoreConfigOptions & { storeName: string }).storeName || this.options.name;\n  }\n\n  // @internal\n  get deepFreeze() {\n    return this.config.deepFreezeFn || this.options.deepFreezeFn || deepFreeze;\n  }\n\n  // @internal\n  get cacheConfig() {\n    return this.config.cache || this.options.cache;\n  }\n\n  get _producerFn() {\n    return this.config.producerFn || this.options.producerFn || getGlobalProducerFn();\n  }\n\n  // @internal\n  get resettable() {\n    return isDefined(this.config.resettable) ? this.config.resettable : this.options.resettable;\n  }\n\n  // @internal\n  _setState(newState: ((state: Readonly<S>) => S) | S, _dispatchAction = true) {\n    if (isFunction(newState)) {\n      const _newState = newState(this._value());\n      this.storeValue = __DEV__ ? this.deepFreeze(_newState) : _newState;\n    } else {\n      this.storeValue = newState;\n    }\n\n    if (!this.store) {\n      this.store = new BehaviorSubject(this.storeValue);\n      return;\n    }\n\n    if (isTransactionInProcess()) {\n      this.handleTransaction();\n      return;\n    }\n\n    this.dispatch(this.storeValue, _dispatchAction);\n  }\n\n  /**\n   *\n   * Reset the current store back to the initial value\n   *\n   * @example\n   *\n   * store.reset()\n   *\n   */\n  reset() {\n    if (this.isResettable()) {\n      isDev() && setAction('Reset');\n      this._setState(() => Object.assign({}, this._initialState));\n      this.setHasCache(false);\n    } else {\n      isDev() && console.warn(`You need to enable the reset functionality`);\n    }\n  }\n\n  /**\n   *\n   * Update the store's value\n   *\n   * @example\n   *\n   * this.store.update(state => {\n   *   return {...}\n   * })\n   */\n  update(stateCallback: UpdateStateCallback<S>);\n  /**\n   *\n   * @example\n   *\n   *  this.store.update({ token: token })\n   */\n  update(state: Partial<S>);\n  update(stateOrCallback: Partial<S> | UpdateStateCallback<S>) {\n    isDev() && setAction('Update');\n\n    let newState;\n    const currentState = this._value();\n    if (isFunction(stateOrCallback)) {\n      newState = isFunction(this._producerFn) ? this._producerFn(currentState, stateOrCallback) : stateOrCallback(currentState);\n    } else {\n      newState = stateOrCallback;\n    }\n\n    const withHook = this.akitaPreUpdate(currentState, { ...currentState, ...newState } as S);\n    const resolved = isPlainObject(currentState) ? withHook : new (currentState as any).constructor(withHook);\n    this._setState(resolved);\n  }\n\n  updateStoreConfig(newOptions: UpdatableStoreConfigOptions) {\n    this.options = { ...this.options, ...newOptions };\n  }\n\n  // @internal\n  akitaPreUpdate(_: Readonly<S>, nextState: Readonly<S>): S {\n    return nextState;\n  }\n\n  ngOnDestroy() {\n    this.destroy();\n  }\n\n  /**\n   *\n   * Destroy the store\n   *\n   * @example\n   *\n   * store.destroy()\n   *\n   */\n  destroy() {\n    const hmrEnabled = isBrowser ? (window as any).hmrEnabled : false;\n    if (!hmrEnabled && this === __stores__[this.storeName]) {\n      delete __stores__[this.storeName];\n      dispatchDeleted(this.storeName);\n      this.setHasCache(false);\n      this.cache.active.complete();\n    }\n  }\n\n  private onInit(initialState: S) {\n    __stores__[this.storeName] = this;\n    this._setState(() => initialState);\n    dispatchAdded(this.storeName);\n    if (this.isResettable()) {\n      this._initialState = initialState;\n    }\n    isDev() && assertStoreHasName(this.storeName, this.constructor.name);\n  }\n\n  private dispatch(state: S, _dispatchAction = true) {\n    this.store.next(state);\n    if (_dispatchAction) {\n      dispatchUpdate(this.storeName);\n      resetCustomAction();\n    }\n  }\n\n  private watchTransaction() {\n    commit().subscribe(() => {\n      this.inTransaction = false;\n      this.dispatch(this._value());\n    });\n  }\n\n  private isResettable() {\n    if (this.resettable === false) {\n      return false;\n    }\n    return this.resettable || getAkitaConfig().resettable;\n  }\n\n  private handleTransaction() {\n    if (!this.inTransaction) {\n      this.watchTransaction();\n      this.inTransaction = true;\n    }\n  }\n\n  private getCacheTTL() {\n    return (this.cacheConfig && this.cacheConfig.ttl) || getAkitaConfig().ttl;\n  }\n}\n","// @internal\nexport function isObject(value: any) {\n  const type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n","import { ID, IDS } from './types';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { isArray } from './isArray';\n\nexport type SetActiveOptions = { prev?: boolean; next?: boolean; wrap?: boolean };\n\n// @internal\nexport function getActiveEntities(idOrOptions: IDS | SetActiveOptions | null, ids: ID[], currentActive: IDS | null) {\n  let result;\n\n  if (isArray(idOrOptions)) {\n    result = idOrOptions;\n  } else {\n    if (isObject(idOrOptions)) {\n      if (isNil(currentActive)) return;\n      (idOrOptions as SetActiveOptions) = Object.assign({ wrap: true }, idOrOptions);\n      const currentIdIndex = ids.indexOf(currentActive as ID);\n      if ((idOrOptions as SetActiveOptions).prev) {\n        const isFirst = currentIdIndex === 0;\n        if (isFirst && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isFirst ? ids[ids.length - 1] : (ids[currentIdIndex - 1] as any);\n      } else if ((idOrOptions as SetActiveOptions).next) {\n        const isLast = ids.length === currentIdIndex + 1;\n        if (isLast && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isLast ? ids[0] : (ids[currentIdIndex + 1] as any);\n      }\n    } else {\n      if (idOrOptions === currentActive) return;\n      result = idOrOptions as ID;\n    }\n  }\n\n  return result;\n}\n","import { EntityState, PreAddEntity } from './types';\nimport { hasEntity } from './hasEntity';\n\nexport type AddEntitiesParams<State, Entity> = {\n  state: State;\n  entities: Entity[];\n  idKey: string;\n  options: AddEntitiesOptions;\n  preAddEntity: PreAddEntity<Entity>;\n};\n\nexport type AddEntitiesOptions = { prepend?: boolean; loading?: boolean };\n\n// @internal\nexport function addEntities<S extends EntityState<E>, E>({ state, entities, idKey, options = {}, preAddEntity }: AddEntitiesParams<S, E>) {\n  let newEntities = {};\n  let newIds = [];\n  let hasNewEntities = false;\n\n  for (const entity of entities) {\n    if (hasEntity(state.entities, entity[idKey]) === false) {\n      // evaluate the middleware first to support dynamic ids\n      const current = preAddEntity(entity);\n      const entityId = current[idKey];\n      newEntities[entityId] = current;\n      if (options.prepend) newIds.unshift(entityId);\n      else newIds.push(entityId);\n\n      hasNewEntities = true;\n    }\n  }\n\n  return hasNewEntities\n    ? {\n        newState: {\n          ...state,\n          entities: {\n            ...state.entities,\n            ...newEntities\n          },\n          ids: options.prepend ? [...newIds, ...state.ids] : [...state.ids, ...newIds]\n        },\n        newIds\n      }\n    : null;\n}\n","import { isNil } from './isNil';\n\n// @internal\nexport function coerceArray<T>(value: T | T[]): T[] {\n  if (isNil(value)) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\n","import { EntityState, ID, StateWithActive } from './types';\nimport { isNil } from './isNil';\nimport { hasActiveState, isMultiActiveState, resolveActiveEntity } from './activeState';\n\nexport type RemoveEntitiesParams<State, Entity> = {\n  state: StateWithActive<State>;\n  ids: any[];\n};\n\n// @internal\nexport function removeEntities<S extends EntityState<E>, E>({ state, ids }: RemoveEntitiesParams<S, E>): S {\n  if (isNil(ids)) return removeAllEntities(state);\n  const entities = state.entities;\n  let newEntities = {};\n\n  for (const id of state.ids) {\n    if (ids.includes(id) === false) {\n      newEntities[id] = entities[id];\n    }\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: state.ids.filter(current => ids.includes(current) === false)\n  };\n\n  if (hasActiveState(state)) {\n    newState.active = resolveActiveEntity(newState);\n  }\n\n  return newState;\n}\n\n// @internal\nexport function removeAllEntities<S>(state: StateWithActive<S>): S {\n  return {\n    ...state,\n    entities: {},\n    ids: [],\n    active: isMultiActiveState(state.active) ? [] : null\n  };\n}\n","import { EntityState } from './index';\n\n// @internal\nexport const getInitialEntitiesState = () =>\n  ({\n    entities: {},\n    ids: [],\n    loading: true,\n    error: null\n  } as EntityState);\n","import { EntityState, ID, PreUpdateEntity, UpdateStateCallback } from './types';\nimport { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n\nexport type UpdateEntitiesParams<State, Entity> = {\n  state: State;\n  ids: any[];\n  idKey: string;\n  newStateOrFn: UpdateStateCallback<Entity> | Partial<Entity> | Partial<State>;\n  preUpdateEntity: PreUpdateEntity<Entity>;\n  producerFn;\n};\n\n// @internal\nexport function updateEntities<S extends EntityState<E>, E>({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn }: UpdateEntitiesParams<S, E>) {\n  const updatedEntities = {};\n\n  let isUpdatingIdKey = false;\n  let idToUpdate: ID;\n\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity: E;\n    idToUpdate = id;\n\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n\n    const merged = {\n      ...oldEntity,\n      ...newState\n    };\n\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new (oldEntity as any).constructor(merged);\n      } else {\n        newEntity = new (newState as any).constructor(merged);\n      }\n    }\n\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const { [id]: deletedEntity, ...rest } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map(current => (current === id ? idToUpdate : current));\n  }\n\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities\n    },\n    ids: updatedIds\n  };\n}\n","// @internal\nexport function isUndefined(value: any): value is undefined {\n  return value === undefined;\n}\n","export enum EntityActions {\n  Set,\n  Add,\n  Update,\n  Remove\n}\n\nexport interface EntityAction<IDType> {\n  type: EntityActions;\n  ids: IDType[];\n}\n","export const DEFAULT_ID_KEY = 'id';\n","import { isEmpty } from './isEmpty';\nimport { SetEntities, setEntities } from './setEntities';\nimport { Store } from './store';\nimport { Constructor, EntityState, EntityUICreateFn, IDS, OrArray, StateWithActive, UpdateEntityPredicate, UpdateStateCallback, getEntityType, getIDType } from './types';\nimport { getActiveEntities, SetActiveOptions } from './getActiveEntities';\nimport { addEntities, AddEntitiesOptions } from './addEntities';\nimport { coerceArray } from './coerceArray';\nimport { removeEntities } from './removeEntities';\nimport { getInitialEntitiesState } from './getInitialEntitiesState';\nimport { isDefined } from './isDefined';\nimport { updateEntities } from './updateEntities';\nimport { transaction } from './transaction';\nimport { isNil } from './isNil';\nimport { isFunction } from './isFunction';\nimport { isUndefined } from './isUndefined';\nimport { StoreConfigOptions } from './storeConfig';\nimport { logAction, setAction } from './actions';\nimport { isDev } from './env';\nimport { hasEntity } from './hasEntity';\nimport { Observable, Subject } from 'rxjs';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\n\n/**\n *\n * Store for managing a collection of entities\n *\n * @example\n *\n * export interface WidgetsState extends EntityState<Widget> { }\n *\n * @StoreConfig({ name: 'widgets' })\n *  export class WidgetsStore extends EntityStore<WidgetsState> {\n *   constructor() {\n *     super();\n *   }\n * }\n *\n *\n */\nexport class EntityStore<S extends EntityState = any, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Store<S> {\n  ui: EntityUIStore<any, EntityType>;\n  private entityActions = new Subject<EntityAction<IDType>>();\n\n  constructor(initialState: Partial<S> = {}, protected options: Partial<StoreConfigOptions> = {}) {\n    super({ ...getInitialEntitiesState(), ...initialState }, options);\n  }\n\n  // @internal\n  get selectEntityAction$(): Observable<EntityAction<IDType>> {\n    return this.entityActions.asObservable();\n  }\n\n  // @internal\n  get idKey() {\n    return (this.config as StoreConfigOptions).idKey || this.options.idKey || DEFAULT_ID_KEY;\n  }\n\n  /**\n   *\n   * Replace current collection with provided collection\n   *\n   * @example\n   *\n   * this.store.set([Entity, Entity])\n   * this.store.set({ids: [], entities: {}})\n   * this.store.set({ 1: {}, 2: {}})\n   *\n   */\n  set(entities: SetEntities<EntityType>, options: { activeId?: IDType | null } = {}) {\n    if (isNil(entities)) return;\n\n    isDev() && setAction('Set Entity');\n\n    const isNativePreAdd = this.akitaPreAddEntity === EntityStore.prototype.akitaPreAddEntity;\n\n    this._setState(state => {\n      const newState = setEntities({\n        state,\n        entities,\n        idKey: this.idKey,\n        preAddEntity: this.akitaPreAddEntity,\n        isNativePreAdd\n      });\n\n      if (isUndefined(options.activeId) === false) {\n        (newState as any).active = options.activeId;\n      }\n\n      return newState;\n    });\n\n    this.setHasCache(true, { restartTTL: true });\n\n    if (this.hasInitialUIState()) {\n      this.handleUICreation();\n    }\n\n    this.entityActions.next({ type: EntityActions.Set, ids: this.ids });\n  }\n\n  /**\n   * Add entities\n   *\n   * @example\n   *\n   * this.store.add([Entity, Entity])\n   * this.store.add(Entity)\n   * this.store.add(Entity, { prepend: true })\n   *\n   * this.store.add(Entity, { loading: false })\n   */\n  add(entities: OrArray<EntityType>, options: AddEntitiesOptions = { loading: false }) {\n    const collection = coerceArray(entities);\n\n    if (isEmpty(collection)) return;\n\n    const data = addEntities({\n      state: this._value(),\n      preAddEntity: this.akitaPreAddEntity,\n      entities: collection,\n      idKey: this.idKey,\n      options\n    });\n\n    if (data) {\n      isDev() && setAction('Add Entity');\n      data.newState.loading = options.loading;\n\n      this._setState(() => data.newState);\n\n      if (this.hasInitialUIState()) {\n        this.handleUICreation(true);\n      }\n\n      this.entityActions.next({ type: EntityActions.Add, ids: data.newIds });\n    }\n  }\n\n  /**\n   *\n   * Update entities\n   *\n   * @example\n   *\n   * store.update(1, entity => ...)\n   * store.update([1, 2, 3], entity => ...)\n   * store.update(null, entity => ...)\n   */\n  update(id: OrArray<IDType> | null, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(1, { name: newName })\n   */\n  update(id: OrArray<IDType> | null, newState: Partial<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, entity => ({ name: newName }))\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, { name: newName })\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newState: Partial<EntityType>);\n  /** Support non-entity updates */\n  update(newState: UpdateStateCallback<S>);\n  update(newState: Partial<S>);\n  update(\n    idsOrFnOrState: OrArray<IDType> | null | Partial<S> | UpdateStateCallback<S> | UpdateEntityPredicate<EntityType>,\n    newStateOrFn?: UpdateStateCallback<EntityType> | Partial<EntityType> | Partial<S>\n  ) {\n    if (isUndefined(newStateOrFn)) {\n      super.update(idsOrFnOrState as Partial<S>);\n      return;\n    }\n    let ids: IDType[] = [];\n\n    if (isFunction(idsOrFnOrState)) {\n      // We need to filter according the predicate function\n      ids = this.ids.filter(id => (idsOrFnOrState as UpdateEntityPredicate<EntityType>)(this.entities[id]));\n    } else {\n      // If it's nil we want all of them\n      ids = isNil(idsOrFnOrState) ? this.ids : coerceArray(idsOrFnOrState as OrArray<IDType>);\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Update Entity', ids);\n    this._setState(state =>\n      updateEntities({\n        idKey: this.idKey,\n        ids,\n        preUpdateEntity: this.akitaPreUpdateEntity,\n        state,\n        newStateOrFn,\n        producerFn: this._producerFn\n      })\n    );\n\n    this.entityActions.next({ type: EntityActions.Update, ids });\n  }\n\n  /**\n   *\n   * Create or update\n   *\n   * @example\n   *\n   * store.upsert(1, { active: true })\n   * store.upsert([2, 3], { active: true })\n   * store.upsert([2, 3], entity => ({ isOpen: !entity.isOpen}))\n   *\n   */\n  @transaction()\n  upsert(ids: OrArray<IDType>, newState: Partial<EntityType> | EntityType | UpdateStateCallback<EntityType> | EntityType[], options: { baseClass?: Constructor } = {}) {\n    const toArray = coerceArray(ids);\n    const predicate = isUpdate => id => hasEntity(this.entities, id) === isUpdate;\n    const isClassBased = isFunction(options.baseClass);\n    const updateIds = toArray.filter(predicate(true));\n    const newEntities = toArray.filter(predicate(false)).map(id => {\n      let entity = isFunction(newState) ? newState({} as EntityType) : newState;\n      const withId = { ...(entity as EntityType), [this.idKey]: id };\n      if (isClassBased) {\n        return new options.baseClass(withId);\n      }\n      return withId;\n    });\n\n    // it can be any of the three types\n    this.update(updateIds as any, newState as any);\n    this.add(newEntities);\n    isDev() && logAction('Upsert Entity');\n  }\n\n  /**\n   *\n   * Upsert entity collection (idKey must be present)\n   *\n   * @example\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }]);\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });\n   *\n   */\n  upsertMany(entities: EntityType[], options: { baseClass?: Constructor; loading?: boolean } = {}) {\n    const addedIds = [];\n    const updatedIds = [];\n    const updatedEntities = {};\n\n    // Update the state directly to optimize performance\n    for (const entity of entities) {\n      const withPreCheckHook = this.akitaPreCheckEntity(entity);\n      const id = withPreCheckHook[this.idKey];\n      if (hasEntity(this.entities, id)) {\n        const prev = this._value().entities[id];\n        const merged = { ...this._value().entities[id], ...withPreCheckHook };\n        const next = options.baseClass ? new options.baseClass(merged) : merged;\n        const withHook = this.akitaPreUpdateEntity(prev, next);\n        const nextId = withHook[this.idKey];\n        updatedEntities[nextId] = withHook;\n        updatedIds.push(nextId);\n      } else {\n        const newEntity = options.baseClass ? new options.baseClass(withPreCheckHook) : withPreCheckHook;\n        const withHook = this.akitaPreAddEntity(newEntity);\n        const nextId = withHook[this.idKey];\n        addedIds.push(nextId);\n        updatedEntities[nextId] = withHook;\n      }\n    }\n\n    isDev() && logAction('Upsert Many');\n\n    this._setState(state => ({\n      ...state,\n      ids: addedIds.length ? [...state.ids, ...addedIds] : state.ids,\n      entities: {\n        ...state.entities,\n        ...updatedEntities\n      },\n      loading: !!options.loading\n    }));\n\n    updatedIds.length && this.entityActions.next({ type: EntityActions.Update, ids: updatedIds });\n    addedIds.length && this.entityActions.next({ type: EntityActions.Add, ids: addedIds });\n    if (addedIds.length && this.hasUIStore()) {\n      this.handleUICreation(true);\n    }\n  }\n\n  /**\n   *\n   * Replace one or more entities (except the id property)\n   *\n   *\n   * @example\n   *\n   * this.store.replace(5, newEntity)\n   * this.store.replace([1,2,3], newEntity)\n   */\n  replace(ids: IDS, newState: Partial<EntityType>) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    let replaced = {};\n    for (const id of toArray) {\n      newState[this.idKey] = id;\n      replaced[id] = newState;\n    }\n    isDev() && setAction('Replace Entity', ids);\n    this._setState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        ...replaced\n      }\n    }));\n  }\n\n  /**\n   *\n   * Move entity inside the collection\n   *\n   *\n   * @example\n   *\n   * this.store.move(fromIndex, toIndex)\n   */\n  move(from: number, to: number) {\n    const ids = this.ids.slice();\n    ids.splice(to < 0 ? ids.length + to : to, 0, ids.splice(from, 1)[0]);\n\n    isDev() && setAction('Move Entity');\n    this._setState(state => ({\n      ...state,\n      // Change the entities reference so that selectAll emit\n      entities: {\n        ...state.entities\n      },\n      ids\n    }));\n  }\n\n  /**\n   *\n   * Remove one or more entities\n   *\n   * @example\n   *\n   * this.store.remove(5)\n   * this.store.remove([1,2,3])\n   * this.store.remove()\n   */\n  remove(id?: OrArray<IDType>);\n  /**\n   * this.store.remove(entity => entity.id === 1)\n   */\n  remove(predicate: (entity: Readonly<EntityType>) => boolean);\n  remove(idsOrFn?: OrArray<IDType> | ((entity: Readonly<EntityType>) => boolean)) {\n    if (isEmpty(this.ids)) return;\n\n    const idPassed = isDefined(idsOrFn);\n\n    // null means remove all\n    let ids: IDType[] | null = [];\n\n    if (isFunction(idsOrFn)) {\n      ids = this.ids.filter(entityId => idsOrFn(this.entities[entityId]));\n    } else {\n      ids = idPassed ? coerceArray(idsOrFn) : null;\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Remove Entity', ids);\n    this._setState((state: StateWithActive<S>) => removeEntities({ state, ids }));\n    if (ids === null) {\n      this.setHasCache(false);\n    }\n\n    this.handleUIRemove(ids);\n    this.entityActions.next({ type: EntityActions.Remove, ids });\n  }\n\n  /**\n   *\n   * Update the active entity\n   *\n   * @example\n   *\n   * this.store.updateActive({ completed: true })\n   * this.store.updateActive(active => {\n   *   return {\n   *     config: {\n   *      ..active.config,\n   *      date\n   *     }\n   *   }\n   * })\n   */\n  updateActive(newStateOrCallback: UpdateStateCallback<EntityType> | Partial<EntityType>) {\n    const ids = coerceArray(this.active);\n    isDev() && setAction('Update Active', ids);\n    this.update(ids, newStateOrCallback as Partial<EntityType>);\n  }\n\n  /**\n   * Set the given entity as active\n   *\n   * @example\n   *\n   * store.setActive(1)\n   * store.setActive([1, 2, 3])\n   */\n  setActive(idOrOptions: S['active'] extends any[] ? S['active'] : (SetActiveOptions | S['active']));\n  setActive(idOrOptions: IDType | SetActiveOptions | null) {\n    const active = getActiveEntities(idOrOptions, this.ids, this.active);\n\n    if (active === undefined) {\n      return;\n    }\n\n    isDev() && setAction('Set Active', active);\n    this._setActive(active);\n  }\n\n  /**\n   * Add active entities\n   *\n   * @example\n   *\n   * store.addActive(2);\n   * store.addActive([3, 4, 5]);\n   */\n  addActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const everyExist = toArray.every(id => this.active.indexOf(id) > -1);\n    if (everyExist) return;\n\n    isDev() && setAction('Add Active', ids);\n    this._setState(state => {\n      /** Protect against case that one of the items in the array exist */\n      const uniques = Array.from(new Set([...(state.active as IDType[]), ...toArray]));\n      return {\n        ...state,\n        active: uniques\n      };\n    });\n  }\n\n  /**\n   * Remove active entities\n   *\n   * @example\n   *\n   * store.removeActive(2)\n   * store.removeActive([3, 4, 5])\n   */\n  removeActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const someExist = toArray.some(id => this.active.indexOf(id) > -1);\n    if (!someExist) return;\n\n    isDev() && setAction('Remove Active', ids);\n    this._setState(state => {\n      return {\n        ...state,\n        active: Array.isArray(state.active) ? state.active.filter(currentId => toArray.indexOf(currentId) === -1) : null\n      };\n    });\n  }\n\n  /**\n   * Toggle active entities\n   *\n   * @example\n   *\n   * store.toggle(2)\n   * store.toggle([3, 4, 5])\n   */\n  @transaction()\n  toggleActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    const filterExists = remove => id => this.active.includes(id) === remove;\n    const remove = toArray.filter(filterExists(true));\n    const add = toArray.filter(filterExists(false));\n    this.removeActive(remove);\n    this.addActive(add);\n    isDev() && logAction('Toggle Active');\n  }\n\n  /**\n   *\n   * Create sub UI store for managing Entity's UI state\n   *\n   * @example\n   *\n   * export type ProductUI = {\n   *   isLoading: boolean;\n   *   isOpen: boolean\n   * }\n   *\n   * interface ProductsUIState extends EntityState<ProductUI> {}\n   *\n   * export class ProductsStore EntityStore<ProductsState, Product> {\n   *   ui: EntityUIStore<ProductsUIState, ProductUI>;\n   *\n   *   constructor() {\n   *     super();\n   *     this.createUIStore();\n   *   }\n   *\n   * }\n   */\n  createUIStore(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    const defaults: Partial<StoreConfigOptions> = { name: `UI/${this.storeName}`, idKey: this.idKey };\n    this.ui = new EntityUIStore(initialState, { ...defaults, ...storeConfig });\n    return this.ui;\n  }\n\n  // @internal\n  destroy() {\n    super.destroy();\n    if (this.ui instanceof EntityStore) {\n      this.ui.destroy();\n    }\n    this.entityActions.complete();\n  }\n\n  // @internal\n  akitaPreUpdateEntity(_: Readonly<EntityType>, nextEntity: any): EntityType {\n    return nextEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreAddEntity(newEntity: any): EntityType {\n    return newEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreCheckEntity(newEntity: Readonly<EntityType>): EntityType {\n    return newEntity;\n  }\n\n  private get ids() {\n    return this._value().ids;\n  }\n\n  private get entities() {\n    return this._value().entities;\n  }\n\n  private get active() {\n    return this._value().active;\n  }\n\n  private _setActive(ids: OrArray<IDType>) {\n    this._setState(state => {\n      return {\n        ...state,\n        active: ids\n      };\n    });\n  }\n\n  private handleUICreation(add = false) {\n    const ids = this.ids;\n    const isFunc = isFunction(this.ui._akitaCreateEntityFn);\n    let uiEntities;\n    const createFn = id => {\n      const current = this.entities[id];\n      const ui = isFunc ? this.ui._akitaCreateEntityFn(current) : this.ui._akitaCreateEntityFn;\n      return {\n        [this.idKey]: current[this.idKey],\n        ...ui\n      };\n    };\n\n    if (add) {\n      uiEntities = this.ids.filter(id => isUndefined(this.ui.entities[id])).map(createFn);\n    } else {\n      uiEntities = ids.map(createFn);\n    }\n\n    add ? this.ui.add(uiEntities) : this.ui.set(uiEntities);\n  }\n\n  private hasInitialUIState() {\n    return this.hasUIStore() && isUndefined(this.ui._akitaCreateEntityFn) === false;\n  }\n\n  private handleUIRemove(ids: IDType[]) {\n    if (this.hasUIStore()) {\n      this.ui.remove(ids);\n    }\n  }\n\n  private hasUIStore() {\n    return this.ui instanceof EntityUIStore;\n  }\n}\n\n// @internal\nexport class EntityUIStore<UIState, DEPRECATED = any> extends EntityStore<UIState> {\n  _akitaCreateEntityFn: EntityUICreateFn;\n\n  constructor(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    super(initialState, storeConfig);\n  }\n\n  /**\n   *\n   * Set the initial UI entity state. This function will determine the entity's\n   * initial state when we call `set()` or `add()`.\n   *\n   * @example\n   *\n   * constructor() {\n   *   super();\n   *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));\n   *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });\n   * }\n   *\n   */\n  setInitialEntityState<EntityUI = any, Entity = any>(createFn: EntityUICreateFn<EntityUI, Entity>) {\n    this._akitaCreateEntityFn = createFn;\n  }\n}\n","import { ID, IDS, ItemPredicate } from './types';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { isArray } from './isArray';\nimport { isFunction } from './isFunction';\nimport { isEmpty } from './isEmpty';\n\n// @internal\nexport function find<T>(collection: T[], idsOrPredicate: IDS | ItemPredicate, idKey: string) {\n  const result = [];\n  if (isFunction(idsOrPredicate)) {\n    for (const entity of collection) {\n      if (idsOrPredicate(entity) === true) {\n        result.push(entity);\n      }\n    }\n  } else {\n    const toSet = coerceArray(idsOrPredicate).reduce((acc, current) => acc.add(current), new Set());\n\n    for (const entity of collection) {\n      if (toSet.has(entity[idKey])) {\n        result.push(entity);\n      }\n    }\n  }\n\n  return result;\n}\n\n// @internal\nexport function distinctUntilArrayItemChanged<T>(): MonoTypeOperatorFunction<T[]> {\n  return distinctUntilChanged((prevCollection: T[], currentCollection: T[]) => {\n    if (prevCollection === currentCollection) {\n      return true;\n    }\n\n    if (isArray(prevCollection) === false || isArray(currentCollection) === false) {\n      return false;\n    }\n\n    if (isEmpty(prevCollection) && isEmpty(currentCollection)) {\n      return true;\n    }\n\n    // if item is new in the current collection but not exist in the prev collection\n    const hasNewItem = hasChange(currentCollection, prevCollection);\n\n    if (hasNewItem) {\n      return false;\n    }\n\n    const isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);\n\n    // return false means there is a change and we want to call next()\n    return isOneOfItemReferenceChanged === false;\n  });\n}\n\n// @internal\nfunction hasChange<T>(first: T[], second: T[]) {\n  const hasChange = second.some(currentItem => {\n    const oldItem = first.find(prevItem => prevItem === currentItem);\n    return oldItem === undefined;\n  });\n\n  return hasChange;\n}\n\n/**\n * Find items in a collection\n *\n * @example\n *\n *  selectEntity(1, 'comments').pipe(\n *   arrayFind(comment => comment.text = 'text')\n * )\n */\nexport function arrayFind<T>(ids: ItemPredicate<T>, idKey?: never): (source: Observable<T[]>) => Observable<T[]>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind(3)\n * )\n */\nexport function arrayFind<T>(ids: ID, idKey?: string): (source: Observable<T[]>) => Observable<T>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind([1, 2, 3])\n * )\n */\nexport function arrayFind<T>(ids: ID[], idKey?: string): (source: Observable<T[]>) => Observable<T[]>;\nexport function arrayFind<T>(idsOrPredicate: ID[] | ID | ItemPredicate<T>, idKey?: string): (source: Observable<T[]>) => Observable<T[] | T> {\n  return function(source: Observable<T[]>) {\n    return source.pipe(\n      map((collection: T[] | undefined | null) => {\n        // which means the user deleted the root entity or set the collection to nil\n        if (isArray(collection) === false) {\n          return collection;\n        }\n        return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);\n      }),\n      distinctUntilArrayItemChanged(),\n      map(value => {\n        if (isArray(value) === false) {\n          return value;\n        }\n\n        if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {\n          return value;\n        }\n\n        return value[0];\n      })\n    );\n  };\n}\n","export enum Order {\n  ASC = 'asc',\n  DESC = 'desc'\n}\n\n// @internal\nexport function compareValues(key, order: Order = Order.ASC) {\n  return function(a, b) {\n    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {\n      return 0;\n    }\n\n    const varA = typeof a[key] === 'string' ? a[key].toUpperCase() : a[key];\n    const varB = typeof b[key] === 'string' ? b[key].toUpperCase() : b[key];\n\n    let comparison = 0;\n    if (varA > varB) {\n      comparison = 1;\n    } else if (varA < varB) {\n      comparison = -1;\n    }\n    return order == Order.DESC ? comparison * -1 : comparison;\n  };\n}\n","import { EntityState, SelectOptions } from './types';\nimport { isFunction } from './isFunction';\nimport { compareValues } from './sort';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToArray<E, S extends EntityState>(state: S, options: SelectOptions<E>): E[] {\n  let arr = [];\n  const { ids, entities } = state;\n  const { filterBy, limitTo, sortBy, sortByOrder } = options;\n\n  for (let i = 0; i < ids.length; i++) {\n    const entity = entities[ids[i]];\n    if (!filterBy) {\n      arr.push(entity);\n      continue;\n    }\n\n    const toArray = coerceArray(filterBy);\n    const allPass = toArray.every(fn => fn(entity, i));\n    if (allPass) {\n      arr.push(entity);\n    }\n  }\n\n  if (sortBy) {\n    let _sortBy: any = isFunction(sortBy) ? sortBy : compareValues(sortBy, sortByOrder);\n    arr = arr.sort((a, b) => _sortBy(a, b, state));\n  }\n\n  const length = Math.min(limitTo || arr.length, arr.length);\n\n  return length === arr.length ? arr : arr.slice(0, length);\n}\n","import { EntityState } from './types';\nimport { isNil } from './isNil';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToMap<S extends EntityState<E>, E>(state: S, options) {\n  const map = {};\n  const { filterBy, limitTo } = options;\n  const { ids, entities } = state;\n\n  if (!filterBy && !limitTo) {\n    return entities;\n  }\n  const hasLimit = isNil(limitTo) === false;\n\n  if (filterBy && hasLimit) {\n    let count = 0;\n    for (let i = 0, length = ids.length; i < length; i++) {\n      if (count === limitTo) break;\n      const id = ids[i];\n      const entity = entities[id];\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n        count++;\n      }\n    }\n  } else {\n    const finalLength = Math.min(limitTo || ids.length, ids.length);\n\n    for (let i = 0; i < finalLength; i++) {\n      const id = ids[i];\n      const entity = entities[id];\n\n      if (!filterBy) {\n        map[id] = entity;\n        continue;\n      }\n\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n      }\n    }\n  }\n\n  return map;\n}\n","// @internal\nexport function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n","import { isUndefined } from './isUndefined';\nimport { isString } from './isString';\nimport { ItemPredicate } from './types';\n\n// @internal\nexport function findEntityByPredicate<E>(predicate: ItemPredicate<E>, entities) {\n    for(const entityId of Object.keys(entities)) {\n      if(predicate(entities[entityId]) === true) {\n        return entityId;\n      }\n    }\n\n    return undefined;\n}\n\n// @internal\nexport function getEntity( id, project ) {\n  return function(entities) {\n    const entity = entities[id];\n\n    if(isUndefined(entity)) {\n      return undefined;\n    }\n\n    if(!project) {\n      return entity;\n    }\n\n    if(isString(project)) {\n      return entity[project];\n    }\n\n    return (project as Function)(entity);\n  };\n\n}\n","import { Order } from './sort';\n\nexport type SortBy<E, S = any> = ((a: E, b: E, state?: S) => number) | keyof E;\n\nexport interface SortByOptions<E> {\n  sortBy?: SortBy<E>;\n  sortByOrder?: Order;\n}\n\nexport interface QueryConfigOptions<E = any> extends SortByOptions<E> {}\n\nexport const queryConfigKey = 'akitaQueryConfig';\n\nexport function QueryConfig<E>(metadata: QueryConfigOptions<E>) {\n  return function(constructor: Function) {\n    constructor[queryConfigKey] = {};\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      constructor[queryConfigKey][key] = metadata[key];\n    }\n  };\n}\n","import { Store } from './store';\nimport { Observable } from 'rxjs';\nimport { queryConfigKey, QueryConfigOptions } from './queryConfig';\nimport { isString } from './isString';\nimport { isFunction } from './isFunction';\nimport { isDev } from './env';\nimport { __queries__ } from './stores';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { compareKeys } from './compareKeys';\nimport { ReturnTypes } from './types';\n\nexport class Query<S> {\n  // @internal\n  __store__: Store<S>;\n\n  constructor(protected store: Store<S>) {\n    this.__store__ = store;\n    if (isDev()) {\n      // @internal\n      __queries__[store.storeName] = this;\n    }\n  }\n\n  /**\n   * Select a slice from the store\n   *\n   * @example\n   *\n   * this.query.select()\n   * this.query.select(state => state.entities)\n   * this.query.select('token');\n   * this.query.select(['name', 'email'])\n   * this.query.select([state => state.name, state => state.age])\n   *\n   */\n  select<K extends keyof S>(key: K): Observable<S[K]>;\n  select<R>(project: (store: S) => R): Observable<R>;\n  select<K extends keyof S>(stateKeys: K[]): Observable<Pick<S, K>>;\n  select<R extends [(state: S) => any] | Array<(state: S) => any>>(selectorFns: R): Observable<ReturnTypes<R>>;\n  select(): Observable<S>;\n  select<R>(project?: ((store: S) => R) | keyof S | (keyof S)[] | ((state: S) => any)[]): Observable<R | S | any[]> {\n    let mapFn;\n    if (isFunction(project)) {\n      mapFn = project;\n    } else if (isString(project)) {\n      mapFn = state => state[project];\n    } else if (Array.isArray(project)) {\n      return this.store\n        ._select(state => state)\n        .pipe(\n          distinctUntilChanged(compareKeys(project)),\n          map(state => {\n            if (isFunction(project[0])) {\n              return (project as ((state: S) => any)[]).map(func => func(state));\n            }\n\n            return (project as (keyof S)[]).reduce((acc, k) => {\n              acc[k as any] = state[k];\n              return acc;\n            }, {});\n          })\n        ) as any;\n    } else {\n      mapFn = state => state;\n    }\n\n    return this.store._select(mapFn);\n  }\n\n  /**\n   * Select the loading state\n   *\n   * @example\n   *\n   * this.query.selectLoading().subscribe(isLoading => {})\n   */\n  selectLoading() {\n    return this.select(state => (state as S & { loading: boolean }).loading);\n  }\n\n  /**\n   * Select the error state\n   *\n   * @example\n   *\n   * this.query.selectError().subscribe(error => {})\n   */\n  selectError<ErrorType = any>(): Observable<ErrorType> {\n    return this.select(state => (state as S & { error: ErrorType }).error);\n  }\n\n  /**\n   * Get the store's value\n   *\n   * @example\n   *\n   * this.query.getValue()\n   *\n   */\n  getValue(): S {\n    return this.store._value();\n  }\n\n  /**\n   * Select the cache state\n   *\n   * @example\n   *\n   * this.query.selectHasCache().pipe(\n   *   switchMap(hasCache => {\n   *     return hasCache ? of() : http().pipe(res => store.set(res))\n   *   })\n   * )\n   */\n  selectHasCache(): Observable<boolean> {\n    return this.store._cache().asObservable();\n  }\n\n  /**\n   * Whether we've cached data\n   *\n   * @example\n   *\n   * this.query.getHasCache()\n   *\n   */\n  getHasCache(): boolean {\n    return this.store._cache().value;\n  }\n\n  // @internal\n  get config(): QueryConfigOptions {\n    return this.constructor[queryConfigKey];\n  }\n}\n","import { isFunction } from './isFunction';\n\nexport function compareKeys<T>(keysOrFuncs: any[]) {\n  return function <T>(prevState, currState) {\n    const isFns = isFunction(keysOrFuncs[0]);\n    // Return when they are NOT changed\n    return keysOrFuncs.some(keyOrFunc => {\n      if(isFns) {\n        return keyOrFunc(prevState) !== keyOrFunc(currState);\n      }\n      return prevState[keyOrFunc] !== currState[keyOrFunc];\n    }) === false;\n  };\n}\n","// @internal\nexport function sortByOptions(options, config) {\n  options.sortBy = options.sortBy || (config && config.sortBy);\n  options.sortByOrder = options.sortByOrder || (config && config.sortByOrder);\n}\n","import { Observable, of } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\nimport { distinctUntilArrayItemChanged } from './arrayFind';\nimport { entitiesToArray } from './entitiesToArray';\nimport { entitiesToMap } from './entitiesToMap';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { EntityStore } from './entityStore';\nimport { findEntityByPredicate, getEntity } from './getEntity';\nimport { isArray } from './isArray';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isUndefined } from './isUndefined';\nimport { mapSkipUndefined } from './mapSkipUndefined';\nimport { Query } from './query';\nimport { QueryConfigOptions } from './queryConfig';\nimport { SelectAllOptionsA, SelectAllOptionsB, SelectAllOptionsC, SelectAllOptionsD, SelectAllOptionsE } from './selectAllOverloads';\nimport { sortByOptions } from './sortByOptions';\nimport { toBoolean } from './toBoolean';\nimport { EntityState, getEntityType, getIDType, HashMap, ItemPredicate, OrArray, SelectOptions } from './types';\n\n/**\n *\n *  The Entity Query is similar to the general Query, with additional functionality tailored for EntityStores.\n *\n *  class WidgetsQuery extends QueryEntity<WidgetsState> {\n *     constructor(protected store: WidgetsStore) {\n *       super(store);\n *     }\n *  }\n *\n *\n *\n */\nexport class QueryEntity<S extends EntityState, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Query<S> {\n  ui: EntityUIQuery<any, EntityType>;\n  protected store: EntityStore<S>;\n\n  // @internal\n  __store__;\n\n  constructor(store: EntityStore<S>, private options: QueryConfigOptions = {}) {\n    super(store);\n    this.__store__ = store;\n  }\n\n  /**\n   * Select the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.selectAll()\n   *\n   * this.query.selectAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.selectAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.selectAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   *\n   */\n  selectAll(options: SelectAllOptionsA<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsB<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsC<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsD<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsE<EntityType>): Observable<EntityType[]>;\n  selectAll(): Observable<EntityType[]>;\n  selectAll(\n    options: SelectOptions<EntityType> = {\n      asObject: false\n    }\n  ): Observable<EntityType[] | HashMap<EntityType>> {\n    return this.select(state => state.entities).pipe(map(() => this.getAll(options)));\n  }\n\n  /**\n   * Get the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.getAll()\n   *\n   * this.query.getAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.getAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.getAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   */\n  getAll(options: SelectAllOptionsA<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsB<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsC<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsD<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsE<EntityType>): EntityType[];\n  getAll(): EntityType[];\n  getAll(options: SelectOptions<EntityType> = { asObject: false, filterBy: undefined, limitTo: undefined }): EntityType[] | HashMap<EntityType> {\n    if (options.asObject) {\n      return entitiesToMap(this.getValue(), options);\n    }\n    sortByOptions(options, this.config || this.options);\n\n    return entitiesToArray(this.getValue(), options);\n  }\n\n  /**\n   * Select multiple entities from the store\n   *\n   * @example\n   *\n   * this.query.selectMany([1,2,3])\n   * this.query.selectMany([1,2], entity => entity.title)\n   */\n  selectMany<R>(ids: IDType[]): Observable<EntityType[]>;\n  selectMany<R>(ids: IDType[], project: (entity: EntityType) => R): Observable<R[]>;\n  selectMany<R>(ids: IDType[], project?: (entity: EntityType) => R): Observable<EntityType[] | R[]> {\n    if (!ids || !ids.length) return of([]);\n\n    return this.select(state => state.entities).pipe(\n      map(entities => mapSkipUndefined(ids, id => getEntity(id, project)(entities))),\n      distinctUntilArrayItemChanged()\n    );\n  }\n\n  /**\n   * Select an entity or a slice of an entity\n   *\n   * @example\n   *\n   * this.query.selectEntity(1)\n   * this.query.selectEntity(1, entity => entity.config.date)\n   * this.query.selectEntity(1, 'comments')\n   * this.query.selectEntity(e => e.title === 'title')\n   *\n   */\n  selectEntity<R>(id: IDType): Observable<EntityType>;\n  selectEntity<K extends keyof EntityType>(id: IDType, project?: K): Observable<EntityType[K]>;\n  selectEntity<R>(id: IDType, project: (entity: EntityType) => R): Observable<R>;\n  selectEntity<R>(predicate: ItemPredicate<EntityType>): Observable<EntityType>;\n  selectEntity<R>(idOrPredicate: IDType | ItemPredicate<EntityType>, project?: ((entity: EntityType) => R) | keyof EntityType): Observable<R | EntityType> {\n    let id = idOrPredicate;\n\n    if (isFunction(idOrPredicate)) {\n      // For performance reason we expect the entity to be in the store\n      (id as any) = findEntityByPredicate(idOrPredicate, this.getValue().entities);\n    }\n\n    return this.select(state => state.entities).pipe(\n      map(getEntity(id, project)),\n      distinctUntilChanged()\n    );\n  }\n\n  /**\n   * Get an entity by id\n   *\n   * @example\n   *\n   * this.query.getEntity(1);\n   */\n  getEntity(id: IDType): EntityType {\n    return this.getValue().entities[id as any];\n  }\n\n  /**\n   * Select the active entity's id\n   *\n   * @example\n   *\n   * this.query.selectActiveId()\n   */\n  selectActiveId(): Observable<S['active']> {\n    return this.select(state => (state as S & { active: S['active'] }).active);\n  }\n\n  /**\n   * Get the active id\n   *\n   * @example\n   *\n   * this.query.getActiveId()\n   */\n  getActiveId(): S['active'] {\n    return this.getValue().active;\n  }\n\n  /**\n   * Select the active entity\n   *\n   * @example\n   *\n   * this.query.selectActive()\n   * this.query.selectActive(entity => entity.title)\n   */\n  selectActive<R>(): S['active'] extends any[] ? Observable<EntityType[]> : Observable<EntityType>;\n  selectActive<R>(project?: (entity: EntityType) => R): S['active'] extends any[] ? Observable<R[]> : Observable<R>;\n  selectActive<R>(project?: (entity: EntityType) => R): Observable<R | EntityType> | Observable<EntityType[] | R[]> {\n    if (isArray(this.getActive())) {\n      return this.selectActiveId().pipe(switchMap(ids => this.selectMany(ids, project)));\n    }\n    return this.selectActiveId().pipe(switchMap(ids => this.selectEntity(ids, project)));\n  }\n\n  /**\n   * Get the active entity\n   *\n   * @example\n   *\n   * this.query.getActive()\n   */\n  getActive(): S['active'] extends any[] ? EntityType[] : EntityType;\n  getActive(): OrArray<EntityType> {\n    const activeId = this.getActiveId();\n    if (isArray(activeId)) {\n      return activeId.map(id => this.getValue().entities[id as any]);\n    }\n    return toBoolean(activeId) ? this.getEntity(activeId) : undefined;\n  }\n\n  /**\n   * Select the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.selectCount()\n   * this.query.selectCount(entity => entity.completed)\n   */\n  selectCount(predicate?: (entity: EntityType, index: number) => boolean): Observable<number> {\n    return this.select(state => state.entities).pipe(map(() => this.getCount(predicate)));\n  }\n\n  /**\n   * Get the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.getCount()\n   * this.query.getCount(entity => entity.completed)\n   */\n  getCount(predicate?: (entity: EntityType, index: number) => boolean): number {\n    if (isFunction(predicate)) {\n      return this.getAll().filter(predicate).length;\n    }\n    return this.getValue().ids.length;\n  }\n\n  /**\n   *\n   * Select the last entity from the store\n   *\n   * @example\n   *\n   * this.query.selectLast()\n   * this.query.selectLast(todo => todo.title)\n   */\n  selectLast<R>(): Observable<EntityType>;\n  selectLast<R>(project: (entity: EntityType) => R): Observable<R>;\n  selectLast<R>(project?: (entity: EntityType) => R): Observable<R | EntityType> {\n    return this.selectAt(ids => ids[ids.length - 1], project);\n  }\n\n  /**\n   *\n   * Select the first entity from the store\n   *\n   * @example\n   *\n   * this.query.selectFirst()\n   * this.query.selectFirst(todo => todo.title)\n   */\n  selectFirst<R>(): Observable<EntityType>;\n  selectFirst<R>(project: (entity: EntityType) => R): Observable<R>;\n  selectFirst<R>(project?: (entity: EntityType) => R): Observable<R | EntityType> {\n    return this.selectAt(ids => ids[0], project);\n  }\n\n  /**\n   *\n   * Listen for entity actions\n   *\n   *  @example\n   *\n   *  this.query.selectEntityAction(EntityActions.Add);\n   *  this.query.selectEntityAction(EntityActions.Update);\n   *  this.query.selectEntityAction(EntityActions.Remove);\n   *\n   *  this.query.selectEntityAction();\n   */\n  selectEntityAction(action: EntityActions): Observable<IDType[]>;\n  selectEntityAction(): Observable<EntityAction<IDType>>;\n  selectEntityAction(action?: EntityActions): Observable<IDType[] | EntityAction<IDType>> {\n    if (isUndefined(action)) {\n      return this.store.selectEntityAction$;\n    }\n    return this.store.selectEntityAction$.pipe(\n      filter(ac => ac.type === action),\n      map(action => action.ids)\n    );\n  }\n\n  /**\n   * Returns whether entity exists\n   *\n   * @example\n   *\n   * this.query.hasEntity(2)\n   * this.query.hasEntity(entity => entity.completed)\n   * this.query.hasEntity([1, 2, 33])\n   *\n   */\n  hasEntity(id: IDType): boolean;\n  hasEntity(id: IDType[]): boolean;\n  hasEntity(project: (entity: EntityType) => boolean): boolean;\n  hasEntity(): boolean;\n  hasEntity(projectOrIds?: IDType | IDType[] | ((entity: EntityType) => boolean)): boolean {\n    if (isNil(projectOrIds)) {\n      return this.getValue().ids.length > 0;\n    }\n\n    if (isFunction(projectOrIds)) {\n      return this.getAll().some(projectOrIds);\n    }\n\n    if (isArray(projectOrIds)) {\n      return projectOrIds.every(id => (id as any) in this.getValue().entities);\n    }\n\n    return (projectOrIds as any) in this.getValue().entities;\n  }\n\n  /**\n   * Returns whether entity store has an active entity\n   *\n   * @example\n   *\n   * this.query.hasActive()\n   * this.query.hasActive(3)\n   *\n   */\n  hasActive(id?: IDType): boolean {\n    const active = this.getValue().active;\n    const isIdProvided = isDefined(id);\n    if (Array.isArray(active)) {\n      if (isIdProvided) {\n        return active.includes(id);\n      }\n      return active.length > 0;\n    }\n    return isIdProvided ? active === id : isDefined(active);\n  }\n\n  /**\n   *\n   * Create sub UI query for querying Entity's UI state\n   *\n   * @example\n   *\n   *\n   * export class ProductsQuery extends QueryEntity<ProductsState> {\n   *   ui: EntityUIQuery<ProductsUIState>;\n   *\n   *   constructor(protected store: ProductsStore) {\n   *     super(store);\n   *     this.createUIQuery();\n   *   }\n   *\n   * }\n   */\n  createUIQuery() {\n    this.ui = new EntityUIQuery(this.__store__.ui);\n  }\n\n  private selectAt<R>(mapFn: (ids: IDType[]) => IDType, project?: (entity: EntityType) => R) {\n    return this.select(state => state.ids as any[]).pipe(\n      map(mapFn),\n      distinctUntilChanged(),\n      switchMap((id: IDType) => this.selectEntity(id, project))\n    );\n  }\n}\n\n// @internal\nexport class EntityUIQuery<UIState, DEPRECATED = any> extends QueryEntity<UIState> {\n  constructor(store) {\n    super(store);\n  }\n}\n","// @internal\nexport function mapSkipUndefined<T, V>(arr: T[], callbackFn: (value: T, index: number, array: T[]) => V) {\n  return arr.reduce((result, value, index, array) => {\n    const val = callbackFn(value, index, array);\n    if (val !== undefined) {\n      result.push(val);\n    }\n    return result;\n  }, []);\n}\n","import { Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { Diff } from './types';\n\n/**\n * @example\n *\n * query.selectEntity(2).pipe(filterNil)\n */\nexport const filterNil = <T>(source: Observable<T | undefined | null>) => source.pipe(filter((value): value is Diff<T, null | undefined> => value !== null && typeof value !== 'undefined'));\n","/**\n * @internal\n *\n * @example\n *\n * getValue(state, 'todos.ui')\n *\n */\nexport function getValue( obj: any, prop: string ) {\n  /** return the whole state  */\n  if( prop.split('.').length === 1 ) {\n    return obj;\n  }\n  const removeStoreName = prop\n    .split('.')\n    .slice(1)\n    .join('.');\n  return removeStoreName.split('.').reduce(( acc: any, part: string ) => acc && acc[part], obj);\n}\n","import { isObject } from './isObject';\n\n/**\n * @internal\n *\n * @example\n * setValue(state, 'todos.ui', { filter: {} })\n */\nexport function setValue(obj: any, prop: string, val: any) {\n  const split = prop.split('.');\n\n  if (split.length === 1) {\n    return { ...obj, ...val };\n  }\n\n  obj = { ...obj };\n\n  const lastIndex = split.length - 2;\n  const removeStoreName = prop.split('.').slice(1);\n\n  removeStoreName.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      if (isObject(acc[part])) {\n        acc[part] = { ...acc[part], ...val };\n      } else {\n        acc[part] = val;\n      }\n    } else {\n      acc[part] = { ...acc[part] };\n    }\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n}\n","import { filter, skip } from 'rxjs/operators';\nimport { from, isObservable, of, OperatorFunction, ReplaySubject, Subscription } from 'rxjs';\nimport { HashMap, MaybeAsync } from './types';\nimport { isFunction } from './isFunction';\nimport { AkitaError } from './errors';\nimport { __stores__ } from './stores';\nimport { getValue } from './getValueByString';\nimport { setAction } from './actions';\nimport { setValue } from './setValueByString';\nimport { $$addStore, $$deleteStore } from './dispatchers';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { isNotBrowser, hasLocalStorage, hasSessionStorage } from './root';\n\nlet skipStorageUpdate = false;\n\nconst _persistStateInit = new ReplaySubject(1);\n\nexport function selectPersistStateInit() {\n  return _persistStateInit.asObservable();\n}\n\nexport function setSkipStorageUpdate(skip: boolean) {\n  skipStorageUpdate = skip;\n}\n\nexport function getSkipStorageUpdate() {\n  return skipStorageUpdate;\n}\n\nexport interface PersistStateStorage {\n  getItem(key: string): MaybeAsync;\n\n  setItem(key: string, value: any): MaybeAsync;\n\n  clear(): void;\n}\n\nfunction isPromise(v: any) {\n  return v && isFunction(v.then);\n}\n\nfunction observify(asyncOrValue: any) {\n  if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {\n    return from(asyncOrValue);\n  }\n\n  return of(asyncOrValue);\n}\n\nexport interface PersistStateParams {\n  /** The storage key */\n  key: string;\n  /** Whether to enable persistState in a non-browser environment */\n  enableInNonBrowser: boolean;\n  /** Storage strategy to use. This defaults to LocalStorage but you can pass SessionStorage or anything that implements the StorageEngine API. */\n  storage: PersistStateStorage;\n  /** Custom deserializer. Defaults to JSON.parse */\n  deserialize: Function;\n  /** Custom serializer, defaults to JSON.stringify */\n  serialize: Function;\n  /**\n   * By default the whole state is saved to storage, use this param to include only the stores you need.\n   * Pay attention that you can't use both include and exclude\n   */\n  include: (string | ((storeName: string) => boolean))[];\n  /**\n   *  By default the whole state is saved to storage, use this param to exclude stores that you don't need.\n   *  Pay attention that you can't use both include and exclude\n   */\n  exclude: string[];\n\n  preStorageUpdate(storeName: string, state: any): any;\n\n  preStoreUpdate(storeName: string, state: any): any;\n\n  skipStorageUpdate: () => boolean;\n  preStorageUpdateOperator: () => OperatorFunction<any, any>;\n  /** Whether to persist a dynamic store upon destroy */\n  persistOnDestroy: boolean;\n}\n\nexport function persistState(params?: Partial<PersistStateParams>) {\n  const defaults: PersistStateParams = {\n    key: 'AkitaStores',\n    enableInNonBrowser: false,\n    storage: !hasLocalStorage() ? params.storage : localStorage,\n    deserialize: JSON.parse,\n    serialize: JSON.stringify,\n    include: [],\n    /**\n     * @deprecated use include with a callback\n     */\n    exclude: [],\n    persistOnDestroy: false,\n    preStorageUpdate: function(storeName, state) {\n      return state;\n    },\n    preStoreUpdate: function(storeName, state) {\n      return state;\n    },\n    skipStorageUpdate: getSkipStorageUpdate,\n    preStorageUpdateOperator: () => source => source\n  };\n\n  const { storage, enableInNonBrowser, deserialize, serialize, include, exclude, key, preStorageUpdate, persistOnDestroy, preStorageUpdateOperator, preStoreUpdate, skipStorageUpdate } = Object.assign(\n    {},\n    defaults,\n    params\n  );\n\n  if ((isNotBrowser && !enableInNonBrowser) || !storage) return;\n\n  const hasInclude = include.length > 0;\n  const hasExclude = exclude.length > 0;\n  let includeStores: { fns: Function[]; [key: string]: Function[] | string };\n\n  if (hasInclude && hasExclude) {\n    throw new AkitaError(\"You can't use both include and exclude\");\n  }\n\n  if (hasInclude) {\n    includeStores = include.reduce(\n      (acc, path) => {\n        if (isFunction(path)) {\n          acc.fns.push(path);\n        } else {\n          const storeName = path.split('.')[0];\n          acc[storeName] = path;\n        }\n        return acc;\n      },\n      { fns: [] }\n    );\n  }\n\n  let stores: HashMap<Subscription> = {};\n  let acc = {};\n  let subscriptions: Subscription[] = [];\n\n  const buffer = [];\n\n  function _save(v: any) {\n    observify(v).subscribe(() => {\n      const next = buffer.shift();\n      next && _save(next);\n    });\n  }\n\n  // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it\n  const isLocalStorage = (hasLocalStorage() && storage === localStorage) || (hasSessionStorage() && storage === sessionStorage);\n\n  observify(storage.getItem(key)).subscribe((value: any) => {\n    let storageState = isObject(value) ? value : deserialize(value || '{}');\n\n    function save(storeCache) {\n      storageState['$cache'] = { ...(storageState['$cache'] || {}), ...storeCache };\n      storageState = Object.assign({}, storageState, acc);\n\n      buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));\n      _save(buffer.shift());\n    }\n\n    function subscribe(storeName, path) {\n      stores[storeName] = __stores__[storeName]\n        ._select(state => getValue(state, path))\n        .pipe(\n          skip(1),\n          filter(() => skipStorageUpdate() === false),\n          preStorageUpdateOperator()\n        )\n        .subscribe(data => {\n          acc[storeName] = preStorageUpdate(storeName, data);\n          Promise.resolve().then(() => save({ [storeName]: __stores__[storeName]._cache().getValue() }));\n        });\n    }\n\n    function setInitial(storeName, store, path) {\n      if (storeName in storageState) {\n        setAction('@PersistState');\n        store._setState(state => {\n          return setValue(state, path, preStoreUpdate(storeName, storageState[storeName]));\n        });\n        const hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;\n        __stores__[storeName].setHasCache(hasCache, { restartTTL: true });\n      }\n    }\n\n    subscriptions.push(\n      $$deleteStore.subscribe(storeName => {\n        if (stores[storeName]) {\n          if (persistOnDestroy === false) {\n            save({ [storeName]: false });\n          }\n          stores[storeName].unsubscribe();\n          delete stores[storeName];\n        }\n      })\n    );\n\n    subscriptions.push(\n      $$addStore.subscribe(storeName => {\n        if (storeName === 'router' || (hasExclude && exclude.includes(storeName))) {\n          return;\n        }\n\n        const store = __stores__[storeName];\n        if (hasInclude) {\n          let path = includeStores[storeName];\n\n          if (!path) {\n            const passPredicate = includeStores.fns.some(fn => fn(storeName));\n            if (passPredicate) {\n              path = storeName;\n            } else {\n              return;\n            }\n          }\n          setInitial(storeName, store, path);\n          subscribe(storeName, path);\n        } else {\n          setInitial(storeName, store, storeName);\n          subscribe(storeName, storeName);\n        }\n      })\n    );\n\n    _persistStateInit.next();\n  });\n\n  return {\n    destroy() {\n      subscriptions.forEach(s => s.unsubscribe());\n      for (let i = 0, keys = Object.keys(stores); i < keys.length; i++) {\n        const storeName = keys[i];\n        stores[storeName].unsubscribe();\n      }\n      stores = {};\n    },\n    clear() {\n      storage.clear();\n    },\n    clearStore(storeName?: string) {\n      if (isNil(storeName)) {\n        const value = observify(storage.setItem(key, '{}'));\n        value.subscribe();\n        return;\n      }\n      const value = storage.getItem(key);\n      observify(value).subscribe(v => {\n        const storageState = deserialize(v || '{}');\n\n        if (storageState[storeName]) {\n          delete storageState[storeName];\n          const value = observify(storage.setItem(key, serialize(storageState)));\n          value.subscribe();\n        }\n      });\n    }\n  };\n}\n","import { __stores__ } from './stores';\nimport { isString } from './isString';\nimport { setSkipStorageUpdate } from './persistState';\nimport { $$addStore } from './dispatchers';\nimport { filter, take } from 'rxjs/operators';\n\nexport class SnapshotManager {\n  /**\n   * Get a snapshot of the whole state or a specific stores\n   * Use it ONLY for things such as saving the state in the server\n   */\n  getStoresSnapshot(stores: string[] = []) {\n    let acc = {};\n    const hasInclude = stores.length > 0;\n    const keys = hasInclude ? stores : Object.keys(__stores__);\n    for (let i = 0; i < keys.length; i++) {\n      let storeName = keys[i];\n      if (storeName !== 'router') {\n        acc[storeName] = __stores__[storeName]._value();\n      }\n    }\n\n    return acc;\n  }\n\n  setStoresSnapshot(stores: { [storeName: string]: any } | string, options?: { skipStorageUpdate?: boolean; lazy?: boolean }) {\n    const mergedOptions = { ...{ skipStorageUpdate: false, lazy: false }, ...options };\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(true);\n\n    let normalizedStores = stores;\n\n    if (isString(stores)) {\n      normalizedStores = JSON.parse(normalizedStores as string);\n    }\n\n    const size = Object.keys(normalizedStores).length;\n\n    if (mergedOptions.lazy) {\n      $$addStore\n        .pipe(\n          filter(name => normalizedStores.hasOwnProperty(name)),\n          take(size)\n        )\n        .subscribe(name => __stores__[name]._setState(() => normalizedStores[name]));\n    } else {\n      for (let i = 0, keys = Object.keys(normalizedStores); i < keys.length; i++) {\n        const storeName = keys[i];\n        if (__stores__[storeName]) {\n          __stores__[storeName]._setState(() => normalizedStores[storeName]);\n        }\n      }\n    }\n\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(false);\n  }\n}\n\nexport const snapshotManager = new SnapshotManager();\n","import { QueryEntity } from '../queryEntity';\nimport { Query } from '../query';\nimport { filterNil } from '../filterNil';\nimport { toBoolean } from '../toBoolean';\nimport { getAkitaConfig } from '../config';\nimport { getValue } from '../getValueByString';\nimport { setValue } from '../setValueByString';\n\nexport type Queries<State> = Query<State> | QueryEntity<State>;\n\nexport abstract class AkitaPlugin<State = any> {\n  protected constructor(protected query: Queries<State>, config?: { resetFn?: Function }) {\n    if (config && config.resetFn) {\n      if (getAkitaConfig().resettable) {\n        this.onReset(config.resetFn);\n      }\n    }\n  }\n\n  /** This method is responsible for getting access to the query. */\n  protected getQuery() {\n    return this.query;\n  }\n\n  /** This method is responsible for getting access to the store. */\n  protected getStore() {\n    return this.getQuery().__store__;\n  }\n\n  /** This method is responsible for cleaning. */\n  public abstract destroy();\n\n  /** This method is responsible tells whether the plugin is entityBased or not.  */\n  protected isEntityBased(entityId: any) {\n    return toBoolean(entityId);\n  }\n\n  /** This method is responsible for selecting the source; it can be the whole store or one entity. */\n  protected selectSource(entityId: any, property?: string) {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).selectEntity(entityId).pipe(filterNil);\n    }\n\n    if (property) {\n      return this.getQuery().select(state => getValue(state, this.withStoreName(property)));\n    }\n\n    return this.getQuery().select();\n  }\n\n  protected getSource(entityId: any, property?: string): any {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).getEntity(entityId);\n    }\n\n    const state = this.getQuery().getValue();\n\n    if (property) {\n      return getValue(state, this.withStoreName(property));\n    }\n\n    return state;\n  }\n\n  protected withStoreName(prop: string) {\n    return `${this.storeName}.${prop}`;\n  }\n\n  protected get storeName() {\n    return this.getStore().storeName;\n  }\n\n  /** This method is responsible for updating the store or one entity; it can be the whole store or one entity. */\n  protected updateStore(newState, entityId?, property?: string) {\n    if (this.isEntityBased(entityId)) {\n      this.getStore().update(entityId, newState);\n    } else {\n      if (property) {\n        this.getStore()._setState(state => {\n          return setValue(state, this.withStoreName(property), newState);\n        });\n        return;\n      }\n      this.getStore()._setState(state => ({ ...state, ...newState }));\n    }\n  }\n\n  /**\n   * Function to invoke upon reset\n   */\n  private onReset(fn: Function) {\n    const original = this.getStore().reset;\n    this.getStore().reset = (...params) => {\n      /** It should run after the plugin destroy method */\n      setTimeout(() => {\n        original.apply(this.getStore(), params);\n        fn();\n      });\n    };\n  }\n}\n","import { QueryEntity } from '../../queryEntity';\nimport { delay, map, switchMap, take } from 'rxjs/operators';\nimport { BehaviorSubject, from, isObservable, Observable, Subscription } from 'rxjs';\nimport { EntityState, ID, getEntityType } from '../../types';\nimport { AkitaPlugin } from '../plugin';\nimport { applyTransaction } from '../../transaction';\nimport { isUndefined } from '../../isUndefined';\nimport { action, logAction } from '../../actions';\nimport { isNil } from '../../isNil';\n\nexport interface PaginationResponse<E> {\n  currentPage: number;\n  perPage: number;\n  lastPage: number;\n  data: E[];\n  total?: number;\n  from?: number;\n  to?: number;\n  pageControls?: number[];\n}\n\nexport type PaginatorConfig = {\n  pagesControls?: boolean;\n  range?: boolean;\n  startWith?: number;\n  cacheTimeout?: Observable<number>;\n  clearStoreWithCache?: boolean;\n};\n\nconst paginatorDefaults: PaginatorConfig = {\n  pagesControls: false,\n  range: false,\n  startWith: 1,\n  cacheTimeout: undefined,\n  clearStoreWithCache: true\n};\n\nexport class PaginatorPlugin<State extends EntityState> extends AkitaPlugin<State> {\n  /** Save current filters, sorting, etc. in cache */\n  metadata = new Map();\n\n  private page: BehaviorSubject<number>;\n  private pages = new Map<number, { ids: ID[] }>();\n  private readonly clearCacheSubscription: Subscription;\n\n  private pagination: PaginationResponse<getEntityType<State>> = {\n    currentPage: 1,\n    perPage: 0,\n    total: 0,\n    lastPage: 0,\n    data: []\n  };\n\n  /**\n   * When the user navigates to a different page and return\n   * we don't want to call `clearCache` on first time.\n   */\n  private initial = true;\n\n  constructor(protected query: QueryEntity<State>, public config: PaginatorConfig = {}) {\n    super(query, {\n      resetFn: () => {\n        this.initial = false;\n        this.destroy({ clearCache: true, currentPage: 1 });\n      }\n    });\n    this.config = Object.assign(paginatorDefaults, config);\n    const { startWith, cacheTimeout } = this.config;\n    this.page = new BehaviorSubject(startWith);\n    if (isObservable(cacheTimeout)) {\n      this.clearCacheSubscription = cacheTimeout.subscribe(() => this.clearCache());\n    }\n  }\n\n  /**\n   * Proxy to the query loading\n   */\n  isLoading$ = this.query.selectLoading().pipe(delay(0));\n\n  /**\n   * Listen to page changes\n   */\n  get pageChanges() {\n    return this.page.asObservable();\n  }\n\n  /**\n   * Get the current page number\n   */\n  get currentPage() {\n    return this.pagination.currentPage;\n  }\n\n  /**\n   * Check if current page is the first one\n   */\n  get isFirst() {\n    return this.currentPage === 1;\n  }\n\n  /**\n   * Check if current page is the last one\n   */\n  get isLast() {\n    return this.currentPage === this.pagination.lastPage;\n  }\n\n  /**\n   * Whether to generate an array of pages for *ngFor\n   * [1, 2, 3, 4]\n   */\n  withControls() {\n    this.config.pagesControls = true;\n    return this;\n  }\n\n  /**\n   * Whether to generate the `from` and `to` keys\n   * [1, 2, 3, 4]\n   */\n  withRange() {\n    this.config.range = true;\n    return this;\n  }\n\n  /**\n   * Set the loading state\n   */\n  setLoading(value = true) {\n    this.getStore().setLoading(value);\n  }\n\n  /**\n   * Update the pagination object and add the page\n   */\n  @action('@Pagination - New Page')\n  update(response: PaginationResponse<getEntityType<State>>) {\n    this.pagination = response;\n    this.addPage(response.data);\n  }\n\n  /**\n   *\n   * Set the ids and add the page to store\n   */\n  addPage(data: getEntityType<State>[]) {\n    this.pages.set(this.currentPage, { ids: data.map(entity => entity[this.getStore().idKey]) });\n    this.getStore().add(data);\n  }\n\n  /**\n   * Clear the cache.\n   */\n  clearCache(options: { clearStore?: boolean } = {}) {\n    if (!this.initial) {\n      logAction('@Pagination - Clear Cache');\n\n      if (options.clearStore !== false && (this.config.clearStoreWithCache || options.clearStore)) {\n        this.getStore().remove();\n      }\n\n      this.pages = new Map();\n      this.metadata = new Map();\n    }\n    this.initial = false;\n  }\n\n  clearPage(page: number) {\n    this.pages.delete(page);\n  }\n\n  /**\n   * Clear the cache timeout and optionally the pages\n   */\n  destroy({ clearCache, currentPage }: { clearCache?: boolean; currentPage?: number } = {}) {\n    if (this.clearCacheSubscription) {\n      this.clearCacheSubscription.unsubscribe();\n    }\n    if (clearCache) {\n      this.clearCache();\n    }\n    if (!isUndefined(currentPage)) {\n      this.setPage(currentPage);\n    }\n    this.initial = true;\n  }\n\n  /**\n   * Whether the provided page is active\n   */\n  isPageActive(page: number) {\n    return this.currentPage === page;\n  }\n\n  /**\n   * Set the current page\n   */\n  setPage(page: number) {\n    if (page !== this.currentPage || !this.hasPage(page)) {\n      this.page.next((this.pagination.currentPage = page));\n    }\n  }\n\n  /**\n   * Increment current page\n   */\n  nextPage() {\n    if (this.currentPage !== this.pagination.lastPage) {\n      this.setPage(this.pagination.currentPage + 1);\n    }\n  }\n\n  /**\n   * Decrement current page\n   */\n  prevPage() {\n    if (this.pagination.currentPage > 1) {\n      this.setPage(this.pagination.currentPage - 1);\n    }\n  }\n\n  /**\n   * Set current page to last\n   */\n  setLastPage() {\n    this.setPage(this.pagination.lastPage);\n  }\n\n  /**\n   * Set current page to first\n   */\n  setFirstPage() {\n    this.setPage(1);\n  }\n\n  /**\n   * Check if page exists in cache\n   */\n  hasPage(page: number) {\n    return this.pages.has(page);\n  }\n\n  /**\n   * Get the current page if it's in cache, otherwise invoke the request\n   */\n  getPage(req: () => Observable<PaginationResponse<getEntityType<State>>>) {\n    let page = this.pagination.currentPage;\n    if (this.hasPage(page)) {\n      return this.selectPage(page);\n    } else {\n      this.setLoading(true);\n      return from(req()).pipe(\n        switchMap((config: PaginationResponse<getEntityType<State>>) => {\n          page = config.currentPage;\n          applyTransaction(() => {\n            this.setLoading(false);\n            this.update(config);\n          });\n          return this.selectPage(page);\n        })\n      );\n    }\n  }\n\n  getQuery(): QueryEntity<State> {\n    return this.query;\n  }\n\n  refreshCurrentPage() {\n    if (isNil(this.currentPage) === false) {\n      this.clearPage(this.currentPage);\n      this.setPage(this.currentPage);\n    }\n  }\n\n  private getFrom() {\n    if (this.isFirst) {\n      return 1;\n    }\n    return (this.currentPage - 1) * this.pagination.perPage + 1;\n  }\n\n  private getTo() {\n    if (this.isLast) {\n      return this.pagination.total;\n    }\n    return this.currentPage * this.pagination.perPage;\n  }\n\n  /**\n   * Select the page\n   */\n  private selectPage(page: number): Observable<PaginationResponse<getEntityType<State>>> {\n    return this.query.selectAll({ asObject: true }).pipe(\n      take(1),\n      map(entities => {\n        let response: PaginationResponse<getEntityType<State>> = {\n          ...this.pagination,\n          data: this.pages.get(page).ids.map(id => entities[id])\n        };\n\n        const { range, pagesControls } = this.config;\n\n        /** If no total - calc it */\n        if (isNaN(this.pagination.total)) {\n          if (response.lastPage === 1) {\n            response.total = response.data ? response.data.length : 0;\n          } else {\n            response.total = response.perPage * response.lastPage;\n          }\n          this.pagination.total = response.total;\n        }\n\n        if (range) {\n          response.from = this.getFrom();\n          response.to = this.getTo();\n        }\n\n        if (pagesControls) {\n          response.pageControls = generatePages(this.pagination.total, this.pagination.perPage);\n        }\n\n        return response;\n      })\n    );\n  }\n}\n\n/**\n * Generate an array so we can ngFor them to navigate between pages\n */\nfunction generatePages(total: number, perPage: number) {\n  const len = Math.ceil(total / perPage);\n  let arr = [];\n  for (let i = 0; i < len; i++) {\n    arr.push(i + 1);\n  }\n  return arr;\n}\n\n/** backward compatibility */\nexport const Paginator = PaginatorPlugin;\n","import { AkitaPlugin } from '../plugin';\nimport { Query } from '../../query';\nimport { Observable, Subscription } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { getValue } from '../../getValueByString';\nimport { toBoolean } from '../../toBoolean';\nimport { isString } from '../../isString';\nimport { setValue } from '../../setValueByString';\nimport { logAction } from '../../actions';\n\nexport type FormGroupLike = {\n  patchValue: Function;\n  setValue: Function;\n  value: any;\n  get: Function;\n  valueChanges: Observable<any>;\n  controls: any;\n};\n\nexport type AkitaFormProp<T> = {\n  [key: string]: T;\n};\n\nexport type PersistFormParams = {\n  debounceTime?: number;\n  formKey?: string;\n  emitEvent?: boolean;\n  arrControlFactory?: ArrayControlFactory;\n};\n\nexport type ArrayControlFactory = (value: any) => any; // Todo: Return  AbstractControl interface\n\nexport class PersistNgFormPlugin<T = any> extends AkitaPlugin {\n  formChanges: Subscription;\n  private isRootKeys: boolean;\n  private form: FormGroupLike;\n  private isKeyBased: boolean;\n  private initialValue;\n  private builder;\n\n  constructor(protected query: Query<any>, private factoryFnOrPath?: Function | string, private params: PersistFormParams = {}) {\n    super(query);\n    this.params = { ...{ debounceTime: 300, formKey: 'akitaForm', emitEvent: false, arrControlFactory: v => this.builder.control(v) }, ...params };\n    this.isRootKeys = toBoolean(factoryFnOrPath) === false;\n    this.isKeyBased = isString(factoryFnOrPath) || this.isRootKeys;\n  }\n\n  setForm(form: FormGroupLike, builder?) {\n    this.form = form;\n    this.builder = builder;\n    this.activate();\n    return this;\n  }\n\n  reset(initialState?: T) {\n    let value;\n    if (initialState) {\n      value = initialState;\n    } else {\n      value = this.isKeyBased ? this.initialValue : (this as any).factoryFnOrPath();\n    }\n\n    if (this.isKeyBased) {\n      Object.keys(this.initialValue).forEach(stateKey => {\n        const value = this.initialValue[stateKey];\n        if (Array.isArray(value) && this.builder) {\n          const formArray = this.form.controls[stateKey];\n          this.cleanArray(formArray);\n          value.forEach((v, i) => {\n            this.form.get(stateKey).insert(i, (this.params.arrControlFactory as Function)(v));\n          });\n        }\n      });\n    }\n    this.form.patchValue(value, { emitEvent: this.params.emitEvent });\n\n    const storeValue = this.isKeyBased ? setValue(this.getQuery().getValue(), `${this.getStore().storeName}.${this.factoryFnOrPath}`, value) : { [this.params.formKey]: value };\n    this.updateStore(storeValue);\n  }\n\n  private cleanArray(control) {\n    while (control.length !== 0) {\n      control.removeAt(0);\n    }\n  }\n\n  private resolveInitialValue(formValue, root) {\n    if (!formValue) return;\n    return Object.keys(formValue).reduce((acc, stateKey) => {\n      const value = root[stateKey];\n      if (Array.isArray(value) && this.builder) {\n        const factory = this.params.arrControlFactory;\n        this.cleanArray(this.form.get(stateKey));\n        value.forEach((v, i) => {\n          this.form.get(stateKey).insert(i, (factory as Function)(v));\n        });\n      }\n      acc[stateKey] = root[stateKey];\n      return acc;\n    }, {});\n  }\n\n  private activate() {\n    let path;\n\n    if (this.isKeyBased) {\n      if (this.isRootKeys) {\n        this.initialValue = this.resolveInitialValue(this.form.value, this.getQuery().getValue());\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      } else {\n        path = `${this.getStore().storeName}.${this.factoryFnOrPath}`;\n        const root = getValue(this.getQuery().getValue(), path);\n        this.initialValue = this.resolveInitialValue(root, root);\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      }\n    } else {\n      if (!(this.getQuery().getValue() as AkitaFormProp<T>)[this.params.formKey]) {\n        logAction('@PersistNgFormPlugin activate');\n        this.updateStore({ [this.params.formKey]: (this as any).factoryFnOrPath() });\n      }\n\n      const value = this.getQuery().getValue()[this.params.formKey];\n      this.form.patchValue(value);\n    }\n\n    this.formChanges = this.form.valueChanges.pipe(debounceTime(this.params.debounceTime)).subscribe(value => {\n      logAction('@PersistForm - Update');\n      let newState;\n      if (this.isKeyBased) {\n        if (this.isRootKeys) {\n          newState = state => ({ ...state, ...value });\n        } else {\n          newState = state => setValue(state, path, value);\n        }\n      } else {\n        newState = () => ({ [this.params.formKey]: value });\n      }\n      this.updateStore(newState(this.getQuery().getValue()));\n    });\n  }\n\n  destroy() {\n    this.formChanges && this.formChanges.unsubscribe();\n    this.form = null;\n    this.builder = null;\n  }\n}\n","// @internal\nexport function capitalize(value: string) {\n  return value && value.charAt(0).toUpperCase() + value.slice(1);\n}\n","import { currentAction, setSkipAction } from './actions';\nimport { isDefined } from './isDefined';\nimport { $$addStore, $$deleteStore, $$updateStore } from './dispatchers';\nimport { __stores__ } from './stores';\nimport { capitalize } from './captialize';\nimport { isNotBrowser } from './root';\n\nexport type DevtoolsOptions = {\n  /** instance name visible in devtools */\n  name: string;\n  /**  maximum allowed actions to be stored in the history tree */\n  maxAge: number;\n  latency: number;\n  actionsBlacklist: string[];\n  actionsWhitelist: string[];\n  storesWhitelist: string[];\n  shouldCatchErrors: boolean;\n  logTrace: boolean;\n  predicate: (state: any, action: any) => boolean;\n  shallow: boolean;\n  sortAlphabetically: boolean;\n};\nlet subs = [];\n\nexport type NgZoneLike = { run: any };\n\nexport function akitaDevtools(ngZone: NgZoneLike, options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(ngZoneOrOptions?: NgZoneLike | Partial<DevtoolsOptions>, options: Partial<DevtoolsOptions> = {}) {\n  if (isNotBrowser) return;\n\n  if (!(window as any).__REDUX_DEVTOOLS_EXTENSION__) {\n    return;\n  }\n\n  subs.length &&\n    subs.forEach(s => {\n      if (s.unsubscribe) {\n        s.unsubscribe();\n      } else {\n        s && s();\n      }\n    });\n\n  const isAngular = ngZoneOrOptions && ngZoneOrOptions['run'];\n\n  if (!isAngular) {\n    ngZoneOrOptions = ngZoneOrOptions || {};\n    (ngZoneOrOptions as any).run = cb => cb();\n    options = ngZoneOrOptions as Partial<DevtoolsOptions>;\n  }\n\n  const defaultOptions: Partial<DevtoolsOptions> & { name: string } = { name: 'Akita', shallow: true, storesWhitelist: [] };\n  const merged = Object.assign({}, defaultOptions, options);\n  const storesWhitelist = merged.storesWhitelist;\n  const devTools = (window as any).__REDUX_DEVTOOLS_EXTENSION__.connect(merged);\n  let appState = {};\n\n  const isAllowed = storeName => {\n    if (!storesWhitelist.length) {\n      return true;\n    }\n\n    return storesWhitelist.indexOf(storeName) > -1;\n  };\n\n  subs.push(\n    $$addStore.subscribe(storeName => {\n      if (isAllowed(storeName) === false) return;\n      appState = {\n        ...appState,\n        [storeName]: __stores__[storeName]._value()\n      };\n      devTools.send({ type: `[${capitalize(storeName)}] - @@INIT` }, appState);\n    })\n  );\n\n  subs.push(\n    $$deleteStore.subscribe(storeName => {\n      if (isAllowed(storeName) === false) return;\n      delete appState[storeName];\n      devTools.send({ type: `[${storeName}] - Delete Store` }, appState);\n    })\n  );\n\n  subs.push(\n    $$updateStore.subscribe(storeName => {\n      if (isAllowed(storeName) === false) return;\n      const { type, entityIds, skip } = currentAction;\n\n      if (skip) {\n        setSkipAction(false);\n        return;\n      }\n\n      const store = __stores__[storeName];\n      if (!store) {\n        return;\n      }\n\n      if (options.shallow === false && appState[storeName]) {\n        const isEqual = JSON.stringify(store._value()) === JSON.stringify(appState[storeName]);\n        if (isEqual) return;\n      }\n\n      appState = {\n        ...appState,\n        [storeName]: store._value()\n      };\n\n      const normalize = capitalize(storeName);\n      let msg = isDefined(entityIds) ? `[${normalize}] - ${type} (ids: ${entityIds})` : `[${normalize}] - ${type}`;\n\n      if (options.logTrace) {\n        console.group(msg);\n        console.trace();\n        console.groupEnd();\n      }\n\n      if (options.sortAlphabetically) {\n        const sortedAppState = Object.keys(appState)\n          .sort()\n          .reduce((acc, storeName) => {\n            acc[storeName] = appState[storeName];\n            return acc;\n          }, {});\n\n        devTools.send({ type: msg }, sortedAppState);\n        return;\n      }\n\n      devTools.send({ type: msg }, appState);\n    })\n  );\n\n  subs.push(\n    devTools.subscribe(message => {\n      if (message.type === 'DISPATCH') {\n        const payloadType = message.payload.type;\n\n        if (payloadType === 'COMMIT') {\n          devTools.init(appState);\n          return;\n        }\n\n        if (message.state) {\n          const rootState = JSON.parse(message.state);\n          for (let i = 0, keys = Object.keys(rootState); i < keys.length; i++) {\n            const storeName = keys[i];\n            if (__stores__[storeName]) {\n              (ngZoneOrOptions as NgZoneLike).run(() => {\n                __stores__[storeName]._setState(() => rootState[storeName], false);\n              });\n            }\n          }\n        }\n      }\n    })\n  );\n}\n","import { Observable } from 'rxjs';\nimport { EntityState, OrArray, getIDType } from '../types';\nimport { QueryEntity } from '../queryEntity';\nimport { isUndefined } from '../isUndefined';\nimport { coerceArray } from '../coerceArray';\nimport { toBoolean } from '../toBoolean';\nimport { isFunction } from '../isFunction';\n\nexport type RebaseAction<P = any> = (plugin: P) => any;\n\nexport type RebaseActions<P = any> = { beforeRemove?: RebaseAction; beforeAdd?: RebaseAction; afterAdd?: RebaseAction };\n\n/**\n * Each plugin that wants to add support for entities should extend this interface.\n */\nexport abstract class EntityCollectionPlugin<State extends EntityState, P> {\n  protected entities = new Map<getIDType<State>, P>();\n\n  protected constructor(protected query: QueryEntity<State>, private entityIds: OrArray<getIDType<State>>) {}\n\n  /**\n   * Get the entity plugin instance.\n   */\n  protected getEntity(id: getIDType<State>): P {\n    return this.entities.get(id);\n  }\n\n  /**\n   * Whether the entity plugin exist.\n   */\n  protected hasEntity(id: getIDType<State>): boolean {\n    return this.entities.has(id);\n  }\n\n  /**\n   * Remove the entity plugin instance.\n   */\n  protected removeEntity(id: getIDType<State>) {\n    this.destroy(id);\n    return this.entities.delete(id);\n  }\n\n  /**\n   * Set the entity plugin instance.\n   */\n  protected createEntity(id: getIDType<State>, plugin: P) {\n    return this.entities.set(id, plugin);\n  }\n\n  /**\n   * If the user passes `entityIds` we take them; otherwise, we take all.\n   */\n  protected getIds(): any {\n    return isUndefined(this.entityIds) ? this.query.getValue().ids : coerceArray(this.entityIds);\n  }\n\n  /**\n   * When you call one of the plugin methods, you can pass id/ids or undefined which means all.\n   */\n  protected resolvedIds(ids?): getIDType<State>[] {\n    return isUndefined(ids) ? this.getIds() : coerceArray(ids);\n  }\n\n  /**\n   * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.\n   *\n   * For example in your plugin you may do the following:\n   *\n   * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));\n   */\n  protected rebase(ids: getIDType<State>[], actions: RebaseActions<P> = {}) {\n    /**\n     *\n     * If the user passes `entityIds` & we have new ids check if we need to add/remove instances.\n     *\n     * This phase will be called only upon update.\n     */\n    if (toBoolean(ids)) {\n      /**\n       * Which means all\n       */\n      if (isUndefined(this.entityIds)) {\n        for (let i = 0, len = ids.length; i < len; i++) {\n          const entityId = ids[i];\n          if (this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          }\n        }\n\n        this.entities.forEach((plugin, entityId) => {\n          if (ids.indexOf(entityId) === -1) {\n            isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n            this.removeEntity(entityId);\n          }\n        });\n      } else {\n        /**\n         * Which means the user passes specific ids\n         */\n        const _ids = coerceArray(this.entityIds);\n        for (let i = 0, len = _ids.length; i < len; i++) {\n          const entityId = _ids[i];\n          /** The Entity in current ids and doesn't exist, add it. */\n          if (ids.indexOf(entityId) > -1 && this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          } else {\n            this.entities.forEach((plugin, entityId) => {\n              /** The Entity not in current ids and exists, remove it. */\n              if (ids.indexOf(entityId) === -1 && this.hasEntity(entityId) === true) {\n                isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n                this.removeEntity(entityId);\n              }\n            });\n          }\n        }\n      }\n    } else {\n      /**\n       * Otherwise, start with the provided ids or all.\n       */\n      this.getIds().forEach(id => {\n        if (!this.hasEntity(id)) this.createEntity(id, this.instantiatePlugin(id));\n      });\n    }\n  }\n\n  /**\n   * Listen for add/remove entities.\n   */\n  protected selectIds(): Observable<any> {\n    return this.query.select(state => state.ids);\n  }\n\n  /**\n   * Base method for activation, you can override it if you need to.\n   */\n  protected activate(ids?: any[]) {\n    this.rebase(ids);\n  }\n\n  /**\n   * This method is responsible for plugin instantiation.\n   *\n   * For example:\n   * return new StateHistory(this.query, this.params, id) as P;\n   */\n  protected abstract instantiatePlugin(id: getIDType<State>): P;\n\n  /**\n   * This method is responsible for cleaning.\n   */\n  public abstract destroy(id?: getIDType<State>);\n\n  /**\n   * Loop over each id and invoke the plugin method.\n   */\n  protected forEachId(ids: OrArray<getIDType<State>>, cb: (entity: P) => any) {\n    const _ids = this.resolvedIds(ids);\n\n    for (let i = 0, len = _ids.length; i < len; i++) {\n      const id = _ids[i];\n      if (this.hasEntity(id)) {\n        cb(this.getEntity(id));\n      }\n    }\n  }\n}\n","import { pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { AkitaPlugin, Queries } from '../plugin';\nimport { logAction } from '../../actions';\nimport { isFunction } from '../../isFunction';\n\nexport interface StateHistoryParams {\n  maxAge?: number;\n  watchProperty?: string;\n  comparator?: (prevState, currentState) => boolean;\n}\n\nexport type History<State> = {\n  past: State[];\n  present: State | null;\n  future: State[];\n};\n\nexport class StateHistoryPlugin<State = any> extends AkitaPlugin<State> {\n  /** Allow skipping an update from outside */\n  private skip = false;\n\n  private history = {\n    past: [],\n    present: null,\n    future: []\n  };\n\n  /** Skip the update when redo/undo */\n  private skipUpdate = false;\n  private subscription;\n\n  /* Subjects for supporting observable hasPast$ and hasFuture$ */\n  private hasPastSubject: BehaviorSubject<boolean>;\n  private _hasPast$: Observable<boolean>;\n  private hasFutureSubject: BehaviorSubject<boolean>;\n  private _hasFuture$: Observable<boolean>;\n\n  constructor(protected query: Queries<State>, private params: StateHistoryParams = {}, private _entityId?: any) {\n    super(query, {\n      resetFn: () => this.clear()\n    });\n    params.maxAge = !!params.maxAge ? params.maxAge : 10;\n    params.comparator = params.comparator || (() => true);\n\n    this.activate();\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available past\n   *\n   */\n  get hasPast$(): Observable<boolean> {\n    return this._hasPast$;\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available future\n   *\n   */\n  get hasFuture$(): Observable<boolean> {\n    return this._hasFuture$;\n  }\n\n  get hasPast() {\n    return this.history.past.length > 0;\n  }\n\n  get hasFuture() {\n    return this.history.future.length > 0;\n  }\n\n  private get property() {\n    return this.params.watchProperty;\n  }\n\n  /* Updates the hasPast$ hasFuture$ observables*/\n  private updateHasHistory() {\n    this.hasFutureSubject.next(this.hasFuture);\n    this.hasPastSubject.next(this.hasPast);\n  }\n\n  activate() {\n    this.hasPastSubject = new BehaviorSubject(false);\n    this._hasPast$ = this.hasPastSubject.asObservable().pipe(distinctUntilChanged());\n    this.hasFutureSubject = new BehaviorSubject(false);\n    this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(distinctUntilChanged());\n\n    this.history.present = this.getSource(this._entityId, this.property);\n    this.subscription = (this as any)\n      .selectSource(this._entityId, this.property)\n      .pipe(pairwise())\n      .subscribe(([past, present]) => {\n        if (this.skip) {\n          this.skip = false;\n          return;\n        }\n        /**\n         *  comparator: (prev, current) => isEqual(prev, current) === false\n         */\n        const shouldUpdate = this.params.comparator(past, present);\n\n        if (!this.skipUpdate && shouldUpdate) {\n          if (this.history.past.length === this.params.maxAge) {\n            this.history.past = this.history.past.slice(1);\n          }\n          this.history.past = [...this.history.past, past];\n          this.history.present = present;\n          this.updateHasHistory();\n        }\n      });\n  }\n\n  undo() {\n    if (this.history.past.length > 0) {\n      const { past, present } = this.history;\n      const previous = past[past.length - 1];\n      this.history.past = past.slice(0, past.length - 1);\n      this.history.present = previous;\n      this.history.future = [present, ...this.history.future];\n      this.update();\n    }\n  }\n\n  redo() {\n    if (this.history.future.length > 0) {\n      const { past, present } = this.history;\n      const next = this.history.future[0];\n      const newFuture = this.history.future.slice(1);\n      this.history.past = [...past, present];\n      this.history.present = next;\n      this.history.future = newFuture;\n      this.update('Redo');\n    }\n  }\n\n  jumpToPast(index: number) {\n    if (index < 0 || index >= this.history.past.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9];\n     * const index = 2;\n     *\n     * newPast = past.slice(0, index) = [1, 2];\n     * newPresent = past[index] = 3;\n     * newFuture = [...past.slice(index + 1),present, ...future] = [4, 5, 6, 7, 8, 9];\n     *\n     */\n    const newPast = past.slice(0, index);\n    const newFuture = [...past.slice(index + 1), present, ...future];\n    const newPresent = past[index];\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update();\n  }\n\n  jumpToFuture(index: number) {\n    if (index < 0 || index >= this.history.future.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9, 10]\n     * const index = 1\n     *\n     * newPast = [...past, present, ...future.slice(0, index) = [1, 2, 3, 4, 5, 6, 7];\n     * newPresent = future[index] = 8;\n     * newFuture = futrue.slice(index+1) = [9, 10];\n     *\n     */\n\n    const newPast = [...past, present, ...future.slice(0, index)];\n    const newPresent = future[index];\n    const newFuture = future.slice(index + 1);\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update('Redo');\n  }\n\n  /**\n   *\n   * jump n steps in the past or forward\n   *\n   */\n  jump(n: number) {\n    if (n > 0) return this.jumpToFuture(n - 1);\n    if (n < 0) return this.jumpToPast(this.history.past.length + n);\n  }\n\n  /**\n   * Clear the history\n   *\n   * @param customUpdateFn Callback function for only clearing part of the history\n   *\n   * @example\n   *\n   * stateHistory.clear((history) => {\n   *  return {\n   *    past: history.past,\n   *    present: history.present,\n   *    future: []\n   *  };\n   * });\n   */\n  clear(customUpdateFn?: (history: History<State>) => History<State>) {\n    this.history = isFunction(customUpdateFn)\n      ? customUpdateFn(this.history)\n      : {\n          past: [],\n          present: null,\n          future: []\n        };\n    this.updateHasHistory();\n  }\n\n  destroy(clearHistory = false) {\n    if (clearHistory) {\n      this.clear();\n    }\n    this.subscription.unsubscribe();\n  }\n\n  ignoreNext() {\n    this.skip = true;\n  }\n\n  private update(action = 'Undo') {\n    this.skipUpdate = true;\n    logAction(`@StateHistory - ${action}`);\n    this.updateStore(this.history.present, this._entityId, this.property);\n    this.updateHasHistory();\n    this.skipUpdate = false;\n  }\n}\n","import { EntityState, OrArray, getIDType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { StateHistoryParams, StateHistoryPlugin } from './stateHistoryPlugin';\nimport { toBoolean } from '../../toBoolean';\nimport { skip } from 'rxjs/operators';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\n\nexport interface StateHistoryEntityParams<IDType> extends StateHistoryParams {\n  entityIds?: OrArray<IDType>;\n}\n\nexport class EntityStateHistoryPlugin<State extends EntityState = any, P extends StateHistoryPlugin<State> = StateHistoryPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  constructor(protected query: QueryEntity<State>, protected readonly params: StateHistoryEntityParams<getIDType<State>> = {}) {\n    super(query, params.entityIds);\n    params.maxAge = toBoolean(params.maxAge) ? params.maxAge : 10;\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => this.activate(ids));\n  }\n\n  redo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.redo());\n  }\n\n  undo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.undo());\n  }\n\n  hasPast(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasPast;\n    }\n  }\n\n  hasFuture(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasFuture;\n    }\n  }\n\n  jumpToFuture(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToFuture(index));\n  }\n\n  jumpToPast(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToPast(index));\n  }\n\n  clear(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.clear());\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>, clearHistory = false) {\n    this.forEachId(ids, e => e.destroy(clearHistory));\n  }\n\n  ignoreNext(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.ignoreNext());\n  }\n\n  protected instantiatePlugin(id: getIDType<State>) {\n    return new StateHistoryPlugin<State>(this.query, this.params, id) as P;\n  }\n}\n","import { AkitaPlugin, Queries } from '../plugin';\nimport { QueryEntity } from '../../queryEntity';\nimport { BehaviorSubject, combineLatest, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map, skip } from 'rxjs/operators';\nimport { isUndefined } from '../../isUndefined';\nimport { Query } from '../../query';\nimport { coerceArray } from '../../coerceArray';\nimport { isFunction } from '../../isFunction';\nimport { logAction } from '../../actions';\n\ntype Head<State = any> = State | Partial<State>;\n\nexport type DirtyCheckComparator<State> = (head: State, current: State) => boolean;\n\nexport type DirtyCheckParams<StoreState = any> = {\n  comparator?: DirtyCheckComparator<StoreState>;\n  watchProperty?: keyof StoreState | (keyof StoreState)[];\n};\n\nexport const dirtyCheckDefaultParams = {\n  comparator: (head, current) => JSON.stringify(head) !== JSON.stringify(current)\n};\n\nexport function getNestedPath(nestedObj, path: string) {\n  const pathAsArray: string[] = path.split('.');\n  return pathAsArray.reduce((obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined), nestedObj);\n}\n\nexport type DirtyCheckResetParams<StoreState = any> = {\n  updateFn?: StoreState | ((head: StoreState, current: StoreState) => any);\n};\n\nexport class DirtyCheckPlugin<State = any> extends AkitaPlugin<State> {\n  private head: Head<State>;\n  private dirty = new BehaviorSubject(false);\n  private subscription: Subscription;\n  private active = false;\n  private _reset = new Subject();\n\n  isDirty$: Observable<boolean> = this.dirty.asObservable().pipe(distinctUntilChanged());\n  reset$ = this._reset.asObservable();\n\n  constructor(protected query: Queries<State>, private params?: DirtyCheckParams<State>, private _entityId?: any) {\n    super(query);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    if (this.params.watchProperty) {\n      let watchProp = coerceArray(this.params.watchProperty) as any[];\n      if (query instanceof QueryEntity && watchProp.includes('entities') && !watchProp.includes('ids')) {\n        watchProp.push('ids');\n      }\n      this.params.watchProperty = watchProp;\n    }\n  }\n\n  reset(params: DirtyCheckResetParams = {}) {\n    let currentValue = this.head;\n    if (isFunction(params.updateFn)) {\n      if (this.isEntityBased(this._entityId)) {\n        currentValue = params.updateFn(this.head, (this.getQuery() as QueryEntity<State>).getEntity(this._entityId));\n      } else {\n        currentValue = params.updateFn(this.head, (this.getQuery() as Query<State>).getValue());\n      }\n    }\n    logAction(`@DirtyCheck - Revert`);\n    this.updateStore(currentValue, this._entityId);\n    this._reset.next();\n  }\n\n  setHead() {\n    if (!this.active) {\n      this.activate();\n      this.active = true;\n    } else {\n      this.head = this._getHead();\n    }\n    this.updateDirtiness(false);\n    return this;\n  }\n\n  isDirty(): boolean {\n    return !!this.dirty.value;\n  }\n\n  hasHead() {\n    return !!this.getHead();\n  }\n\n  destroy() {\n    this.head = null;\n    this.subscription && this.subscription.unsubscribe();\n    this._reset && this._reset.complete();\n  }\n\n  isPathDirty(path: string) {\n    const head = this.getHead();\n    const current = (this.getQuery() as Query<State>).getValue();\n    const currentPathValue = getNestedPath(current, path);\n    const headPathValue = getNestedPath(head, path);\n\n    return this.params.comparator(currentPathValue, headPathValue);\n  }\n\n  protected getHead() {\n    return this.head;\n  }\n\n  private activate() {\n    this.head = this._getHead();\n    /** if we are tracking specific properties select only the relevant ones */\n    const source = this.params.watchProperty\n      ? (this.params.watchProperty as (keyof State)[]).map(prop =>\n          this.query\n            .select(state => state[prop])\n            .pipe(\n              map(val => ({\n                val,\n                __akitaKey: prop\n              }))\n            )\n        )\n      : [this.selectSource(this._entityId)];\n    this.subscription = combineLatest(...source)\n      .pipe(skip(1))\n      .subscribe((currentState: any[]) => {\n        if (isUndefined(this.head)) return;\n        /** __akitaKey is used to determine if we are tracking a specific property or a store change */\n        const isChange = currentState.some(state => {\n          const head = state.__akitaKey ? this.head[state.__akitaKey as any] : this.head;\n          const compareTo = state.__akitaKey ? state.val : state;\n\n          return this.params.comparator(head, compareTo);\n        });\n\n        this.updateDirtiness(isChange);\n      });\n  }\n\n  private updateDirtiness(isDirty: boolean) {\n    this.dirty.next(isDirty);\n  }\n\n  private _getHead(): Head<State> {\n    let head: Head<State> = this.getSource(this._entityId);\n    if (this.params.watchProperty) {\n      head = this.getWatchedValues(head as State);\n    }\n    return head;\n  }\n\n  private getWatchedValues(source: State): Partial<State> {\n    return (this.params.watchProperty as (keyof State)[]).reduce(\n      (watched, prop) => {\n        watched[prop] = source[prop];\n        return watched;\n      },\n      {} as Partial<State>\n    );\n  }\n}\n","import { DirtyCheckComparator, dirtyCheckDefaultParams, DirtyCheckPlugin, DirtyCheckResetParams, getNestedPath } from './dirtyCheckPlugin';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\nimport { auditTime, map, skip } from 'rxjs/operators';\nimport { merge, Observable, Subject } from 'rxjs';\nimport { EntityState, OrArray, getIDType, getEntityType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { coerceArray } from '../../coerceArray';\n\nexport type DirtyCheckCollectionParams<State extends EntityState> = {\n  comparator?: DirtyCheckComparator<getEntityType<State>>;\n  entityIds?: OrArray<getIDType<State>>;\n};\n\nexport class EntityDirtyCheckPlugin<State extends EntityState = any, P extends DirtyCheckPlugin<State> = DirtyCheckPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  private _someDirty = new Subject();\n  someDirty$: Observable<boolean> = merge(this.query.select(state => state.entities), this._someDirty.asObservable()).pipe(\n    auditTime(0),\n    map(() => this.checkSomeDirty())\n  );\n\n  constructor(protected query: QueryEntity<State>, private readonly params: DirtyCheckCollectionParams<State> = {}) {\n    super(query, params.entityIds);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    // TODO lazy activate?\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => {\n        super.rebase(ids, { afterAdd: plugin => plugin.setHead() });\n      });\n  }\n\n  setHead(ids?: OrArray<getIDType<State>>) {\n    if (this.params.entityIds && ids) {\n      const toArray = coerceArray(ids) as getIDType<State>[];\n      const someAreWatched = coerceArray(this.params.entityIds).some(id => toArray.indexOf(id) > -1);\n      if (someAreWatched === false) {\n        return this;\n      }\n    }\n    this.forEachId(ids, e => e.setHead());\n    this._someDirty.next();\n    return this;\n  }\n\n  hasHead(id: getIDType<State>): boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return entity.hasHead();\n    }\n\n    return false;\n  }\n\n  reset(ids?: OrArray<getIDType<State>>, params: DirtyCheckResetParams = {}) {\n    this.forEachId(ids, e => e.reset(params));\n  }\n\n  isDirty(id: getIDType<State>): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: true): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: false): boolean;\n  isDirty(id: getIDType<State>, asObservable = true): Observable<boolean> | boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return asObservable ? entity.isDirty$ : entity.isDirty();\n    }\n\n    return false;\n  }\n\n  someDirty(): boolean {\n    return this.checkSomeDirty();\n  }\n\n  isPathDirty(id: getIDType<State>, path: string) {\n    if (this.entities.has(id)) {\n      const head = (this.getEntity(id) as any).getHead();\n      const current = this.query.getEntity(id);\n      const currentPathValue = getNestedPath(current, path);\n      const headPathValue = getNestedPath(head, path);\n\n      return this.params.comparator(currentPathValue, headPathValue);\n    }\n\n    return null;\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.destroy());\n    /** complete only when the plugin destroys */\n    if (!ids) {\n      this._someDirty.complete();\n    }\n  }\n\n  protected instantiatePlugin(id: getIDType<State>): P {\n    return new DirtyCheckPlugin(this.query, this.params, id) as P;\n  }\n\n  private checkSomeDirty(): boolean {\n    const entitiesIds = this.resolvedIds();\n    for (const id of entitiesIds) {\n      if (this.getEntity(id).isDirty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import { __stores__ } from './stores';\nimport { IDS } from './types';\nimport { AddEntitiesOptions } from './addEntities';\nimport { EntityStore } from './entityStore';\nimport { SetEntities } from './setEntities';\nimport { isNil } from './isNil';\nimport { AkitaError } from './errors';\n\nexport enum StoreActions {\n  Update,\n  AddEntities,\n  SetEntities,\n  UpdateEntities,\n  RemoveEntities,\n  UpsertEntities\n}\n\ninterface RunStoreActionSetEntities<Entity = any> {\n  payload: {\n    data: SetEntities<Entity>;\n  };\n}\n\ninterface RunStoreActionAddEntities<Entity = any> {\n  payload: {\n    data: Entity[] | Entity;\n    params?: AddEntitiesOptions;\n  };\n}\n\ninterface RunStoreActionUpdateEntities<Entity = any> {\n  payload: {\n    data: Partial<Entity>;\n    entityIds: IDS;\n  };\n}\n\ninterface RunStoreActionRemoveEntities<Entity = any> {\n  payload: {\n    entityIds: IDS;\n  };\n}\n\ninterface RunStoreActionUpsertEntities<Entity = any> {\n  payload: {\n    data: Partial<Entity>[] | Partial<Entity>;\n    entityIds?: IDS;\n  };\n}\n\ninterface RunStoreActionUpdate<State = any> {\n  payload: {\n    data: Partial<State>;\n  };\n}\n\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.Update, {\n *   payload: {\n *    data: { filter: 'New filter' }\n *   }\n * });\n */\nexport function runStoreAction<State = any>(storeName: string, action: StoreActions.Update, params: RunStoreActionUpdate<State>);\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.RemoveEntities, {\n *   payload: {\n *    entityIds: 2\n *   }\n * });\n */\nexport function runStoreAction<Entity = any>(storeName: string, action: StoreActions.RemoveEntities, params: RunStoreActionRemoveEntities<Entity>);\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.UpdateEntities, {\n *   payload: {\n *    data: { title: 'New title' },\n *    entityIds: 2\n *   }\n * });\n */\nexport function runStoreAction<Entity = any>(storeName: string, action: StoreActions.UpdateEntities, params: RunStoreActionUpdateEntities<Entity>);\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.SetEntities, {\n *   payload: {\n *    data: [{ id: 1 }, { id: 2 }]\n *   }\n * });\n */\nexport function runStoreAction<Entity = any>(storeName: string, action: StoreActions.SetEntities, params: RunStoreActionSetEntities<Entity>);\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.AddEntities, {\n *   payload: {\n *    data: { id: 1 }\n *   }\n * });\n */\nexport function runStoreAction<Entity = any>(storeName: string, action: StoreActions.AddEntities, params: RunStoreActionAddEntities<Entity>);\n/**\n * @example\n *\n * runStoreAction('books', StoreActions.UpsertEntities, {\n *   payload: {\n *    data: { title: 'New Title' },\n *    entityIds: [1, 2]\n *   }\n * });\n * runStoreAction('books', StoreActions.UpsertEntities, {\n *   payload: {\n *    data: [{ id: 2, title: 'New Title' }, { id: 3, title: 'Another title'}],\n *   }\n * });\n */\nexport function runStoreAction<Entity = any>(storeName: string, action: StoreActions.UpsertEntities, params: RunStoreActionUpsertEntities<Entity>);\nexport function runStoreAction<EntityOrState = any>(\n  storeName: string,\n  action: StoreActions,\n  params:\n    | RunStoreActionSetEntities<EntityOrState>\n    | RunStoreActionAddEntities<EntityOrState>\n    | RunStoreActionRemoveEntities<EntityOrState>\n    | RunStoreActionUpdateEntities<EntityOrState>\n    | RunStoreActionUpsertEntities<EntityOrState>\n) {\n  const store = __stores__[storeName];\n\n  if (isNil(store)) {\n    throw new AkitaError(`${storeName} doesn't exist`);\n  }\n\n  switch (action) {\n    case StoreActions.SetEntities: {\n      const { payload } = params as RunStoreActionSetEntities;\n      (store as EntityStore).set(payload.data);\n      return;\n    }\n    case StoreActions.AddEntities: {\n      const { payload } = params as RunStoreActionAddEntities;\n      (store as EntityStore).add(payload.data, payload.params);\n      return;\n    }\n\n    case StoreActions.UpdateEntities: {\n      const { payload } = params as RunStoreActionUpdateEntities;\n      (store as EntityStore).update(payload.entityIds, payload.data);\n      return;\n    }\n\n    case StoreActions.RemoveEntities: {\n      const { payload } = params as RunStoreActionRemoveEntities;\n      (store as EntityStore).remove(payload.entityIds);\n      return;\n    }\n\n    case StoreActions.UpsertEntities: {\n      const { payload } = params as RunStoreActionUpsertEntities;\n      if (payload.entityIds) {\n        (store as EntityStore).upsert(payload.entityIds, payload.data);\n      } else if (Array.isArray(payload.data)) {\n        (store as EntityStore).upsertMany(payload.data);\n      } else {\n        (store as EntityStore).upsertMany([payload.data]);\n      }\n      return;\n    }\n\n    case StoreActions.Update: {\n      const { payload } = params as RunStoreActionUpdate;\n      (store as EntityStore).update(payload.data);\n      return;\n    }\n  }\n}\n","import { ArrayProperties, IDS, ItemPredicate } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { coerceArray } from './coerceArray';\nimport { isFunction } from './isFunction';\nimport { isObject } from './isObject';\nimport { isArray } from './isArray';\n\n/**\n * Update item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpdate(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpdate<Root extends any[], Entity = any>(keyOrRoot: Root, predicateOrIds: IDS | ItemPredicate<Root[0]>, obj: Partial<Root[0]>, idKey?: string): Root[0][];\n/**\n * @deprecated\n */\nexport function arrayUpdate<Root, Entity = any>(keyOrRoot: ArrayProperties<Root>, predicateOrIds: IDS | ItemPredicate<Entity>, obj: Partial<Entity>, idKey?: string): (state: Root) => Root;\nexport function arrayUpdate<Root, Entity = any>(keyOrRoot: ArrayProperties<Root> | Root, predicateOrIds: IDS | ItemPredicate<Entity>, obj: Partial<Entity>, idKey = DEFAULT_ID_KEY) {\n  let condition: ItemPredicate<Entity>;\n\n  if (isFunction(predicateOrIds)) {\n    condition = predicateOrIds;\n  } else {\n    const ids = coerceArray(predicateOrIds);\n    condition = item => ids.includes(isObject(item) ? item[idKey] : item) === true;\n  }\n\n  const updateFn = state =>\n    state.map(entity => {\n      if (condition(entity) === true) {\n        return isObject(entity)\n          ? {\n              ...entity,\n              ...obj\n            }\n          : obj;\n      }\n\n      return entity;\n    });\n\n  if (isArray(keyOrRoot)) {\n    return updateFn(keyOrRoot);\n  }\n\n  return root => {\n    return {\n      [keyOrRoot as string]: updateFn(root[keyOrRoot])\n    };\n  };\n}\n","import { ArrayProperties, OrArray } from './types';\nimport { coerceArray } from './coerceArray';\nimport { AddEntitiesOptions } from './addEntities';\nimport { isArray } from './isArray';\n\n/**\n * Add item to a collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   comments: arrayAdd(state.comments, { id: 2 })\n * }))\n *\n */\nexport function arrayAdd<Root extends any[], Entity = any>(keyOrRoot: Root, newEntity: OrArray<Root[0]>, options?: AddEntitiesOptions): Root[0][];\n/**\n * @deprecated\n */\nexport function arrayAdd<Root, Entity = any>(keyOrRoot: ArrayProperties<Root>, newEntity: OrArray<Entity>, options?: AddEntitiesOptions): (state: Root) => Root;\nexport function arrayAdd<Root, Entity = any>(keyOrRoot: ArrayProperties<Root> | Root, newEntity: OrArray<Entity>, options: AddEntitiesOptions = {}) {\n  const newEntities = coerceArray(newEntity);\n\n  const addFn = state => (options.prepend ? [...newEntities, ...(state || [])] : [...(state || []), ...newEntities]);\n\n  if (isArray(keyOrRoot)) {\n    return addFn(keyOrRoot);\n  }\n\n  return state => {\n    return {\n      [keyOrRoot as ArrayProperties<Root>]: addFn(state[keyOrRoot])\n    };\n  };\n}\n","import { EntityState, getEntityType, getIDType } from './types';\nimport { Observable } from 'rxjs';\n\nexport abstract class EntityService<S extends EntityState> {\n  abstract get<T>(id?: getIDType<S>, config?: any): Observable<T>;\n  abstract add<T>(entity: getEntityType<EntityState>, config?: any): Observable<T>;\n  abstract update<T>(id: getIDType<S>, entity: Partial<getEntityType<S>>, config: any): Observable<T>;\n  abstract delete<T>(id: getIDType<S>, config: any): Observable<T>;\n}\n","/**\n * Generate random guid\n *\n * @example\n *\n * {\n *   id: guid()\n * }\n *\n */\nexport function guid() {\n  return 'xxxxxx4xyx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","import { DEFAULT_ID_KEY } from './defaultIDKey';\n\n// @internal\nexport function toEntitiesIds<E>(entities: E[], idKey = DEFAULT_ID_KEY) {\n  const ids = [];\n  for (const entity of entities) {\n    ids.push(entity[idKey]);\n  }\n  return ids;\n}\n","import { __stores__ } from './stores';\nimport { applyTransaction } from './transaction';\n\nexport interface ResetStoresParams {\n  exclude: string[];\n}\n\n/**\n * Reset stores back to their initial state\n *\n * @example\n *\n * resetStores()\n * resetStores({\n *   exclude: ['auth']\n * })\n */\nexport function resetStores(options?: Partial<ResetStoresParams>) {\n  const defaults: ResetStoresParams = {\n    exclude: []\n  };\n\n  options = Object.assign({}, defaults, options);\n  const stores = Object.keys(__stores__);\n\n  applyTransaction(() => {\n    for (const store of stores) {\n      const s = __stores__[store];\n      if (!options.exclude) {\n        s.reset();\n      } else {\n        if (options.exclude.indexOf(s.storeName) === -1) {\n          s.reset();\n        }\n      }\n    }\n  });\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isNumber(value: any): value is number {\n  return !isArray(value) && value - parseFloat(value) + 1 >= 0;\n}\n","import { ID } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { arrayAdd } from './arrayAdd';\nimport { arrayUpdate } from './arrayUpdate';\nimport { isObject } from './isObject';\n\n/**\n * Upsert item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpsert(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpsert<Root extends any[]>(arr: Root, id: ID, obj: Partial<Root[0]>, idKey = DEFAULT_ID_KEY): Root[0][] {\n  const entityIsObject = isObject(obj);\n  const entityExists = arr.some(entity => (entityIsObject ? entity[idKey] === id : entity === id));\n  if (entityExists) {\n    return arrayUpdate(arr, id, obj, idKey);\n  } else {\n    return arrayAdd(arr, entityIsObject ? { ...obj, [idKey]: id } : obj);\n  }\n}\n","import { ArrayProperties, IDS, ItemPredicate } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { coerceArray } from './coerceArray';\nimport { isObject } from './isObject';\nimport { isFunction } from './isFunction';\nimport { not } from './not';\n\n/**\n * Remove item from collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   names: arrayRemove(state.names, ['one', 'second'])\n * }))\n */\nexport function arrayRemove<Root extends any[], Entity = Root[0]>(keyOrRoot: Root, identifier: IDS | ItemPredicate<Root[0]>, idKey?: string): Root[0][];\n/**\n * @deprecated\n */\nexport function arrayRemove<Root, Entity = any>(keyOrRoot: ArrayProperties<Root>, identifier: IDS | ItemPredicate<Entity>, idKey?: string): (state: Root) => Root;\nexport function arrayRemove<Root, Entity = any>(keyOrRoot: ArrayProperties<Root> | Root, identifier: IDS | ItemPredicate<Entity>, idKey = DEFAULT_ID_KEY) {\n  let identifiers;\n  let filterFn;\n\n  if (isFunction(identifier)) {\n    filterFn = not(identifier);\n  } else {\n    identifiers = coerceArray(identifier as IDS);\n    filterFn = current => {\n      return identifiers.includes(isObject(current) ? current[idKey] : current) === false;\n    };\n  }\n\n  if (Array.isArray(keyOrRoot)) {\n    return keyOrRoot.filter(filterFn);\n  }\n\n  return state => {\n    return {\n      [keyOrRoot as string]: state[keyOrRoot].filter(filterFn)\n    };\n  };\n}\n","// @internal\nexport function not(pred: Function): Function {\n  return function(...args) {\n    return !pred(...args);\n  };\n}\n","import { Store } from './store';\nimport { Query } from './query';\nimport { StoreConfigOptions } from './storeConfig';\nimport { EntityStore } from './entityStore';\nimport { QueryEntity } from './queryEntity';\nimport { QueryConfigOptions } from './queryConfig';\nimport { EntityState } from './types';\n\nexport function createStore<State>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new Store<State>(initialState, options);\n}\n\nexport function createQuery<State>(store: Store<State>) {\n  return new Query<State>(store);\n}\n\nexport function createEntityStore<State extends EntityState>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new EntityStore<State>(initialState, options);\n}\n\nexport function createEntityQuery<State extends EntityState>(store: EntityStore<State>, options: QueryConfigOptions = {}) {\n  return new QueryEntity<State>(store, options);\n}\n","import { EMPTY, Observable, of } from 'rxjs';\nimport { Store } from './store';\n\n/**\n * \n * Helper function for checking if we have data in cache\n * \n * export class ProductsService {\n *   constructor(private productsStore: ProductsStore) {}\n\n *   get(): Observable<void> {\n *     const request = this.http.get().pipe(\n *       tap(this.productsStore.set(response))\n *     );\n *\n *     return cacheable(this.productsStore, request);\n *   }\n * }\n */\nexport function cacheable<T>(store: Store, request$: Observable<T>, options: { emitNext: boolean } = { emitNext: false }) {\n  if (store._cache().value) {\n    return options.emitNext ? of(undefined) : EMPTY;\n  }\n  return request$;\n}\n","import { combineLatest, Observable, ObservableInput, ObservedValueOf } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\n\ntype ReturnTypes<T extends Observable<any>[]> = { [P in keyof T]: T[P] extends Observable<infer R> ? R : never };\ntype Observables = [Observable<any>] | Observable<any>[];\n\nexport function combineQueries<R extends Observables>(observables: R): Observable<ReturnTypes<R>> {\n  return combineLatest(observables).pipe(auditTime(0)) as any;\n}\n","import { Store } from './store';\nimport { Observable, defer } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\n\nexport function setLoading(store: Store) {\n  return function<T>(source: Observable<T>) {\n    return defer(() => {\n      store.setLoading(true);\n      return source.pipe(finalize(() => store.setLoading(false)));\n    });\n  };\n}\n"]}