/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isFunction } from './isFunction';
import { compareValues } from './sort';
import { coerceArray } from './coerceArray';
// @internal
/**
 * @template E, S
 * @param {?} state
 * @param {?} options
 * @return {?}
 */
export function entitiesToArray(state, options) {
    /** @type {?} */
    let arr = [];
    const { ids, entities } = state;
    const { filterBy, limitTo, sortBy, sortByOrder } = options;
    for (let i = 0; i < ids.length; i++) {
        /** @type {?} */
        const entity = entities[ids[i]];
        if (!filterBy) {
            arr.push(entity);
            continue;
        }
        /** @type {?} */
        const toArray = coerceArray(filterBy);
        /** @type {?} */
        const allPass = toArray.every((/**
         * @param {?} fn
         * @return {?}
         */
        fn => fn(entity, i)));
        if (allPass) {
            arr.push(entity);
        }
    }
    if (sortBy) {
        /** @type {?} */
        let _sortBy = isFunction(sortBy) ? sortBy : compareValues(sortBy, sortByOrder);
        arr = arr.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => _sortBy(a, b, state)));
    }
    /** @type {?} */
    const length = Math.min(limitTo || arr.length, arr.length);
    return length === arr.length ? arr : arr.slice(0, length);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXRpZXNUb0FycmF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRhdG9yYW1hL2FraXRhLyIsInNvdXJjZXMiOlsic3JjL2VudGl0aWVzVG9BcnJheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMxQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7O0FBRzVDLE1BQU0sVUFBVSxlQUFlLENBQTJCLEtBQVEsRUFBRSxPQUF5Qjs7UUFDdkYsR0FBRyxHQUFHLEVBQUU7VUFDTixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLO1VBQ3pCLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsT0FBTztJQUUxRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7Y0FDN0IsTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakIsU0FBUztTQUNWOztjQUVLLE9BQU8sR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDOztjQUMvQixPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQUs7Ozs7UUFBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUM7UUFDbEQsSUFBSSxPQUFPLEVBQUU7WUFDWCxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2xCO0tBQ0Y7SUFFRCxJQUFJLE1BQU0sRUFBRTs7WUFDTixPQUFPLEdBQVEsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDO1FBQ25GLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSTs7Ozs7UUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFDLENBQUM7S0FDaEQ7O1VBRUssTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQztJQUUxRCxPQUFPLE1BQU0sS0FBSyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzVELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdHlTdGF0ZSwgU2VsZWN0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBjb21wYXJlVmFsdWVzIH0gZnJvbSAnLi9zb3J0JztcbmltcG9ydCB7IGNvZXJjZUFycmF5IH0gZnJvbSAnLi9jb2VyY2VBcnJheSc7XG5cbi8vIEBpbnRlcm5hbFxuZXhwb3J0IGZ1bmN0aW9uIGVudGl0aWVzVG9BcnJheTxFLCBTIGV4dGVuZHMgRW50aXR5U3RhdGU+KHN0YXRlOiBTLCBvcHRpb25zOiBTZWxlY3RPcHRpb25zPEU+KTogRVtdIHtcbiAgbGV0IGFyciA9IFtdO1xuICBjb25zdCB7IGlkcywgZW50aXRpZXMgfSA9IHN0YXRlO1xuICBjb25zdCB7IGZpbHRlckJ5LCBsaW1pdFRvLCBzb3J0QnksIHNvcnRCeU9yZGVyIH0gPSBvcHRpb25zO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXNbaWRzW2ldXTtcbiAgICBpZiAoIWZpbHRlckJ5KSB7XG4gICAgICBhcnIucHVzaChlbnRpdHkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdG9BcnJheSA9IGNvZXJjZUFycmF5KGZpbHRlckJ5KTtcbiAgICBjb25zdCBhbGxQYXNzID0gdG9BcnJheS5ldmVyeShmbiA9PiBmbihlbnRpdHksIGkpKTtcbiAgICBpZiAoYWxsUGFzcykge1xuICAgICAgYXJyLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc29ydEJ5KSB7XG4gICAgbGV0IF9zb3J0Qnk6IGFueSA9IGlzRnVuY3Rpb24oc29ydEJ5KSA/IHNvcnRCeSA6IGNvbXBhcmVWYWx1ZXMoc29ydEJ5LCBzb3J0QnlPcmRlcik7XG4gICAgYXJyID0gYXJyLnNvcnQoKGEsIGIpID0+IF9zb3J0QnkoYSwgYiwgc3RhdGUpKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGxpbWl0VG8gfHwgYXJyLmxlbmd0aCwgYXJyLmxlbmd0aCk7XG5cbiAgcmV0dXJuIGxlbmd0aCA9PT0gYXJyLmxlbmd0aCA/IGFyciA6IGFyci5zbGljZSgwLCBsZW5ndGgpO1xufVxuIl19