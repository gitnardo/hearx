/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isFunction } from './isFunction';
import { hasEntity } from './hasEntity';
import { isPlainObject } from './isPlainObject';
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
export function updateEntities({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn }) {
    /** @type {?} */
    const updatedEntities = {};
    /** @type {?} */
    let isUpdatingIdKey = false;
    /** @type {?} */
    let idToUpdate;
    for (const id of ids) {
        // if the entity doesn't exist don't do anything
        if (hasEntity(state.entities, id) === false) {
            continue;
        }
        /** @type {?} */
        const oldEntity = state.entities[id];
        /** @type {?} */
        let newState;
        if (isFunction(newStateOrFn)) {
            newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);
        }
        else {
            newState = newStateOrFn;
        }
        /** @type {?} */
        const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];
        /** @type {?} */
        let newEntity;
        idToUpdate = id;
        if (isIdChanged) {
            isUpdatingIdKey = true;
            idToUpdate = newState[idKey];
        }
        /** @type {?} */
        const merged = Object.assign({}, oldEntity, newState);
        if (isPlainObject(oldEntity)) {
            newEntity = merged;
        }
        else {
            /**
             * In case that new state is class of it's own, there's
             * a possibility that it will be different than the old
             * class.
             * For example, Old state is an instance of animal class
             * and new state is instance of person class.
             * To avoid run over new person class with the old animal
             * class we check if the new state is a class of it's own.
             * If so, use it. Otherwise, use the old state class
             */
            if (isPlainObject(newState)) {
                newEntity = new ((/** @type {?} */ (oldEntity))).constructor(merged);
            }
            else {
                newEntity = new ((/** @type {?} */ (newState))).constructor(merged);
            }
        }
        updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);
    }
    /** @type {?} */
    let updatedIds = state.ids;
    /** @type {?} */
    let stateEntities = state.entities;
    if (isUpdatingIdKey) {
        const [id] = ids;
        const _a = state.entities, _b = id, deletedEntity = _a[_b], rest = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
        stateEntities = rest;
        updatedIds = state.ids.map((/**
         * @param {?} current
         * @return {?}
         */
        current => (current === id ? idToUpdate : current)));
    }
    return Object.assign({}, state, { entities: Object.assign({}, stateEntities, updatedEntities), ids: updatedIds });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlRW50aXRpZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvdXBkYXRlRW50aXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7O0FBWWhELE1BQU0sVUFBVSxjQUFjLENBQThCLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQThCOztVQUNoSixlQUFlLEdBQUcsRUFBRTs7UUFFdEIsZUFBZSxHQUFHLEtBQUs7O1FBQ3ZCLFVBQWM7SUFFbEIsS0FBSyxNQUFNLEVBQUUsSUFBSSxHQUFHLEVBQUU7UUFDcEIsZ0RBQWdEO1FBQ2hELElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQzNDLFNBQVM7U0FDVjs7Y0FFSyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7O1lBQ2hDLFFBQVE7UUFDWixJQUFJLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM1QixRQUFRLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbkc7YUFBTTtZQUNMLFFBQVEsR0FBRyxZQUFZLENBQUM7U0FDekI7O2NBRUssV0FBVyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUM7O1lBQ3RGLFNBQVk7UUFDaEIsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVoQixJQUFJLFdBQVcsRUFBRTtZQUNmLGVBQWUsR0FBRyxJQUFJLENBQUM7WUFDdkIsVUFBVSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM5Qjs7Y0FFSyxNQUFNLHFCQUNQLFNBQVMsRUFDVCxRQUFRLENBQ1o7UUFFRCxJQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM1QixTQUFTLEdBQUcsTUFBTSxDQUFDO1NBQ3BCO2FBQU07WUFDTDs7Ozs7Ozs7O2VBU0c7WUFDSCxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDM0IsU0FBUyxHQUFHLElBQUksQ0FBQyxtQkFBQSxTQUFTLEVBQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN4RDtpQkFBTTtnQkFDTCxTQUFTLEdBQUcsSUFBSSxDQUFDLG1CQUFBLFFBQVEsRUFBTyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZEO1NBQ0Y7UUFFRCxlQUFlLENBQUMsVUFBVSxDQUFDLEdBQUcsZUFBZSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNyRTs7UUFFRyxVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQUc7O1FBQ3RCLGFBQWEsR0FBRyxLQUFLLENBQUMsUUFBUTtJQUVsQyxJQUFJLGVBQWUsRUFBRTtjQUNiLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRztjQUNWLG1CQUFpRCxFQUEvQyxPQUFJLEVBQUosc0JBQW1CLEVBQUUsa0VBQU87UUFDcEMsYUFBYSxHQUFHLElBQUksQ0FBQztRQUNyQixVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7O1FBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUMsQ0FBQztLQUNoRjtJQUVELHlCQUNLLEtBQUssSUFDUixRQUFRLG9CQUNILGFBQWEsRUFDYixlQUFlLEdBRXBCLEdBQUcsRUFBRSxVQUFVLElBQ2Y7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW50aXR5U3RhdGUsIElELCBQcmVVcGRhdGVFbnRpdHksIFVwZGF0ZVN0YXRlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgaGFzRW50aXR5IH0gZnJvbSAnLi9oYXNFbnRpdHknO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdCc7XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUVudGl0aWVzUGFyYW1zPFN0YXRlLCBFbnRpdHk+ID0ge1xuICBzdGF0ZTogU3RhdGU7XG4gIGlkczogYW55W107XG4gIGlkS2V5OiBzdHJpbmc7XG4gIG5ld1N0YXRlT3JGbjogVXBkYXRlU3RhdGVDYWxsYmFjazxFbnRpdHk+IHwgUGFydGlhbDxFbnRpdHk+IHwgUGFydGlhbDxTdGF0ZT47XG4gIHByZVVwZGF0ZUVudGl0eTogUHJlVXBkYXRlRW50aXR5PEVudGl0eT47XG4gIHByb2R1Y2VyRm47XG59O1xuXG4vLyBAaW50ZXJuYWxcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVFbnRpdGllczxTIGV4dGVuZHMgRW50aXR5U3RhdGU8RT4sIEU+KHsgc3RhdGUsIGlkcywgaWRLZXksIG5ld1N0YXRlT3JGbiwgcHJlVXBkYXRlRW50aXR5LCBwcm9kdWNlckZuIH06IFVwZGF0ZUVudGl0aWVzUGFyYW1zPFMsIEU+KSB7XG4gIGNvbnN0IHVwZGF0ZWRFbnRpdGllcyA9IHt9O1xuXG4gIGxldCBpc1VwZGF0aW5nSWRLZXkgPSBmYWxzZTtcbiAgbGV0IGlkVG9VcGRhdGU6IElEO1xuXG4gIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgLy8gaWYgdGhlIGVudGl0eSBkb2Vzbid0IGV4aXN0IGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGhhc0VudGl0eShzdGF0ZS5lbnRpdGllcywgaWQpID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkRW50aXR5ID0gc3RhdGUuZW50aXRpZXNbaWRdO1xuICAgIGxldCBuZXdTdGF0ZTtcbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZU9yRm4pKSB7XG4gICAgICBuZXdTdGF0ZSA9IGlzRnVuY3Rpb24ocHJvZHVjZXJGbikgPyBwcm9kdWNlckZuKG9sZEVudGl0eSwgbmV3U3RhdGVPckZuKSA6IG5ld1N0YXRlT3JGbihvbGRFbnRpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlT3JGbjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0lkQ2hhbmdlZCA9IG5ld1N0YXRlLmhhc093blByb3BlcnR5KGlkS2V5KSAmJiBuZXdTdGF0ZVtpZEtleV0gIT09IG9sZEVudGl0eVtpZEtleV07XG4gICAgbGV0IG5ld0VudGl0eTogRTtcbiAgICBpZFRvVXBkYXRlID0gaWQ7XG5cbiAgICBpZiAoaXNJZENoYW5nZWQpIHtcbiAgICAgIGlzVXBkYXRpbmdJZEtleSA9IHRydWU7XG4gICAgICBpZFRvVXBkYXRlID0gbmV3U3RhdGVbaWRLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAgIC4uLm9sZEVudGl0eSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0KG9sZEVudGl0eSkpIHtcbiAgICAgIG5ld0VudGl0eSA9IG1lcmdlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBJbiBjYXNlIHRoYXQgbmV3IHN0YXRlIGlzIGNsYXNzIG9mIGl0J3Mgb3duLCB0aGVyZSdzXG4gICAgICAgKiBhIHBvc3NpYmlsaXR5IHRoYXQgaXQgd2lsbCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkXG4gICAgICAgKiBjbGFzcy5cbiAgICAgICAqIEZvciBleGFtcGxlLCBPbGQgc3RhdGUgaXMgYW4gaW5zdGFuY2Ugb2YgYW5pbWFsIGNsYXNzXG4gICAgICAgKiBhbmQgbmV3IHN0YXRlIGlzIGluc3RhbmNlIG9mIHBlcnNvbiBjbGFzcy5cbiAgICAgICAqIFRvIGF2b2lkIHJ1biBvdmVyIG5ldyBwZXJzb24gY2xhc3Mgd2l0aCB0aGUgb2xkIGFuaW1hbFxuICAgICAgICogY2xhc3Mgd2UgY2hlY2sgaWYgdGhlIG5ldyBzdGF0ZSBpcyBhIGNsYXNzIG9mIGl0J3Mgb3duLlxuICAgICAgICogSWYgc28sIHVzZSBpdC4gT3RoZXJ3aXNlLCB1c2UgdGhlIG9sZCBzdGF0ZSBjbGFzc1xuICAgICAgICovXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChuZXdTdGF0ZSkpIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbmV3IChvbGRFbnRpdHkgYXMgYW55KS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbmV3IChuZXdTdGF0ZSBhcyBhbnkpLmNvbnN0cnVjdG9yKG1lcmdlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlZEVudGl0aWVzW2lkVG9VcGRhdGVdID0gcHJlVXBkYXRlRW50aXR5KG9sZEVudGl0eSwgbmV3RW50aXR5KTtcbiAgfVxuXG4gIGxldCB1cGRhdGVkSWRzID0gc3RhdGUuaWRzO1xuICBsZXQgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuXG4gIGlmIChpc1VwZGF0aW5nSWRLZXkpIHtcbiAgICBjb25zdCBbaWRdID0gaWRzO1xuICAgIGNvbnN0IHsgW2lkXTogZGVsZXRlZEVudGl0eSwgLi4ucmVzdCB9ID0gc3RhdGUuZW50aXRpZXM7XG4gICAgc3RhdGVFbnRpdGllcyA9IHJlc3Q7XG4gICAgdXBkYXRlZElkcyA9IHN0YXRlLmlkcy5tYXAoY3VycmVudCA9PiAoY3VycmVudCA9PT0gaWQgPyBpZFRvVXBkYXRlIDogY3VycmVudCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlbnRpdGllczoge1xuICAgICAgLi4uc3RhdGVFbnRpdGllcyxcbiAgICAgIC4uLnVwZGF0ZWRFbnRpdGllc1xuICAgIH0sXG4gICAgaWRzOiB1cGRhdGVkSWRzXG4gIH07XG59XG4iXX0=