/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isNil } from './isNil';
import { coerceArray } from './coerceArray';
// @internal
/**
 * @template S, E
 * @param {?} state
 * @param {?} options
 * @return {?}
 */
export function entitiesToMap(state, options) {
    /** @type {?} */
    const map = {};
    const { filterBy, limitTo } = options;
    const { ids, entities } = state;
    if (!filterBy && !limitTo) {
        return entities;
    }
    /** @type {?} */
    const hasLimit = isNil(limitTo) === false;
    if (filterBy && hasLimit) {
        /** @type {?} */
        let count = 0;
        for (let i = 0, length = ids.length; i < length; i++) {
            if (count === limitTo)
                break;
            /** @type {?} */
            const id = ids[i];
            /** @type {?} */
            const entity = entities[id];
            /** @type {?} */
            const allPass = coerceArray(filterBy).every((/**
             * @param {?} fn
             * @return {?}
             */
            fn => fn(entity, i)));
            if (allPass) {
                map[id] = entity;
                count++;
            }
        }
    }
    else {
        /** @type {?} */
        const finalLength = Math.min(limitTo || ids.length, ids.length);
        for (let i = 0; i < finalLength; i++) {
            /** @type {?} */
            const id = ids[i];
            /** @type {?} */
            const entity = entities[id];
            if (!filterBy) {
                map[id] = entity;
                continue;
            }
            /** @type {?} */
            const allPass = coerceArray(filterBy).every((/**
             * @param {?} fn
             * @return {?}
             */
            fn => fn(entity, i)));
            if (allPass) {
                map[id] = entity;
            }
        }
    }
    return map;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXRpZXNUb01hcC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BkYXRvcmFtYS9ha2l0YS8iLCJzb3VyY2VzIjpbInNyYy9lbnRpdGllc1RvTWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ2hDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7O0FBRzVDLE1BQU0sVUFBVSxhQUFhLENBQThCLEtBQVEsRUFBRSxPQUFPOztVQUNwRSxHQUFHLEdBQUcsRUFBRTtVQUNSLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxHQUFHLE9BQU87VUFDL0IsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsS0FBSztJQUUvQixJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ3pCLE9BQU8sUUFBUSxDQUFDO0tBQ2pCOztVQUNLLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssS0FBSztJQUV6QyxJQUFJLFFBQVEsSUFBSSxRQUFRLEVBQUU7O1lBQ3BCLEtBQUssR0FBRyxDQUFDO1FBQ2IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwRCxJQUFJLEtBQUssS0FBSyxPQUFPO2dCQUFFLE1BQU07O2tCQUN2QixFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQzs7a0JBQ1gsTUFBTSxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUM7O2tCQUNyQixPQUFPLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUs7Ozs7WUFBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUM7WUFDaEUsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztnQkFDakIsS0FBSyxFQUFFLENBQUM7YUFDVDtTQUNGO0tBQ0Y7U0FBTTs7Y0FDQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDO1FBRS9ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7O2tCQUM5QixFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQzs7a0JBQ1gsTUFBTSxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFFM0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDYixHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDO2dCQUNqQixTQUFTO2FBQ1Y7O2tCQUVLLE9BQU8sR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSzs7OztZQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBQztZQUNoRSxJQUFJLE9BQU8sRUFBRTtnQkFDWCxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQ2xCO1NBQ0Y7S0FDRjtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVudGl0eVN0YXRlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpc05pbCB9IGZyb20gJy4vaXNOaWwnO1xuaW1wb3J0IHsgY29lcmNlQXJyYXkgfSBmcm9tICcuL2NvZXJjZUFycmF5JztcblxuLy8gQGludGVybmFsXG5leHBvcnQgZnVuY3Rpb24gZW50aXRpZXNUb01hcDxTIGV4dGVuZHMgRW50aXR5U3RhdGU8RT4sIEU+KHN0YXRlOiBTLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCB7IGZpbHRlckJ5LCBsaW1pdFRvIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IGlkcywgZW50aXRpZXMgfSA9IHN0YXRlO1xuXG4gIGlmICghZmlsdGVyQnkgJiYgIWxpbWl0VG8pIHtcbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH1cbiAgY29uc3QgaGFzTGltaXQgPSBpc05pbChsaW1pdFRvKSA9PT0gZmFsc2U7XG5cbiAgaWYgKGZpbHRlckJ5ICYmIGhhc0xpbWl0KSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gaWRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY291bnQgPT09IGxpbWl0VG8pIGJyZWFrO1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllc1tpZF07XG4gICAgICBjb25zdCBhbGxQYXNzID0gY29lcmNlQXJyYXkoZmlsdGVyQnkpLmV2ZXJ5KGZuID0+IGZuKGVudGl0eSwgaSkpO1xuICAgICAgaWYgKGFsbFBhc3MpIHtcbiAgICAgICAgbWFwW2lkXSA9IGVudGl0eTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmluYWxMZW5ndGggPSBNYXRoLm1pbihsaW1pdFRvIHx8IGlkcy5sZW5ndGgsIGlkcy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5hbExlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzW2lkXTtcblxuICAgICAgaWYgKCFmaWx0ZXJCeSkge1xuICAgICAgICBtYXBbaWRdID0gZW50aXR5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsUGFzcyA9IGNvZXJjZUFycmF5KGZpbHRlckJ5KS5ldmVyeShmbiA9PiBmbihlbnRpdHksIGkpKTtcbiAgICAgIGlmIChhbGxQYXNzKSB7XG4gICAgICAgIG1hcFtpZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn1cbiJdfQ==