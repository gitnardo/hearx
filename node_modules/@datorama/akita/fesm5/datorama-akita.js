import { __assign, __values, __spread, __read, __rest, __extends, __decorate, __metadata } from 'tslib';
import { ReplaySubject, Subject, BehaviorSubject, of, from, isObservable, combineLatest, merge, EMPTY, defer } from 'rxjs';
import { tap, distinctUntilChanged, map, filter, switchMap, skip, take, delay, debounceTime, pairwise, auditTime, finalize } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function isArray(value) {
    return Array.isArray(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template T
 * @param {?} arr
 * @return {?}
 */
function isEmpty(arr) {
    if (isArray(arr)) {
        return arr.length === 0;
    }
    return false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E
 * @param {?} entities
 * @param {?} idKey
 * @param {?} preAddEntity
 * @return {?}
 */
function toEntitiesObject(entities, idKey, preAddEntity) {
    var e_1, _a;
    /** @type {?} */
    var acc = {
        entities: {},
        ids: []
    };
    try {
        for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
            var entity = entities_1_1.value;
            // evaluate the middleware first to support dynamic ids
            /** @type {?} */
            var current = preAddEntity(entity);
            acc.entities[current[idKey]] = current;
            acc.ids.push(current[idKey]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return acc;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E
 * @param {?} entities
 * @param {?} id
 * @return {?}
 */
function hasEntity(entities, id) {
    return entities.hasOwnProperty(id);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E
 * @param {?} state
 * @return {?}
 */
function hasActiveState(state) {
    return state.hasOwnProperty('active');
}
// @internal
/**
 * @param {?} active
 * @return {?}
 */
function isMultiActiveState(active) {
    return isArray(active);
}
// @internal
/**
 * @template E
 * @param {?} __0
 * @return {?}
 */
function resolveActiveEntity(_a) {
    var active = _a.active, ids = _a.ids, entities = _a.entities;
    if (isMultiActiveState(active)) {
        return getExitingActives(active, ids);
    }
    if (hasEntity(entities, active) === false) {
        return null;
    }
    return active;
}
// @internal
/**
 * @param {?} currentActivesIds
 * @param {?} newIds
 * @return {?}
 */
function getExitingActives(currentActivesIds, newIds) {
    /** @type {?} */
    var filtered = currentActivesIds.filter((/**
     * @param {?} id
     * @return {?}
     */
    function (id) { return newIds.indexOf(id) > -1; }));
    /** Return the same reference if nothing has changed */
    if (filtered.length === currentActivesIds.length) {
        return currentActivesIds;
    }
    return filtered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template Entity
 * @param {?} state
 * @return {?}
 */
function isEntityState(state) {
    return state.entities && state.ids;
}
// @internal
/**
 * @template E
 * @param {?} entities
 * @param {?} preAddEntity
 * @return {?}
 */
function applyMiddleware(entities, preAddEntity) {
    var e_1, _a;
    /** @type {?} */
    var mapped = {};
    try {
        for (var _b = __values(Object.keys(entities)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            mapped[id] = preAddEntity(entities[id]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return mapped;
}
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
function setEntities(_a) {
    var state = _a.state, entities = _a.entities, idKey = _a.idKey, preAddEntity = _a.preAddEntity, isNativePreAdd = _a.isNativePreAdd;
    /** @type {?} */
    var newEntities;
    /** @type {?} */
    var newIds;
    if (isArray(entities)) {
        /** @type {?} */
        var resolve = toEntitiesObject(entities, idKey, preAddEntity);
        newEntities = resolve.entities;
        newIds = resolve.ids;
    }
    else if (isEntityState(entities)) {
        newEntities = isNativePreAdd ? entities.entities : applyMiddleware(entities.entities, preAddEntity);
        newIds = entities.ids;
    }
    else {
        // it's an object
        newEntities = isNativePreAdd ? entities : applyMiddleware(entities, preAddEntity);
        newIds = Object.keys(newEntities).map((/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return (isNaN((/** @type {?} */ (id))) ? id : Number(id)); }));
    }
    /** @type {?} */
    var newState = __assign({}, state, { entities: newEntities, ids: newIds, loading: false });
    if (hasActiveState(state)) {
        newState.active = resolveActiveEntity((/** @type {?} */ (newState)));
    }
    return newState;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var currentAction = {
    type: null,
    entityIds: null,
    skip: false
};
/** @type {?} */
var customActionActive = false;
/**
 * @return {?}
 */
function resetCustomAction() {
    customActionActive = false;
}
// public API for custom actions. Custom action always wins
/**
 * @param {?} type
 * @param {?=} entityIds
 * @return {?}
 */
function logAction(type, entityIds) {
    setAction(type, entityIds);
    customActionActive = true;
}
/**
 * @param {?} type
 * @param {?=} entityIds
 * @return {?}
 */
function setAction(type, entityIds) {
    if (customActionActive === false) {
        currentAction.type = type;
        currentAction.entityIds = entityIds;
    }
}
/**
 * @param {?=} skip
 * @return {?}
 */
function setSkipAction(skip$$1) {
    if (skip$$1 === void 0) { skip$$1 = true; }
    currentAction.skip = skip$$1;
}
/**
 * @param {?} action
 * @param {?=} entityIds
 * @return {?}
 */
function action(action, entityIds) {
    return (/**
     * @param {?} target
     * @param {?} propertyKey
     * @param {?} descriptor
     * @return {?}
     */
    function (target, propertyKey, descriptor) {
        /** @type {?} */
        var originalMethod = descriptor.value;
        descriptor.value = (/**
         * @param {...?} args
         * @return {?}
         */
        function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            logAction(action, entityIds);
            return originalMethod.apply(this, args);
        });
        return descriptor;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CONFIG = {
    resettable: false,
    ttl: null,
    producerFn: undefined
};
/**
 * @param {?} config
 * @return {?}
 */
function akitaConfig(config) {
    CONFIG = __assign({}, CONFIG, config);
}
// @internal
/**
 * @return {?}
 */
function getAkitaConfig() {
    return CONFIG;
}
/**
 * @return {?}
 */
function getGlobalProducerFn() {
    return CONFIG.producerFn;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} o
 * @return {?}
 */
function deepFreeze(o) {
    Object.freeze(o);
    /** @type {?} */
    var oIsFunction = typeof o === 'function';
    /** @type {?} */
    var hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach((/**
     * @param {?} prop
     * @return {?}
     */
    function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    }));
    return o;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/** @type {?} */
var $$deleteStore = new Subject();
// @internal
/** @type {?} */
var $$addStore = new ReplaySubject(50, 5000);
// @internal
/** @type {?} */
var $$updateStore = new Subject();
// @internal
/**
 * @param {?} storeName
 * @return {?}
 */
function dispatchDeleted(storeName) {
    $$deleteStore.next(storeName);
}
// @internal
/**
 * @param {?} storeName
 * @return {?}
 */
function dispatchAdded(storeName) {
    $$addStore.next(storeName);
}
// @internal
/**
 * @param {?} storeName
 * @return {?}
 */
function dispatchUpdate(storeName) {
    $$updateStore.next(storeName);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var __DEV__ = true;
/**
 * @return {?}
 */
function enableAkitaProdMode() {
    __DEV__ = false;
}
// @internal
/**
 * @return {?}
 */
function isDev() {
    return __DEV__;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
var 
// @internal
AkitaError = /** @class */ (function (_super) {
    __extends(AkitaError, _super);
    function AkitaError(message) {
        return _super.call(this, message) || this;
    }
    return AkitaError;
}(Error));
// @internal
/**
 * @param {?} name
 * @param {?} className
 * @return {?}
 */
function assertStoreHasName(name, className) {
    if (!name) {
        console.error("@StoreConfig({ name }) is missing in " + className);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} v
 * @return {?}
 */
function isNil(v) {
    return v === null || v === undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} val
 * @return {?}
 */
function isDefined(val) {
    return isNil(val) === false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
    return typeof value === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function toBoolean(value) {
    return value != null && "" + value !== 'false';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isPlainObject(value) {
    return toBoolean(value) && value.constructor.name === 'Object';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var isBrowser = typeof window !== 'undefined';
/** @type {?} */
var isNotBrowser = !isBrowser;
/** @type {?} */
var isNativeScript = typeof global !== 'undefined' && ((/** @type {?} */ (global))).__runtimeVersion !== 'undefined';
/** @type {?} */
var hasLocalStorage = (/**
 * @return {?}
 */
function () {
    try {
        return typeof localStorage !== 'undefined';
    }
    catch (_a) {
        return false;
    }
});
/** @type {?} */
var hasSessionStorage = (/**
 * @return {?}
 */
function () {
    try {
        return typeof sessionStorage !== 'undefined';
    }
    catch (_a) {
        return false;
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var configKey = 'akitaConfig';
/**
 * @param {?} metadata
 * @return {?}
 */
function StoreConfig(metadata) {
    return (/**
     * @param {?} constructor
     * @return {?}
     */
    function (constructor) {
        constructor[configKey] = { idKey: 'id' };
        for (var i = 0, keys = Object.keys(metadata); i < keys.length; i++) {
            /** @type {?} */
            var key = keys[i];
            /* name is preserved read only key */
            if (key === 'name') {
                constructor[configKey]['storeName'] = metadata[key];
            }
            else {
                constructor[configKey][key] = metadata[key];
            }
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/** @type {?} */
var __stores__ = {};
// @internal
/** @type {?} */
var __queries__ = {};
if (isBrowser && isDev()) {
    ((/** @type {?} */ (window))).$$stores = __stores__;
    ((/** @type {?} */ (window))).$$queries = __queries__;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/** @type {?} */
var transactionFinished = new Subject();
// @internal
/** @type {?} */
var transactionInProcess = new BehaviorSubject(false);
// @internal
/** @type {?} */
var transactionManager = {
    activeTransactions: 0,
    batchTransaction: null
};
// @internal
/**
 * @return {?}
 */
function startBatch() {
    if (!isTransactionInProcess()) {
        transactionManager.batchTransaction = new Subject();
    }
    transactionManager.activeTransactions++;
    transactionInProcess.next(true);
}
// @internal
/**
 * @return {?}
 */
function endBatch() {
    if (--transactionManager.activeTransactions === 0) {
        transactionManager.batchTransaction.next(true);
        transactionManager.batchTransaction.complete();
        transactionInProcess.next(false);
        transactionFinished.next(true);
    }
}
// @internal
/**
 * @return {?}
 */
function isTransactionInProcess() {
    return transactionManager.activeTransactions > 0;
}
// @internal
/**
 * @return {?}
 */
function commit() {
    return transactionManager.batchTransaction ? transactionManager.batchTransaction.asObservable() : of(true);
}
/**
 *  A logical transaction.
 *  Use this transaction to optimize the dispatch of all the stores.
 *  The following code will update the store, BUT  emits only once
 *
 * \@example
 *  applyTransaction(() => {
 *    this.todosStore.add(new Todo(1, title));
 *    this.todosStore.add(new Todo(2, title));
 *  });
 *
 * @template T
 * @param {?} action
 * @param {?=} thisArg
 * @return {?}
 */
function applyTransaction(action$$1, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    startBatch();
    try {
        return action$$1.apply(thisArg);
    }
    finally {
        logAction('@Transaction');
        endBatch();
    }
}
/**
 *  A logical transaction.
 *  Use this transaction to optimize the dispatch of all the stores.
 *
 *  The following code will update the store, BUT  emits only once.
 *
 * \@example
 * \@transaction
 *  addTodos() {
 *    this.todosStore.add(new Todo(1, title));
 *    this.todosStore.add(new Todo(2, title));
 *  }
 *
 *
 * @return {?}
 */
function transaction() {
    return (/**
     * @param {?} target
     * @param {?} propertyKey
     * @param {?} descriptor
     * @return {?}
     */
    function (target, propertyKey, descriptor) {
        /** @type {?} */
        var originalMethod = descriptor.value;
        descriptor.value = (/**
         * @param {...?} args
         * @return {?}
         */
        function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return applyTransaction((/**
             * @return {?}
             */
            function () {
                return originalMethod.apply(_this, args);
            }), this);
        });
        return descriptor;
    });
}
/**
 *
 * RxJS custom operator that wraps the callback inside transaction
 *
 * \@example
 *
 * return http.get().pipe(
 *    withTransaction(response > {
 *      store.setActive(1);
 *      store.update();
 *      store.updateEntity(1, {});
 *    })
 * )
 *
 * @template T
 * @param {?} next
 * @return {?}
 */
function withTransaction(next) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return source.pipe(tap((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return applyTransaction((/**
         * @return {?}
         */
        function () { return next(value); })); })));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * Store for managing any type of data
 *
 * \@example
 *
 * export interface SessionState {
 *   token: string;
 *   userDetails: UserDetails
 * }
 *
 * export function createInitialState(): SessionState {
 *  return {
 *    token: '',
 *    userDetails: null
 *  };
 * }
 *
 * \@StoreConfig({ name: 'session' })
 * export class SessionStore extends Store<SessionState> {
 *   constructor() {
 *    super(createInitialState());
 *   }
 * }
 * @template S
 */
var  /**
 *
 * Store for managing any type of data
 *
 * \@example
 *
 * export interface SessionState {
 *   token: string;
 *   userDetails: UserDetails
 * }
 *
 * export function createInitialState(): SessionState {
 *  return {
 *    token: '',
 *    userDetails: null
 *  };
 * }
 *
 * \@StoreConfig({ name: 'session' })
 * export class SessionStore extends Store<SessionState> {
 *   constructor() {
 *    super(createInitialState());
 *   }
 * }
 * @template S
 */
Store = /** @class */ (function () {
    function Store(initialState, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.inTransaction = false;
        this.cache = {
            active: new BehaviorSubject(false),
            ttl: null
        };
        this.onInit((/** @type {?} */ (initialState)));
    }
    /**
     *  Set the loading state
     *
     *  @example
     *
     *  store.setLoading(true)
     *
     */
    /**
     *  Set the loading state
     *
     * \@example
     *
     *  store.setLoading(true)
     *
     * @param {?=} loading
     * @return {?}
     */
    Store.prototype.setLoading = /**
     *  Set the loading state
     *
     * \@example
     *
     *  store.setLoading(true)
     *
     * @param {?=} loading
     * @return {?}
     */
    function (loading) {
        if (loading === void 0) { loading = false; }
        if (loading !== ((/** @type {?} */ (this._value()))).loading) {
            isDev() && setAction('Set Loading');
            this._setState((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return ((/** @type {?} */ (__assign({}, state, { loading: loading })))); }));
        }
    };
    /**
     *
     * Set whether the data is cached
     *
     * @example
     *
     * store.setHasCache(true)
     * store.setHasCache(false)
     * store.setHasCache(true, { restartTTL: true })
     *
     */
    /**
     *
     * Set whether the data is cached
     *
     * \@example
     *
     * store.setHasCache(true)
     * store.setHasCache(false)
     * store.setHasCache(true, { restartTTL: true })
     *
     * @param {?} hasCache
     * @param {?=} options
     * @return {?}
     */
    Store.prototype.setHasCache = /**
     *
     * Set whether the data is cached
     *
     * \@example
     *
     * store.setHasCache(true)
     * store.setHasCache(false)
     * store.setHasCache(true, { restartTTL: true })
     *
     * @param {?} hasCache
     * @param {?=} options
     * @return {?}
     */
    function (hasCache, options) {
        var _this = this;
        if (options === void 0) { options = { restartTTL: false }; }
        if (hasCache !== this.cache.active.value) {
            this.cache.active.next(hasCache);
        }
        if (options.restartTTL) {
            /** @type {?} */
            var ttlConfig = this.getCacheTTL();
            if (ttlConfig) {
                if (this.cache.ttl !== null) {
                    clearTimeout(this.cache.ttl);
                }
                this.cache.ttl = (/** @type {?} */ (setTimeout((/**
                 * @return {?}
                 */
                function () { return _this.setHasCache(false); }), ttlConfig)));
            }
        }
    };
    /**
     *
     * Sometimes we need to access the store value from a store
     *
     * @example middleware
     *
     */
    /**
     *
     * Sometimes we need to access the store value from a store
     *
     * \@example middleware
     *
     * @return {?}
     */
    Store.prototype.getValue = /**
     *
     * Sometimes we need to access the store value from a store
     *
     * \@example middleware
     *
     * @return {?}
     */
    function () {
        return this.storeValue;
    };
    /**
     *  Set the error state
     *
     *  @example
     *
     *  store.setError({text: 'unable to load data' })
     *
     */
    /**
     *  Set the error state
     *
     * \@example
     *
     *  store.setError({text: 'unable to load data' })
     *
     * @template T
     * @param {?} error
     * @return {?}
     */
    Store.prototype.setError = /**
     *  Set the error state
     *
     * \@example
     *
     *  store.setError({text: 'unable to load data' })
     *
     * @template T
     * @param {?} error
     * @return {?}
     */
    function (error) {
        if (error !== ((/** @type {?} */ (this._value()))).error) {
            isDev() && setAction('Set Error');
            this._setState((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return ((/** @type {?} */ (__assign({}, state, { error: error })))); }));
        }
    };
    // @internal
    // @internal
    /**
     * @template R
     * @param {?} project
     * @return {?}
     */
    Store.prototype._select = 
    // @internal
    /**
     * @template R
     * @param {?} project
     * @return {?}
     */
    function (project) {
        return this.store.asObservable().pipe(map(project), distinctUntilChanged());
    };
    // @internal
    // @internal
    /**
     * @return {?}
     */
    Store.prototype._value = 
    // @internal
    /**
     * @return {?}
     */
    function () {
        return this.storeValue;
    };
    // @internal
    // @internal
    /**
     * @return {?}
     */
    Store.prototype._cache = 
    // @internal
    /**
     * @return {?}
     */
    function () {
        return this.cache.active;
    };
    Object.defineProperty(Store.prototype, "config", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return this.constructor[configKey] || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "storeName", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.config))).storeName || ((/** @type {?} */ (this.options))).storeName || this.options.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "deepFreeze", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return this.config.deepFreezeFn || this.options.deepFreezeFn || deepFreeze;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "cacheConfig", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return this.config.cache || this.options.cache;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "_producerFn", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.producerFn || this.options.producerFn || getGlobalProducerFn();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "resettable", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return isDefined(this.config.resettable) ? this.config.resettable : this.options.resettable;
        },
        enumerable: true,
        configurable: true
    });
    // @internal
    // @internal
    /**
     * @param {?} newState
     * @param {?=} _dispatchAction
     * @return {?}
     */
    Store.prototype._setState = 
    // @internal
    /**
     * @param {?} newState
     * @param {?=} _dispatchAction
     * @return {?}
     */
    function (newState, _dispatchAction) {
        if (_dispatchAction === void 0) { _dispatchAction = true; }
        if (isFunction(newState)) {
            /** @type {?} */
            var _newState = newState(this._value());
            this.storeValue = __DEV__ ? this.deepFreeze(_newState) : _newState;
        }
        else {
            this.storeValue = newState;
        }
        if (!this.store) {
            this.store = new BehaviorSubject(this.storeValue);
            return;
        }
        if (isTransactionInProcess()) {
            this.handleTransaction();
            return;
        }
        this.dispatch(this.storeValue, _dispatchAction);
    };
    /**
     *
     * Reset the current store back to the initial value
     *
     * @example
     *
     * store.reset()
     *
     */
    /**
     *
     * Reset the current store back to the initial value
     *
     * \@example
     *
     * store.reset()
     *
     * @return {?}
     */
    Store.prototype.reset = /**
     *
     * Reset the current store back to the initial value
     *
     * \@example
     *
     * store.reset()
     *
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isResettable()) {
            isDev() && setAction('Reset');
            this._setState((/**
             * @return {?}
             */
            function () { return Object.assign({}, _this._initialState); }));
            this.setHasCache(false);
        }
        else {
            isDev() && console.warn("You need to enable the reset functionality");
        }
    };
    /**
     * @param {?} stateOrCallback
     * @return {?}
     */
    Store.prototype.update = /**
     * @param {?} stateOrCallback
     * @return {?}
     */
    function (stateOrCallback) {
        isDev() && setAction('Update');
        /** @type {?} */
        var newState;
        /** @type {?} */
        var currentState = this._value();
        if (isFunction(stateOrCallback)) {
            newState = isFunction(this._producerFn) ? this._producerFn(currentState, stateOrCallback) : stateOrCallback(currentState);
        }
        else {
            newState = stateOrCallback;
        }
        /** @type {?} */
        var withHook = this.akitaPreUpdate(currentState, (/** @type {?} */ (__assign({}, currentState, newState))));
        /** @type {?} */
        var resolved = isPlainObject(currentState) ? withHook : new ((/** @type {?} */ (currentState))).constructor(withHook);
        this._setState(resolved);
    };
    /**
     * @param {?} newOptions
     * @return {?}
     */
    Store.prototype.updateStoreConfig = /**
     * @param {?} newOptions
     * @return {?}
     */
    function (newOptions) {
        this.options = __assign({}, this.options, newOptions);
    };
    // @internal
    // @internal
    /**
     * @param {?} _
     * @param {?} nextState
     * @return {?}
     */
    Store.prototype.akitaPreUpdate = 
    // @internal
    /**
     * @param {?} _
     * @param {?} nextState
     * @return {?}
     */
    function (_, nextState) {
        return nextState;
    };
    /**
     * @return {?}
     */
    Store.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     *
     * Destroy the store
     *
     * @example
     *
     * store.destroy()
     *
     */
    /**
     *
     * Destroy the store
     *
     * \@example
     *
     * store.destroy()
     *
     * @return {?}
     */
    Store.prototype.destroy = /**
     *
     * Destroy the store
     *
     * \@example
     *
     * store.destroy()
     *
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hmrEnabled = isBrowser ? ((/** @type {?} */ (window))).hmrEnabled : false;
        if (!hmrEnabled && this === __stores__[this.storeName]) {
            delete __stores__[this.storeName];
            dispatchDeleted(this.storeName);
            this.setHasCache(false);
            this.cache.active.complete();
        }
    };
    /**
     * @private
     * @param {?} initialState
     * @return {?}
     */
    Store.prototype.onInit = /**
     * @private
     * @param {?} initialState
     * @return {?}
     */
    function (initialState) {
        __stores__[this.storeName] = this;
        this._setState((/**
         * @return {?}
         */
        function () { return initialState; }));
        dispatchAdded(this.storeName);
        if (this.isResettable()) {
            this._initialState = initialState;
        }
        isDev() && assertStoreHasName(this.storeName, this.constructor.name);
    };
    /**
     * @private
     * @param {?} state
     * @param {?=} _dispatchAction
     * @return {?}
     */
    Store.prototype.dispatch = /**
     * @private
     * @param {?} state
     * @param {?=} _dispatchAction
     * @return {?}
     */
    function (state, _dispatchAction) {
        if (_dispatchAction === void 0) { _dispatchAction = true; }
        this.store.next(state);
        if (_dispatchAction) {
            dispatchUpdate(this.storeName);
            resetCustomAction();
        }
    };
    /**
     * @private
     * @return {?}
     */
    Store.prototype.watchTransaction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        commit().subscribe((/**
         * @return {?}
         */
        function () {
            _this.inTransaction = false;
            _this.dispatch(_this._value());
        }));
    };
    /**
     * @private
     * @return {?}
     */
    Store.prototype.isResettable = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.resettable === false) {
            return false;
        }
        return this.resettable || getAkitaConfig().resettable;
    };
    /**
     * @private
     * @return {?}
     */
    Store.prototype.handleTransaction = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.inTransaction) {
            this.watchTransaction();
            this.inTransaction = true;
        }
    };
    /**
     * @private
     * @return {?}
     */
    Store.prototype.getCacheTTL = /**
     * @private
     * @return {?}
     */
    function () {
        return (this.cacheConfig && this.cacheConfig.ttl) || getAkitaConfig().ttl;
    };
    return Store;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    /** @type {?} */
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} idOrOptions
 * @param {?} ids
 * @param {?} currentActive
 * @return {?}
 */
function getActiveEntities(idOrOptions, ids, currentActive) {
    /** @type {?} */
    var result;
    if (isArray(idOrOptions)) {
        result = idOrOptions;
    }
    else {
        if (isObject(idOrOptions)) {
            if (isNil(currentActive))
                return;
            ((/** @type {?} */ (idOrOptions))) = Object.assign({ wrap: true }, idOrOptions);
            /** @type {?} */
            var currentIdIndex = ids.indexOf((/** @type {?} */ (currentActive)));
            if (((/** @type {?} */ (idOrOptions))).prev) {
                /** @type {?} */
                var isFirst = currentIdIndex === 0;
                if (isFirst && !((/** @type {?} */ (idOrOptions))).wrap)
                    return;
                result = isFirst ? ids[ids.length - 1] : ((/** @type {?} */ (ids[currentIdIndex - 1])));
            }
            else if (((/** @type {?} */ (idOrOptions))).next) {
                /** @type {?} */
                var isLast = ids.length === currentIdIndex + 1;
                if (isLast && !((/** @type {?} */ (idOrOptions))).wrap)
                    return;
                result = isLast ? ids[0] : ((/** @type {?} */ (ids[currentIdIndex + 1])));
            }
        }
        else {
            if (idOrOptions === currentActive)
                return;
            result = (/** @type {?} */ (idOrOptions));
        }
    }
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
function addEntities(_a) {
    var state = _a.state, entities = _a.entities, idKey = _a.idKey, _b = _a.options, options = _b === void 0 ? {} : _b, preAddEntity = _a.preAddEntity;
    var e_1, _c;
    /** @type {?} */
    var newEntities = {};
    /** @type {?} */
    var newIds = [];
    /** @type {?} */
    var hasNewEntities = false;
    try {
        for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
            var entity = entities_1_1.value;
            if (hasEntity(state.entities, entity[idKey]) === false) {
                // evaluate the middleware first to support dynamic ids
                /** @type {?} */
                var current = preAddEntity(entity);
                /** @type {?} */
                var entityId = current[idKey];
                newEntities[entityId] = current;
                if (options.prepend)
                    newIds.unshift(entityId);
                else
                    newIds.push(entityId);
                hasNewEntities = true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entities_1_1 && !entities_1_1.done && (_c = entities_1.return)) _c.call(entities_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return hasNewEntities
        ? {
            newState: __assign({}, state, { entities: __assign({}, state.entities, newEntities), ids: options.prepend ? __spread(newIds, state.ids) : __spread(state.ids, newIds) }),
            newIds: newIds
        }
        : null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function coerceArray(value) {
    if (isNil(value)) {
        return [];
    }
    return Array.isArray(value) ? value : [value];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
function removeEntities(_a) {
    var state = _a.state, ids = _a.ids;
    var e_1, _b;
    if (isNil(ids))
        return removeAllEntities(state);
    /** @type {?} */
    var entities = state.entities;
    /** @type {?} */
    var newEntities = {};
    try {
        for (var _c = __values(state.ids), _d = _c.next(); !_d.done; _d = _c.next()) {
            var id = _d.value;
            if (ids.includes(id) === false) {
                newEntities[id] = entities[id];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /** @type {?} */
    var newState = __assign({}, state, { entities: newEntities, ids: state.ids.filter((/**
         * @param {?} current
         * @return {?}
         */
        function (current) { return ids.includes(current) === false; })) });
    if (hasActiveState(state)) {
        newState.active = resolveActiveEntity(newState);
    }
    return newState;
}
// @internal
/**
 * @template S
 * @param {?} state
 * @return {?}
 */
function removeAllEntities(state) {
    return __assign({}, state, { entities: {}, ids: [], active: isMultiActiveState(state.active) ? [] : null });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/** @type {?} */
var getInitialEntitiesState = (/**
 * @return {?}
 */
function () {
    return ((/** @type {?} */ ({
        entities: {},
        ids: [],
        loading: true,
        error: null
    })));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
function updateEntities(_a) {
    var state = _a.state, ids = _a.ids, idKey = _a.idKey, newStateOrFn = _a.newStateOrFn, preUpdateEntity = _a.preUpdateEntity, producerFn = _a.producerFn;
    var e_1, _b;
    /** @type {?} */
    var updatedEntities = {};
    /** @type {?} */
    var isUpdatingIdKey = false;
    /** @type {?} */
    var idToUpdate;
    try {
        for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            // if the entity doesn't exist don't do anything
            if (hasEntity(state.entities, id) === false) {
                continue;
            }
            /** @type {?} */
            var oldEntity = state.entities[id];
            /** @type {?} */
            var newState = void 0;
            if (isFunction(newStateOrFn)) {
                newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);
            }
            else {
                newState = newStateOrFn;
            }
            /** @type {?} */
            var isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];
            /** @type {?} */
            var newEntity = void 0;
            idToUpdate = id;
            if (isIdChanged) {
                isUpdatingIdKey = true;
                idToUpdate = newState[idKey];
            }
            /** @type {?} */
            var merged = __assign({}, oldEntity, newState);
            if (isPlainObject(oldEntity)) {
                newEntity = merged;
            }
            else {
                /**
                 * In case that new state is class of it's own, there's
                 * a possibility that it will be different than the old
                 * class.
                 * For example, Old state is an instance of animal class
                 * and new state is instance of person class.
                 * To avoid run over new person class with the old animal
                 * class we check if the new state is a class of it's own.
                 * If so, use it. Otherwise, use the old state class
                 */
                if (isPlainObject(newState)) {
                    newEntity = new ((/** @type {?} */ (oldEntity))).constructor(merged);
                }
                else {
                    newEntity = new ((/** @type {?} */ (newState))).constructor(merged);
                }
            }
            updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ids_1_1 && !ids_1_1.done && (_b = ids_1.return)) _b.call(ids_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /** @type {?} */
    var updatedIds = state.ids;
    /** @type {?} */
    var stateEntities = state.entities;
    if (isUpdatingIdKey) {
        var _c = __read(ids, 1), id_1 = _c[0];
        var _d = state.entities, _e = id_1, deletedEntity = _d[_e], rest = __rest(_d, [typeof _e === "symbol" ? _e : _e + ""]);
        stateEntities = rest;
        updatedIds = state.ids.map((/**
         * @param {?} current
         * @return {?}
         */
        function (current) { return (current === id_1 ? idToUpdate : current); }));
    }
    return __assign({}, state, { entities: __assign({}, stateEntities, updatedEntities), ids: updatedIds });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isUndefined(value) {
    return value === undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var EntityActions = {
    Set: 0,
    Add: 1,
    Update: 2,
    Remove: 3,
};
EntityActions[EntityActions.Set] = 'Set';
EntityActions[EntityActions.Add] = 'Add';
EntityActions[EntityActions.Update] = 'Update';
EntityActions[EntityActions.Remove] = 'Remove';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_ID_KEY = 'id';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * Store for managing a collection of entities
 *
 * \@example
 *
 * export interface WidgetsState extends EntityState<Widget> { }
 *
 * \@StoreConfig({ name: 'widgets' })
 *  export class WidgetsStore extends EntityStore<WidgetsState> {
 *   constructor() {
 *     super();
 *   }
 * }
 *
 *
 * @template S, EntityType, IDType
 */
var EntityStore = /** @class */ (function (_super) {
    __extends(EntityStore, _super);
    function EntityStore(initialState, options) {
        if (initialState === void 0) { initialState = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, __assign({}, getInitialEntitiesState(), initialState), options) || this;
        _this.options = options;
        _this.entityActions = new Subject();
        return _this;
    }
    Object.defineProperty(EntityStore.prototype, "selectEntityAction$", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return this.entityActions.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityStore.prototype, "idKey", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.config))).idKey || this.options.idKey || DEFAULT_ID_KEY;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Replace current collection with provided collection
     *
     * @example
     *
     * this.store.set([Entity, Entity])
     * this.store.set({ids: [], entities: {}})
     * this.store.set({ 1: {}, 2: {}})
     *
     */
    /**
     *
     * Replace current collection with provided collection
     *
     * \@example
     *
     * this.store.set([Entity, Entity])
     * this.store.set({ids: [], entities: {}})
     * this.store.set({ 1: {}, 2: {}})
     *
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    EntityStore.prototype.set = /**
     *
     * Replace current collection with provided collection
     *
     * \@example
     *
     * this.store.set([Entity, Entity])
     * this.store.set({ids: [], entities: {}})
     * this.store.set({ 1: {}, 2: {}})
     *
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    function (entities, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (isNil(entities))
            return;
        isDev() && setAction('Set Entity');
        /** @type {?} */
        var isNativePreAdd = this.akitaPreAddEntity === EntityStore.prototype.akitaPreAddEntity;
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            /** @type {?} */
            var newState = setEntities({
                state: state,
                entities: entities,
                idKey: _this.idKey,
                preAddEntity: _this.akitaPreAddEntity,
                isNativePreAdd: isNativePreAdd
            });
            if (isUndefined(options.activeId) === false) {
                ((/** @type {?} */ (newState))).active = options.activeId;
            }
            return newState;
        }));
        this.setHasCache(true, { restartTTL: true });
        if (this.hasInitialUIState()) {
            this.handleUICreation();
        }
        this.entityActions.next({ type: EntityActions.Set, ids: this.ids });
    };
    /**
     * Add entities
     *
     * @example
     *
     * this.store.add([Entity, Entity])
     * this.store.add(Entity)
     * this.store.add(Entity, { prepend: true })
     *
     * this.store.add(Entity, { loading: false })
     */
    /**
     * Add entities
     *
     * \@example
     *
     * this.store.add([Entity, Entity])
     * this.store.add(Entity)
     * this.store.add(Entity, { prepend: true })
     *
     * this.store.add(Entity, { loading: false })
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    EntityStore.prototype.add = /**
     * Add entities
     *
     * \@example
     *
     * this.store.add([Entity, Entity])
     * this.store.add(Entity)
     * this.store.add(Entity, { prepend: true })
     *
     * this.store.add(Entity, { loading: false })
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    function (entities, options) {
        if (options === void 0) { options = { loading: false }; }
        /** @type {?} */
        var collection = coerceArray(entities);
        if (isEmpty(collection))
            return;
        /** @type {?} */
        var data = addEntities({
            state: this._value(),
            preAddEntity: this.akitaPreAddEntity,
            entities: collection,
            idKey: this.idKey,
            options: options
        });
        if (data) {
            isDev() && setAction('Add Entity');
            data.newState.loading = options.loading;
            this._setState((/**
             * @return {?}
             */
            function () { return data.newState; }));
            if (this.hasInitialUIState()) {
                this.handleUICreation(true);
            }
            this.entityActions.next({ type: EntityActions.Add, ids: data.newIds });
        }
    };
    /**
     * @param {?} idsOrFnOrState
     * @param {?=} newStateOrFn
     * @return {?}
     */
    EntityStore.prototype.update = /**
     * @param {?} idsOrFnOrState
     * @param {?=} newStateOrFn
     * @return {?}
     */
    function (idsOrFnOrState, newStateOrFn) {
        var _this = this;
        if (isUndefined(newStateOrFn)) {
            _super.prototype.update.call(this, (/** @type {?} */ (idsOrFnOrState)));
            return;
        }
        /** @type {?} */
        var ids = [];
        if (isFunction(idsOrFnOrState)) {
            // We need to filter according the predicate function
            ids = this.ids.filter((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return ((/** @type {?} */ (idsOrFnOrState)))(_this.entities[id]); }));
        }
        else {
            // If it's nil we want all of them
            ids = isNil(idsOrFnOrState) ? this.ids : coerceArray((/** @type {?} */ (idsOrFnOrState)));
        }
        if (isEmpty(ids))
            return;
        isDev() && setAction('Update Entity', ids);
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            return updateEntities({
                idKey: _this.idKey,
                ids: ids,
                preUpdateEntity: _this.akitaPreUpdateEntity,
                state: state,
                newStateOrFn: newStateOrFn,
                producerFn: _this._producerFn
            });
        }));
        this.entityActions.next({ type: EntityActions.Update, ids: ids });
    };
    /**
     *
     * Create or update
     *
     * @example
     *
     * store.upsert(1, { active: true })
     * store.upsert([2, 3], { active: true })
     * store.upsert([2, 3], entity => ({ isOpen: !entity.isOpen}))
     *
     */
    /**
     *
     * Create or update
     *
     * \@example
     *
     * store.upsert(1, { active: true })
     * store.upsert([2, 3], { active: true })
     * store.upsert([2, 3], entity => ({ isOpen: !entity.isOpen}))
     *
     * @param {?} ids
     * @param {?} newState
     * @param {?=} options
     * @return {?}
     */
    EntityStore.prototype.upsert = /**
     *
     * Create or update
     *
     * \@example
     *
     * store.upsert(1, { active: true })
     * store.upsert([2, 3], { active: true })
     * store.upsert([2, 3], entity => ({ isOpen: !entity.isOpen}))
     *
     * @param {?} ids
     * @param {?} newState
     * @param {?=} options
     * @return {?}
     */
    function (ids, newState, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var toArray = coerceArray(ids);
        /** @type {?} */
        var predicate = (/**
         * @param {?} isUpdate
         * @return {?}
         */
        function (isUpdate) { return (/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return hasEntity(_this.entities, id) === isUpdate; }); });
        /** @type {?} */
        var isClassBased = isFunction(options.baseClass);
        /** @type {?} */
        var updateIds = toArray.filter(predicate(true));
        /** @type {?} */
        var newEntities = toArray.filter(predicate(false)).map((/**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            var _a;
            /** @type {?} */
            var entity = isFunction(newState) ? newState((/** @type {?} */ ({}))) : newState;
            /** @type {?} */
            var withId = __assign({}, ((/** @type {?} */ (entity))), (_a = {}, _a[_this.idKey] = id, _a));
            if (isClassBased) {
                return new options.baseClass(withId);
            }
            return withId;
        }));
        // it can be any of the three types
        this.update((/** @type {?} */ (updateIds)), (/** @type {?} */ (newState)));
        this.add(newEntities);
        isDev() && logAction('Upsert Entity');
    };
    /**
     *
     * Upsert entity collection (idKey must be present)
     *
     * @example
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }]);
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });
     * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });
     *
     */
    /**
     *
     * Upsert entity collection (idKey must be present)
     *
     * \@example
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }]);
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });
     * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });
     *
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    EntityStore.prototype.upsertMany = /**
     *
     * Upsert entity collection (idKey must be present)
     *
     * \@example
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }]);
     *
     * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });
     * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });
     *
     * @param {?} entities
     * @param {?=} options
     * @return {?}
     */
    function (entities, options) {
        if (options === void 0) { options = {}; }
        var e_1, _a;
        /** @type {?} */
        var addedIds = [];
        /** @type {?} */
        var updatedIds = [];
        /** @type {?} */
        var updatedEntities = {};
        try {
            // Update the state directly to optimize performance
            for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                var entity = entities_1_1.value;
                /** @type {?} */
                var withPreCheckHook = this.akitaPreCheckEntity(entity);
                /** @type {?} */
                var id = withPreCheckHook[this.idKey];
                if (hasEntity(this.entities, id)) {
                    /** @type {?} */
                    var prev = this._value().entities[id];
                    /** @type {?} */
                    var merged = __assign({}, this._value().entities[id], withPreCheckHook);
                    /** @type {?} */
                    var next = options.baseClass ? new options.baseClass(merged) : merged;
                    /** @type {?} */
                    var withHook = this.akitaPreUpdateEntity(prev, next);
                    /** @type {?} */
                    var nextId = withHook[this.idKey];
                    updatedEntities[nextId] = withHook;
                    updatedIds.push(nextId);
                }
                else {
                    /** @type {?} */
                    var newEntity = options.baseClass ? new options.baseClass(withPreCheckHook) : withPreCheckHook;
                    /** @type {?} */
                    var withHook = this.akitaPreAddEntity(newEntity);
                    /** @type {?} */
                    var nextId = withHook[this.idKey];
                    addedIds.push(nextId);
                    updatedEntities[nextId] = withHook;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        isDev() && logAction('Upsert Many');
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return (__assign({}, state, { ids: addedIds.length ? __spread(state.ids, addedIds) : state.ids, entities: __assign({}, state.entities, updatedEntities), loading: !!options.loading })); }));
        updatedIds.length && this.entityActions.next({ type: EntityActions.Update, ids: updatedIds });
        addedIds.length && this.entityActions.next({ type: EntityActions.Add, ids: addedIds });
        if (addedIds.length && this.hasUIStore()) {
            this.handleUICreation(true);
        }
    };
    /**
     *
     * Replace one or more entities (except the id property)
     *
     *
     * @example
     *
     * this.store.replace(5, newEntity)
     * this.store.replace([1,2,3], newEntity)
     */
    /**
     *
     * Replace one or more entities (except the id property)
     *
     *
     * \@example
     *
     * this.store.replace(5, newEntity)
     * this.store.replace([1,2,3], newEntity)
     * @param {?} ids
     * @param {?} newState
     * @return {?}
     */
    EntityStore.prototype.replace = /**
     *
     * Replace one or more entities (except the id property)
     *
     *
     * \@example
     *
     * this.store.replace(5, newEntity)
     * this.store.replace([1,2,3], newEntity)
     * @param {?} ids
     * @param {?} newState
     * @return {?}
     */
    function (ids, newState) {
        var e_2, _a;
        /** @type {?} */
        var toArray = coerceArray(ids);
        if (isEmpty(toArray))
            return;
        /** @type {?} */
        var replaced = {};
        try {
            for (var toArray_1 = __values(toArray), toArray_1_1 = toArray_1.next(); !toArray_1_1.done; toArray_1_1 = toArray_1.next()) {
                var id = toArray_1_1.value;
                newState[this.idKey] = id;
                replaced[id] = newState;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (toArray_1_1 && !toArray_1_1.done && (_a = toArray_1.return)) _a.call(toArray_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        isDev() && setAction('Replace Entity', ids);
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return (__assign({}, state, { entities: __assign({}, state.entities, replaced) })); }));
    };
    /**
     *
     * Move entity inside the collection
     *
     *
     * @example
     *
     * this.store.move(fromIndex, toIndex)
     */
    /**
     *
     * Move entity inside the collection
     *
     *
     * \@example
     *
     * this.store.move(fromIndex, toIndex)
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    EntityStore.prototype.move = /**
     *
     * Move entity inside the collection
     *
     *
     * \@example
     *
     * this.store.move(fromIndex, toIndex)
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    function (from$$1, to) {
        /** @type {?} */
        var ids = this.ids.slice();
        ids.splice(to < 0 ? ids.length + to : to, 0, ids.splice(from$$1, 1)[0]);
        isDev() && setAction('Move Entity');
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return (__assign({}, state, { entities: __assign({}, state.entities), ids: ids })); }));
    };
    /**
     * @param {?=} idsOrFn
     * @return {?}
     */
    EntityStore.prototype.remove = /**
     * @param {?=} idsOrFn
     * @return {?}
     */
    function (idsOrFn) {
        var _this = this;
        if (isEmpty(this.ids))
            return;
        /** @type {?} */
        var idPassed = isDefined(idsOrFn);
        // null means remove all
        /** @type {?} */
        var ids = [];
        if (isFunction(idsOrFn)) {
            ids = this.ids.filter((/**
             * @param {?} entityId
             * @return {?}
             */
            function (entityId) { return idsOrFn(_this.entities[entityId]); }));
        }
        else {
            ids = idPassed ? coerceArray(idsOrFn) : null;
        }
        if (isEmpty(ids))
            return;
        isDev() && setAction('Remove Entity', ids);
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return removeEntities({ state: state, ids: ids }); }));
        if (ids === null) {
            this.setHasCache(false);
        }
        this.handleUIRemove(ids);
        this.entityActions.next({ type: EntityActions.Remove, ids: ids });
    };
    /**
     *
     * Update the active entity
     *
     * @example
     *
     * this.store.updateActive({ completed: true })
     * this.store.updateActive(active => {
     *   return {
     *     config: {
     *      ..active.config,
     *      date
     *     }
     *   }
     * })
     */
    /**
     *
     * Update the active entity
     *
     * \@example
     *
     * this.store.updateActive({ completed: true })
     * this.store.updateActive(active => {
     *   return {
     *     config: {
     *      ..active.config,
     *      date
     *     }
     *   }
     * })
     * @param {?} newStateOrCallback
     * @return {?}
     */
    EntityStore.prototype.updateActive = /**
     *
     * Update the active entity
     *
     * \@example
     *
     * this.store.updateActive({ completed: true })
     * this.store.updateActive(active => {
     *   return {
     *     config: {
     *      ..active.config,
     *      date
     *     }
     *   }
     * })
     * @param {?} newStateOrCallback
     * @return {?}
     */
    function (newStateOrCallback) {
        /** @type {?} */
        var ids = coerceArray(this.active);
        isDev() && setAction('Update Active', ids);
        this.update(ids, (/** @type {?} */ (newStateOrCallback)));
    };
    /**
     * @param {?} idOrOptions
     * @return {?}
     */
    EntityStore.prototype.setActive = /**
     * @param {?} idOrOptions
     * @return {?}
     */
    function (idOrOptions) {
        /** @type {?} */
        var active = getActiveEntities(idOrOptions, this.ids, this.active);
        if (active === undefined) {
            return;
        }
        isDev() && setAction('Set Active', active);
        this._setActive(active);
    };
    /**
     * Add active entities
     *
     * @example
     *
     * store.addActive(2);
     * store.addActive([3, 4, 5]);
     */
    /**
     * Add active entities
     *
     * \@example
     *
     * store.addActive(2);
     * store.addActive([3, 4, 5]);
     * @template T
     * @param {?} ids
     * @return {?}
     */
    EntityStore.prototype.addActive = /**
     * Add active entities
     *
     * \@example
     *
     * store.addActive(2);
     * store.addActive([3, 4, 5]);
     * @template T
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        var _this = this;
        /** @type {?} */
        var toArray = coerceArray(ids);
        if (isEmpty(toArray))
            return;
        /** @type {?} */
        var everyExist = toArray.every((/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return _this.active.indexOf(id) > -1; }));
        if (everyExist)
            return;
        isDev() && setAction('Add Active', ids);
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            /**
             * Protect against case that one of the items in the array exist
             * @type {?}
             */
            var uniques = Array.from(new Set(__spread(((/** @type {?} */ (state.active))), toArray)));
            return __assign({}, state, { active: uniques });
        }));
    };
    /**
     * Remove active entities
     *
     * @example
     *
     * store.removeActive(2)
     * store.removeActive([3, 4, 5])
     */
    /**
     * Remove active entities
     *
     * \@example
     *
     * store.removeActive(2)
     * store.removeActive([3, 4, 5])
     * @template T
     * @param {?} ids
     * @return {?}
     */
    EntityStore.prototype.removeActive = /**
     * Remove active entities
     *
     * \@example
     *
     * store.removeActive(2)
     * store.removeActive([3, 4, 5])
     * @template T
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        var _this = this;
        /** @type {?} */
        var toArray = coerceArray(ids);
        if (isEmpty(toArray))
            return;
        /** @type {?} */
        var someExist = toArray.some((/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return _this.active.indexOf(id) > -1; }));
        if (!someExist)
            return;
        isDev() && setAction('Remove Active', ids);
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            return __assign({}, state, { active: Array.isArray(state.active) ? state.active.filter((/**
                 * @param {?} currentId
                 * @return {?}
                 */
                function (currentId) { return toArray.indexOf(currentId) === -1; })) : null });
        }));
    };
    /**
     * Toggle active entities
     *
     * @example
     *
     * store.toggle(2)
     * store.toggle([3, 4, 5])
     */
    /**
     * Toggle active entities
     *
     * \@example
     *
     * store.toggle(2)
     * store.toggle([3, 4, 5])
     * @template T
     * @param {?} ids
     * @return {?}
     */
    EntityStore.prototype.toggleActive = /**
     * Toggle active entities
     *
     * \@example
     *
     * store.toggle(2)
     * store.toggle([3, 4, 5])
     * @template T
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        var _this = this;
        /** @type {?} */
        var toArray = coerceArray(ids);
        /** @type {?} */
        var filterExists = (/**
         * @param {?} remove
         * @return {?}
         */
        function (remove) { return (/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return _this.active.includes(id) === remove; }); });
        /** @type {?} */
        var remove = toArray.filter(filterExists(true));
        /** @type {?} */
        var add = toArray.filter(filterExists(false));
        this.removeActive(remove);
        this.addActive(add);
        isDev() && logAction('Toggle Active');
    };
    /**
     *
     * Create sub UI store for managing Entity's UI state
     *
     * @example
     *
     * export type ProductUI = {
     *   isLoading: boolean;
     *   isOpen: boolean
     * }
     *
     * interface ProductsUIState extends EntityState<ProductUI> {}
     *
     * export class ProductsStore EntityStore<ProductsState, Product> {
     *   ui: EntityUIStore<ProductsUIState, ProductUI>;
     *
     *   constructor() {
     *     super();
     *     this.createUIStore();
     *   }
     *
     * }
     */
    /**
     *
     * Create sub UI store for managing Entity's UI state
     *
     * \@example
     *
     * export type ProductUI = {
     *   isLoading: boolean;
     *   isOpen: boolean
     * }
     *
     * interface ProductsUIState extends EntityState<ProductUI> {}
     *
     * export class ProductsStore EntityStore<ProductsState, Product> {
     *   ui: EntityUIStore<ProductsUIState, ProductUI>;
     *
     *   constructor() {
     *     super();
     *     this.createUIStore();
     *   }
     *
     * }
     * @param {?=} initialState
     * @param {?=} storeConfig
     * @return {?}
     */
    EntityStore.prototype.createUIStore = /**
     *
     * Create sub UI store for managing Entity's UI state
     *
     * \@example
     *
     * export type ProductUI = {
     *   isLoading: boolean;
     *   isOpen: boolean
     * }
     *
     * interface ProductsUIState extends EntityState<ProductUI> {}
     *
     * export class ProductsStore EntityStore<ProductsState, Product> {
     *   ui: EntityUIStore<ProductsUIState, ProductUI>;
     *
     *   constructor() {
     *     super();
     *     this.createUIStore();
     *   }
     *
     * }
     * @param {?=} initialState
     * @param {?=} storeConfig
     * @return {?}
     */
    function (initialState, storeConfig) {
        if (initialState === void 0) { initialState = {}; }
        if (storeConfig === void 0) { storeConfig = {}; }
        /** @type {?} */
        var defaults = { name: "UI/" + this.storeName, idKey: this.idKey };
        this.ui = new EntityUIStore(initialState, __assign({}, defaults, storeConfig));
        return this.ui;
    };
    // @internal
    // @internal
    /**
     * @return {?}
     */
    EntityStore.prototype.destroy = 
    // @internal
    /**
     * @return {?}
     */
    function () {
        _super.prototype.destroy.call(this);
        if (this.ui instanceof EntityStore) {
            this.ui.destroy();
        }
        this.entityActions.complete();
    };
    // @internal
    // @internal
    /**
     * @param {?} _
     * @param {?} nextEntity
     * @return {?}
     */
    EntityStore.prototype.akitaPreUpdateEntity = 
    // @internal
    /**
     * @param {?} _
     * @param {?} nextEntity
     * @return {?}
     */
    function (_, nextEntity) {
        return (/** @type {?} */ (nextEntity));
    };
    // @internal
    // @internal
    /**
     * @param {?} newEntity
     * @return {?}
     */
    EntityStore.prototype.akitaPreAddEntity = 
    // @internal
    /**
     * @param {?} newEntity
     * @return {?}
     */
    function (newEntity) {
        return (/** @type {?} */ (newEntity));
    };
    // @internal
    // @internal
    /**
     * @param {?} newEntity
     * @return {?}
     */
    EntityStore.prototype.akitaPreCheckEntity = 
    // @internal
    /**
     * @param {?} newEntity
     * @return {?}
     */
    function (newEntity) {
        return newEntity;
    };
    Object.defineProperty(EntityStore.prototype, "ids", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._value().ids;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityStore.prototype, "entities", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._value().entities;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityStore.prototype, "active", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._value().active;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} ids
     * @return {?}
     */
    EntityStore.prototype._setActive = /**
     * @private
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this._setState((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            return __assign({}, state, { active: ids });
        }));
    };
    /**
     * @private
     * @param {?=} add
     * @return {?}
     */
    EntityStore.prototype.handleUICreation = /**
     * @private
     * @param {?=} add
     * @return {?}
     */
    function (add) {
        var _this = this;
        if (add === void 0) { add = false; }
        /** @type {?} */
        var ids = this.ids;
        /** @type {?} */
        var isFunc = isFunction(this.ui._akitaCreateEntityFn);
        /** @type {?} */
        var uiEntities;
        /** @type {?} */
        var createFn = (/**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            var _a;
            /** @type {?} */
            var current = _this.entities[id];
            /** @type {?} */
            var ui = isFunc ? _this.ui._akitaCreateEntityFn(current) : _this.ui._akitaCreateEntityFn;
            return __assign((_a = {}, _a[_this.idKey] = current[_this.idKey], _a), ui);
        });
        if (add) {
            uiEntities = this.ids.filter((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return isUndefined(_this.ui.entities[id]); })).map(createFn);
        }
        else {
            uiEntities = ids.map(createFn);
        }
        add ? this.ui.add(uiEntities) : this.ui.set(uiEntities);
    };
    /**
     * @private
     * @return {?}
     */
    EntityStore.prototype.hasInitialUIState = /**
     * @private
     * @return {?}
     */
    function () {
        return this.hasUIStore() && isUndefined(this.ui._akitaCreateEntityFn) === false;
    };
    /**
     * @private
     * @param {?} ids
     * @return {?}
     */
    EntityStore.prototype.handleUIRemove = /**
     * @private
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        if (this.hasUIStore()) {
            this.ui.remove(ids);
        }
    };
    /**
     * @private
     * @return {?}
     */
    EntityStore.prototype.hasUIStore = /**
     * @private
     * @return {?}
     */
    function () {
        return this.ui instanceof EntityUIStore;
    };
    var _a;
    __decorate([
        transaction(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Object]),
        __metadata("design:returntype", void 0)
    ], EntityStore.prototype, "upsert", null);
    __decorate([
        transaction(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_a = typeof T !== "undefined" && T) === "function" ? _a : Object]),
        __metadata("design:returntype", void 0)
    ], EntityStore.prototype, "toggleActive", null);
    return EntityStore;
}(Store));
// @internal
/**
 * @template UIState, DEPRECATED
 */
var  
// @internal
/**
 * @template UIState, DEPRECATED
 */
EntityUIStore = /** @class */ (function (_super) {
    __extends(EntityUIStore, _super);
    function EntityUIStore(initialState, storeConfig) {
        if (initialState === void 0) { initialState = {}; }
        if (storeConfig === void 0) { storeConfig = {}; }
        return _super.call(this, initialState, storeConfig) || this;
    }
    /**
     *
     * Set the initial UI entity state. This function will determine the entity's
     * initial state when we call `set()` or `add()`.
     *
     * @example
     *
     * constructor() {
     *   super();
     *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));
     *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });
     * }
     *
     */
    /**
     *
     * Set the initial UI entity state. This function will determine the entity's
     * initial state when we call `set()` or `add()`.
     *
     * \@example
     *
     * constructor() {
     *   super();
     *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));
     *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });
     * }
     *
     * @template EntityUI, Entity
     * @param {?} createFn
     * @return {?}
     */
    EntityUIStore.prototype.setInitialEntityState = /**
     *
     * Set the initial UI entity state. This function will determine the entity's
     * initial state when we call `set()` or `add()`.
     *
     * \@example
     *
     * constructor() {
     *   super();
     *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));
     *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });
     * }
     *
     * @template EntityUI, Entity
     * @param {?} createFn
     * @return {?}
     */
    function (createFn) {
        this._akitaCreateEntityFn = createFn;
    };
    return EntityUIStore;
}(EntityStore));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template T
 * @param {?} collection
 * @param {?} idsOrPredicate
 * @param {?} idKey
 * @return {?}
 */
function find(collection, idsOrPredicate, idKey) {
    var e_1, _a, e_2, _b;
    /** @type {?} */
    var result = [];
    if (isFunction(idsOrPredicate)) {
        try {
            for (var collection_1 = __values(collection), collection_1_1 = collection_1.next(); !collection_1_1.done; collection_1_1 = collection_1.next()) {
                var entity = collection_1_1.value;
                if (idsOrPredicate(entity) === true) {
                    result.push(entity);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (collection_1_1 && !collection_1_1.done && (_a = collection_1.return)) _a.call(collection_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        /** @type {?} */
        var toSet = coerceArray(idsOrPredicate).reduce((/**
         * @param {?} acc
         * @param {?} current
         * @return {?}
         */
        function (acc, current) { return acc.add(current); }), new Set());
        try {
            for (var collection_2 = __values(collection), collection_2_1 = collection_2.next(); !collection_2_1.done; collection_2_1 = collection_2.next()) {
                var entity = collection_2_1.value;
                if (toSet.has(entity[idKey])) {
                    result.push(entity);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (collection_2_1 && !collection_2_1.done && (_b = collection_2.return)) _b.call(collection_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    return result;
}
// @internal
/**
 * @template T
 * @return {?}
 */
function distinctUntilArrayItemChanged() {
    return distinctUntilChanged((/**
     * @param {?} prevCollection
     * @param {?} currentCollection
     * @return {?}
     */
    function (prevCollection, currentCollection) {
        if (prevCollection === currentCollection) {
            return true;
        }
        if (isArray(prevCollection) === false || isArray(currentCollection) === false) {
            return false;
        }
        if (isEmpty(prevCollection) && isEmpty(currentCollection)) {
            return true;
        }
        // if item is new in the current collection but not exist in the prev collection
        /** @type {?} */
        var hasNewItem = hasChange(currentCollection, prevCollection);
        if (hasNewItem) {
            return false;
        }
        /** @type {?} */
        var isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);
        // return false means there is a change and we want to call next()
        return isOneOfItemReferenceChanged === false;
    }));
}
// @internal
/**
 * @template T
 * @param {?} first
 * @param {?} second
 * @return {?}
 */
function hasChange(first, second) {
    /** @type {?} */
    var hasChange = second.some((/**
     * @param {?} currentItem
     * @return {?}
     */
    function (currentItem) {
        /** @type {?} */
        var oldItem = first.find((/**
         * @param {?} prevItem
         * @return {?}
         */
        function (prevItem) { return prevItem === currentItem; }));
        return oldItem === undefined;
    }));
    return hasChange;
}
/**
 * @template T
 * @param {?} idsOrPredicate
 * @param {?=} idKey
 * @return {?}
 */
function arrayFind(idsOrPredicate, idKey) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return source.pipe(map((/**
         * @param {?} collection
         * @return {?}
         */
        function (collection) {
            // which means the user deleted the root entity or set the collection to nil
            if (isArray(collection) === false) {
                return collection;
            }
            return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);
        })), distinctUntilArrayItemChanged(), map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (isArray(value) === false) {
                return value;
            }
            if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {
                return value;
            }
            return value[0];
        })));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var Order = {
    ASC: 'asc',
    DESC: 'desc',
};
// @internal
/**
 * @param {?} key
 * @param {?=} order
 * @return {?}
 */
function compareValues(key, order) {
    if (order === void 0) { order = Order.ASC; }
    return (/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
            return 0;
        }
        /** @type {?} */
        var varA = typeof a[key] === 'string' ? a[key].toUpperCase() : a[key];
        /** @type {?} */
        var varB = typeof b[key] === 'string' ? b[key].toUpperCase() : b[key];
        /** @type {?} */
        var comparison = 0;
        if (varA > varB) {
            comparison = 1;
        }
        else if (varA < varB) {
            comparison = -1;
        }
        return order == Order.DESC ? comparison * -1 : comparison;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E, S
 * @param {?} state
 * @param {?} options
 * @return {?}
 */
function entitiesToArray(state, options) {
    /** @type {?} */
    var arr = [];
    var ids = state.ids, entities = state.entities;
    var filterBy = options.filterBy, limitTo = options.limitTo, sortBy = options.sortBy, sortByOrder = options.sortByOrder;
    var _loop_1 = function (i) {
        /** @type {?} */
        var entity = entities[ids[i]];
        if (!filterBy) {
            arr.push(entity);
            return "continue";
        }
        /** @type {?} */
        var toArray = coerceArray(filterBy);
        /** @type {?} */
        var allPass = toArray.every((/**
         * @param {?} fn
         * @return {?}
         */
        function (fn) { return fn(entity, i); }));
        if (allPass) {
            arr.push(entity);
        }
    };
    for (var i = 0; i < ids.length; i++) {
        _loop_1(i);
    }
    if (sortBy) {
        /** @type {?} */
        var _sortBy_1 = isFunction(sortBy) ? sortBy : compareValues(sortBy, sortByOrder);
        arr = arr.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return _sortBy_1(a, b, state); }));
    }
    /** @type {?} */
    var length = Math.min(limitTo || arr.length, arr.length);
    return length === arr.length ? arr : arr.slice(0, length);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template S, E
 * @param {?} state
 * @param {?} options
 * @return {?}
 */
function entitiesToMap(state, options) {
    /** @type {?} */
    var map$$1 = {};
    var filterBy = options.filterBy, limitTo = options.limitTo;
    var ids = state.ids, entities = state.entities;
    if (!filterBy && !limitTo) {
        return entities;
    }
    /** @type {?} */
    var hasLimit = isNil(limitTo) === false;
    if (filterBy && hasLimit) {
        /** @type {?} */
        var count = 0;
        var _loop_1 = function (i, length_1) {
            if (count === limitTo)
                return "break";
            /** @type {?} */
            var id = ids[i];
            /** @type {?} */
            var entity = entities[id];
            /** @type {?} */
            var allPass = coerceArray(filterBy).every((/**
             * @param {?} fn
             * @return {?}
             */
            function (fn) { return fn(entity, i); }));
            if (allPass) {
                map$$1[id] = entity;
                count++;
            }
        };
        for (var i = 0, length_1 = ids.length; i < length_1; i++) {
            var state_1 = _loop_1(i, length_1);
            if (state_1 === "break")
                break;
        }
    }
    else {
        /** @type {?} */
        var finalLength = Math.min(limitTo || ids.length, ids.length);
        var _loop_2 = function (i) {
            /** @type {?} */
            var id = ids[i];
            /** @type {?} */
            var entity = entities[id];
            if (!filterBy) {
                map$$1[id] = entity;
                return "continue";
            }
            /** @type {?} */
            var allPass = coerceArray(filterBy).every((/**
             * @param {?} fn
             * @return {?}
             */
            function (fn) { return fn(entity, i); }));
            if (allPass) {
                map$$1[id] = entity;
            }
        };
        for (var i = 0; i < finalLength; i++) {
            _loop_2(i);
        }
    }
    return map$$1;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E
 * @param {?} predicate
 * @param {?} entities
 * @return {?}
 */
function findEntityByPredicate(predicate, entities) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(entities)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var entityId = _c.value;
            if (predicate(entities[entityId]) === true) {
                return entityId;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}
// @internal
/**
 * @param {?} id
 * @param {?} project
 * @return {?}
 */
function getEntity(id, project) {
    return (/**
     * @param {?} entities
     * @return {?}
     */
    function (entities) {
        /** @type {?} */
        var entity = entities[id];
        if (isUndefined(entity)) {
            return undefined;
        }
        if (!project) {
            return entity;
        }
        if (isString(project)) {
            return entity[project];
        }
        return ((/** @type {?} */ (project)))(entity);
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template T, V
 * @param {?} arr
 * @param {?} callbackFn
 * @return {?}
 */
function mapSkipUndefined(arr, callbackFn) {
    return arr.reduce((/**
     * @param {?} result
     * @param {?} value
     * @param {?} index
     * @param {?} array
     * @return {?}
     */
    function (result, value, index, array) {
        /** @type {?} */
        var val = callbackFn(value, index, array);
        if (val !== undefined) {
            result.push(val);
        }
        return result;
    }), []);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var queryConfigKey = 'akitaQueryConfig';
/**
 * @template E
 * @param {?} metadata
 * @return {?}
 */
function QueryConfig(metadata) {
    return (/**
     * @param {?} constructor
     * @return {?}
     */
    function (constructor) {
        constructor[queryConfigKey] = {};
        for (var i = 0, keys = Object.keys(metadata); i < keys.length; i++) {
            /** @type {?} */
            var key = keys[i];
            constructor[queryConfigKey][key] = metadata[key];
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} keysOrFuncs
 * @return {?}
 */
function compareKeys(keysOrFuncs) {
    return (/**
     * @template T
     * @param {?} prevState
     * @param {?} currState
     * @return {?}
     */
    function (prevState, currState) {
        /** @type {?} */
        var isFns = isFunction(keysOrFuncs[0]);
        // Return when they are NOT changed
        return keysOrFuncs.some((/**
         * @param {?} keyOrFunc
         * @return {?}
         */
        function (keyOrFunc) {
            if (isFns) {
                return keyOrFunc(prevState) !== keyOrFunc(currState);
            }
            return prevState[keyOrFunc] !== currState[keyOrFunc];
        })) === false;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template S
 */
var  /**
 * @template S
 */
Query = /** @class */ (function () {
    function Query(store) {
        this.store = store;
        this.__store__ = store;
        if (isDev()) {
            // @internal
            __queries__[store.storeName] = this;
        }
    }
    /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    Query.prototype.select = /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    function (project) {
        /** @type {?} */
        var mapFn;
        if (isFunction(project)) {
            mapFn = project;
        }
        else if (isString(project)) {
            mapFn = (/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return state[project]; });
        }
        else if (Array.isArray(project)) {
            return (/** @type {?} */ (this.store
                ._select((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return state; }))
                .pipe(distinctUntilChanged(compareKeys(project)), map((/**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                if (isFunction(project[0])) {
                    return ((/** @type {?} */ (project))).map((/**
                     * @param {?} func
                     * @return {?}
                     */
                    function (func) { return func(state); }));
                }
                return ((/** @type {?} */ (project))).reduce((/**
                 * @param {?} acc
                 * @param {?} k
                 * @return {?}
                 */
                function (acc, k) {
                    acc[(/** @type {?} */ (k))] = state[k];
                    return acc;
                }), {});
            })))));
        }
        else {
            mapFn = (/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return state; });
        }
        return this.store._select(mapFn);
    };
    /**
     * Select the loading state
     *
     * @example
     *
     * this.query.selectLoading().subscribe(isLoading => {})
     */
    /**
     * Select the loading state
     *
     * \@example
     *
     * this.query.selectLoading().subscribe(isLoading => {})
     * @return {?}
     */
    Query.prototype.selectLoading = /**
     * Select the loading state
     *
     * \@example
     *
     * this.query.selectLoading().subscribe(isLoading => {})
     * @return {?}
     */
    function () {
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return ((/** @type {?} */ (state))).loading; }));
    };
    /**
     * Select the error state
     *
     * @example
     *
     * this.query.selectError().subscribe(error => {})
     */
    /**
     * Select the error state
     *
     * \@example
     *
     * this.query.selectError().subscribe(error => {})
     * @template ErrorType
     * @return {?}
     */
    Query.prototype.selectError = /**
     * Select the error state
     *
     * \@example
     *
     * this.query.selectError().subscribe(error => {})
     * @template ErrorType
     * @return {?}
     */
    function () {
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return ((/** @type {?} */ (state))).error; }));
    };
    /**
     * Get the store's value
     *
     * @example
     *
     * this.query.getValue()
     *
     */
    /**
     * Get the store's value
     *
     * \@example
     *
     * this.query.getValue()
     *
     * @return {?}
     */
    Query.prototype.getValue = /**
     * Get the store's value
     *
     * \@example
     *
     * this.query.getValue()
     *
     * @return {?}
     */
    function () {
        return this.store._value();
    };
    /**
     * Select the cache state
     *
     * @example
     *
     * this.query.selectHasCache().pipe(
     *   switchMap(hasCache => {
     *     return hasCache ? of() : http().pipe(res => store.set(res))
     *   })
     * )
     */
    /**
     * Select the cache state
     *
     * \@example
     *
     * this.query.selectHasCache().pipe(
     *   switchMap(hasCache => {
     *     return hasCache ? of() : http().pipe(res => store.set(res))
     *   })
     * )
     * @return {?}
     */
    Query.prototype.selectHasCache = /**
     * Select the cache state
     *
     * \@example
     *
     * this.query.selectHasCache().pipe(
     *   switchMap(hasCache => {
     *     return hasCache ? of() : http().pipe(res => store.set(res))
     *   })
     * )
     * @return {?}
     */
    function () {
        return this.store._cache().asObservable();
    };
    /**
     * Whether we've cached data
     *
     * @example
     *
     * this.query.getHasCache()
     *
     */
    /**
     * Whether we've cached data
     *
     * \@example
     *
     * this.query.getHasCache()
     *
     * @return {?}
     */
    Query.prototype.getHasCache = /**
     * Whether we've cached data
     *
     * \@example
     *
     * this.query.getHasCache()
     *
     * @return {?}
     */
    function () {
        return this.store._cache().value;
    };
    Object.defineProperty(Query.prototype, "config", {
        // @internal
        get: 
        // @internal
        /**
         * @return {?}
         */
        function () {
            return this.constructor[queryConfigKey];
        },
        enumerable: true,
        configurable: true
    });
    return Query;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} options
 * @param {?} config
 * @return {?}
 */
function sortByOptions(options, config) {
    options.sortBy = options.sortBy || (config && config.sortBy);
    options.sortByOrder = options.sortByOrder || (config && config.sortByOrder);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 *  The Entity Query is similar to the general Query, with additional functionality tailored for EntityStores.
 *
 *  class WidgetsQuery extends QueryEntity<WidgetsState> {
 *     constructor(protected store: WidgetsStore) {
 *       super(store);
 *     }
 *  }
 *
 *
 *
 * @template S, EntityType, IDType
 */
var  /**
 *
 *  The Entity Query is similar to the general Query, with additional functionality tailored for EntityStores.
 *
 *  class WidgetsQuery extends QueryEntity<WidgetsState> {
 *     constructor(protected store: WidgetsStore) {
 *       super(store);
 *     }
 *  }
 *
 *
 *
 * @template S, EntityType, IDType
 */
QueryEntity = /** @class */ (function (_super) {
    __extends(QueryEntity, _super);
    function QueryEntity(store, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, store) || this;
        _this.options = options;
        _this.__store__ = store;
        return _this;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    QueryEntity.prototype.selectAll = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        if (options === void 0) { options = {
            asObject: false
        }; }
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.entities; })).pipe(map((/**
         * @return {?}
         */
        function () { return _this.getAll(options); })));
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    QueryEntity.prototype.getAll = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = { asObject: false, filterBy: undefined, limitTo: undefined }; }
        if (options.asObject) {
            return entitiesToMap(this.getValue(), options);
        }
        sortByOptions(options, this.config || this.options);
        return entitiesToArray(this.getValue(), options);
    };
    /**
     * @template R
     * @param {?} ids
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectMany = /**
     * @template R
     * @param {?} ids
     * @param {?=} project
     * @return {?}
     */
    function (ids, project) {
        if (!ids || !ids.length)
            return of([]);
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.entities; })).pipe(map((/**
         * @param {?} entities
         * @return {?}
         */
        function (entities) { return mapSkipUndefined(ids, (/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return getEntity(id, project)(entities); })); })), distinctUntilArrayItemChanged());
    };
    /**
     * @template R
     * @param {?} idOrPredicate
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectEntity = /**
     * @template R
     * @param {?} idOrPredicate
     * @param {?=} project
     * @return {?}
     */
    function (idOrPredicate, project) {
        /** @type {?} */
        var id = idOrPredicate;
        if (isFunction(idOrPredicate)) {
            // For performance reason we expect the entity to be in the store
            ((/** @type {?} */ (id))) = findEntityByPredicate(idOrPredicate, this.getValue().entities);
        }
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.entities; })).pipe(map(getEntity(id, project)), distinctUntilChanged());
    };
    /**
     * Get an entity by id
     *
     * @example
     *
     * this.query.getEntity(1);
     */
    /**
     * Get an entity by id
     *
     * \@example
     *
     * this.query.getEntity(1);
     * @param {?} id
     * @return {?}
     */
    QueryEntity.prototype.getEntity = /**
     * Get an entity by id
     *
     * \@example
     *
     * this.query.getEntity(1);
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.getValue().entities[(/** @type {?} */ (id))];
    };
    /**
     * Select the active entity's id
     *
     * @example
     *
     * this.query.selectActiveId()
     */
    /**
     * Select the active entity's id
     *
     * \@example
     *
     * this.query.selectActiveId()
     * @return {?}
     */
    QueryEntity.prototype.selectActiveId = /**
     * Select the active entity's id
     *
     * \@example
     *
     * this.query.selectActiveId()
     * @return {?}
     */
    function () {
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return ((/** @type {?} */ (state))).active; }));
    };
    /**
     * Get the active id
     *
     * @example
     *
     * this.query.getActiveId()
     */
    /**
     * Get the active id
     *
     * \@example
     *
     * this.query.getActiveId()
     * @return {?}
     */
    QueryEntity.prototype.getActiveId = /**
     * Get the active id
     *
     * \@example
     *
     * this.query.getActiveId()
     * @return {?}
     */
    function () {
        return this.getValue().active;
    };
    /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectActive = /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    function (project) {
        var _this = this;
        if (isArray(this.getActive())) {
            return this.selectActiveId().pipe(switchMap((/**
             * @param {?} ids
             * @return {?}
             */
            function (ids) { return _this.selectMany(ids, project); })));
        }
        return this.selectActiveId().pipe(switchMap((/**
         * @param {?} ids
         * @return {?}
         */
        function (ids) { return _this.selectEntity(ids, project); })));
    };
    /**
     * @return {?}
     */
    QueryEntity.prototype.getActive = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var activeId = this.getActiveId();
        if (isArray(activeId)) {
            return activeId.map((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return _this.getValue().entities[(/** @type {?} */ (id))]; }));
        }
        return toBoolean(activeId) ? this.getEntity(activeId) : undefined;
    };
    /**
     * Select the store's entity collection length
     *
     * @example
     *
     * this.query.selectCount()
     * this.query.selectCount(entity => entity.completed)
     */
    /**
     * Select the store's entity collection length
     *
     * \@example
     *
     * this.query.selectCount()
     * this.query.selectCount(entity => entity.completed)
     * @param {?=} predicate
     * @return {?}
     */
    QueryEntity.prototype.selectCount = /**
     * Select the store's entity collection length
     *
     * \@example
     *
     * this.query.selectCount()
     * this.query.selectCount(entity => entity.completed)
     * @param {?=} predicate
     * @return {?}
     */
    function (predicate) {
        var _this = this;
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.entities; })).pipe(map((/**
         * @return {?}
         */
        function () { return _this.getCount(predicate); })));
    };
    /**
     * Get the store's entity collection length
     *
     * @example
     *
     * this.query.getCount()
     * this.query.getCount(entity => entity.completed)
     */
    /**
     * Get the store's entity collection length
     *
     * \@example
     *
     * this.query.getCount()
     * this.query.getCount(entity => entity.completed)
     * @param {?=} predicate
     * @return {?}
     */
    QueryEntity.prototype.getCount = /**
     * Get the store's entity collection length
     *
     * \@example
     *
     * this.query.getCount()
     * this.query.getCount(entity => entity.completed)
     * @param {?=} predicate
     * @return {?}
     */
    function (predicate) {
        if (isFunction(predicate)) {
            return this.getAll().filter(predicate).length;
        }
        return this.getValue().ids.length;
    };
    /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectLast = /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    function (project) {
        return this.selectAt((/**
         * @param {?} ids
         * @return {?}
         */
        function (ids) { return ids[ids.length - 1]; }), project);
    };
    /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectFirst = /**
     * @template R
     * @param {?=} project
     * @return {?}
     */
    function (project) {
        return this.selectAt((/**
         * @param {?} ids
         * @return {?}
         */
        function (ids) { return ids[0]; }), project);
    };
    /**
     * @param {?=} action
     * @return {?}
     */
    QueryEntity.prototype.selectEntityAction = /**
     * @param {?=} action
     * @return {?}
     */
    function (action) {
        if (isUndefined(action)) {
            return this.store.selectEntityAction$;
        }
        return this.store.selectEntityAction$.pipe(filter((/**
         * @param {?} ac
         * @return {?}
         */
        function (ac) { return ac.type === action; })), map((/**
         * @param {?} action
         * @return {?}
         */
        function (action) { return action.ids; })));
    };
    /**
     * @param {?=} projectOrIds
     * @return {?}
     */
    QueryEntity.prototype.hasEntity = /**
     * @param {?=} projectOrIds
     * @return {?}
     */
    function (projectOrIds) {
        var _this = this;
        if (isNil(projectOrIds)) {
            return this.getValue().ids.length > 0;
        }
        if (isFunction(projectOrIds)) {
            return this.getAll().some(projectOrIds);
        }
        if (isArray(projectOrIds)) {
            return projectOrIds.every((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return ((/** @type {?} */ (id))) in _this.getValue().entities; }));
        }
        return ((/** @type {?} */ (projectOrIds))) in this.getValue().entities;
    };
    /**
     * Returns whether entity store has an active entity
     *
     * @example
     *
     * this.query.hasActive()
     * this.query.hasActive(3)
     *
     */
    /**
     * Returns whether entity store has an active entity
     *
     * \@example
     *
     * this.query.hasActive()
     * this.query.hasActive(3)
     *
     * @param {?=} id
     * @return {?}
     */
    QueryEntity.prototype.hasActive = /**
     * Returns whether entity store has an active entity
     *
     * \@example
     *
     * this.query.hasActive()
     * this.query.hasActive(3)
     *
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var active = this.getValue().active;
        /** @type {?} */
        var isIdProvided = isDefined(id);
        if (Array.isArray(active)) {
            if (isIdProvided) {
                return active.includes(id);
            }
            return active.length > 0;
        }
        return isIdProvided ? active === id : isDefined(active);
    };
    /**
     *
     * Create sub UI query for querying Entity's UI state
     *
     * @example
     *
     *
     * export class ProductsQuery extends QueryEntity<ProductsState> {
     *   ui: EntityUIQuery<ProductsUIState>;
     *
     *   constructor(protected store: ProductsStore) {
     *     super(store);
     *     this.createUIQuery();
     *   }
     *
     * }
     */
    /**
     *
     * Create sub UI query for querying Entity's UI state
     *
     * \@example
     *
     *
     * export class ProductsQuery extends QueryEntity<ProductsState> {
     *   ui: EntityUIQuery<ProductsUIState>;
     *
     *   constructor(protected store: ProductsStore) {
     *     super(store);
     *     this.createUIQuery();
     *   }
     *
     * }
     * @return {?}
     */
    QueryEntity.prototype.createUIQuery = /**
     *
     * Create sub UI query for querying Entity's UI state
     *
     * \@example
     *
     *
     * export class ProductsQuery extends QueryEntity<ProductsState> {
     *   ui: EntityUIQuery<ProductsUIState>;
     *
     *   constructor(protected store: ProductsStore) {
     *     super(store);
     *     this.createUIQuery();
     *   }
     *
     * }
     * @return {?}
     */
    function () {
        this.ui = new EntityUIQuery(this.__store__.ui);
    };
    /**
     * @private
     * @template R
     * @param {?} mapFn
     * @param {?=} project
     * @return {?}
     */
    QueryEntity.prototype.selectAt = /**
     * @private
     * @template R
     * @param {?} mapFn
     * @param {?=} project
     * @return {?}
     */
    function (mapFn, project) {
        var _this = this;
        return this.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return (/** @type {?} */ (state.ids)); })).pipe(map(mapFn), distinctUntilChanged(), switchMap((/**
         * @param {?} id
         * @return {?}
         */
        function (id) { return _this.selectEntity(id, project); })));
    };
    return QueryEntity;
}(Query));
// @internal
/**
 * @template UIState, DEPRECATED
 */
var  
// @internal
/**
 * @template UIState, DEPRECATED
 */
EntityUIQuery = /** @class */ (function (_super) {
    __extends(EntityUIQuery, _super);
    function EntityUIQuery(store) {
        return _super.call(this, store) || this;
    }
    return EntityUIQuery;
}(QueryEntity));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@example
 *
 * query.selectEntity(2).pipe(filterNil)
 * @type {?}
 */
var filterNil = (/**
 * @template T
 * @param {?} source
 * @return {?}
 */
function (source) { return source.pipe(filter((/**
 * @param {?} value
 * @return {?}
 */
function (value) { return value !== null && typeof value !== 'undefined'; }))); });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 *
 * \@example
 *
 * getValue(state, 'todos.ui')
 *
 * @param {?} obj
 * @param {?} prop
 * @return {?}
 */
function getValue(obj, prop) {
    /** return the whole state  */
    if (prop.split('.').length === 1) {
        return obj;
    }
    /** @type {?} */
    var removeStoreName = prop
        .split('.')
        .slice(1)
        .join('.');
    return removeStoreName.split('.').reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    function (acc, part) { return acc && acc[part]; }), obj);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 *
 * \@example
 * setValue(state, 'todos.ui', { filter: {} })
 * @param {?} obj
 * @param {?} prop
 * @param {?} val
 * @return {?}
 */
function setValue(obj, prop, val) {
    /** @type {?} */
    var split = prop.split('.');
    if (split.length === 1) {
        return __assign({}, obj, val);
    }
    obj = __assign({}, obj);
    /** @type {?} */
    var lastIndex = split.length - 2;
    /** @type {?} */
    var removeStoreName = prop.split('.').slice(1);
    removeStoreName.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @param {?} index
     * @return {?}
     */
    function (acc, part, index) {
        if (index === lastIndex) {
            if (isObject(acc[part])) {
                acc[part] = __assign({}, acc[part], val);
            }
            else {
                acc[part] = val;
            }
        }
        else {
            acc[part] = __assign({}, acc[part]);
        }
        return acc && acc[part];
    }), obj);
    return obj;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var skipStorageUpdate = false;
/** @type {?} */
var _persistStateInit = new ReplaySubject(1);
/**
 * @return {?}
 */
function selectPersistStateInit() {
    return _persistStateInit.asObservable();
}
/**
 * @param {?} skip
 * @return {?}
 */
function setSkipStorageUpdate(skip$$1) {
    skipStorageUpdate = skip$$1;
}
/**
 * @return {?}
 */
function getSkipStorageUpdate() {
    return skipStorageUpdate;
}
/**
 * @param {?} v
 * @return {?}
 */
function isPromise(v) {
    return v && isFunction(v.then);
}
/**
 * @param {?} asyncOrValue
 * @return {?}
 */
function observify(asyncOrValue) {
    if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {
        return from(asyncOrValue);
    }
    return of(asyncOrValue);
}
/**
 * @param {?=} params
 * @return {?}
 */
function persistState(params) {
    /** @type {?} */
    var defaults = {
        key: 'AkitaStores',
        enableInNonBrowser: false,
        storage: !hasLocalStorage() ? params.storage : localStorage,
        deserialize: JSON.parse,
        serialize: JSON.stringify,
        include: [],
        /**
         * @deprecated use include with a callback
         */
        exclude: [],
        persistOnDestroy: false,
        preStorageUpdate: (/**
         * @param {?} storeName
         * @param {?} state
         * @return {?}
         */
        function (storeName, state) {
            return state;
        }),
        preStoreUpdate: (/**
         * @param {?} storeName
         * @param {?} state
         * @return {?}
         */
        function (storeName, state) {
            return state;
        }),
        skipStorageUpdate: getSkipStorageUpdate,
        preStorageUpdateOperator: (/**
         * @return {?}
         */
        function () { return (/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return source; }); })
    };
    var _a = Object.assign({}, defaults, params), storage = _a.storage, enableInNonBrowser = _a.enableInNonBrowser, deserialize = _a.deserialize, serialize = _a.serialize, include = _a.include, exclude = _a.exclude, key = _a.key, preStorageUpdate = _a.preStorageUpdate, persistOnDestroy = _a.persistOnDestroy, preStorageUpdateOperator = _a.preStorageUpdateOperator, preStoreUpdate = _a.preStoreUpdate, skipStorageUpdate = _a.skipStorageUpdate;
    if ((isNotBrowser && !enableInNonBrowser) || !storage)
        return;
    /** @type {?} */
    var hasInclude = include.length > 0;
    /** @type {?} */
    var hasExclude = exclude.length > 0;
    /** @type {?} */
    var includeStores;
    if (hasInclude && hasExclude) {
        throw new AkitaError("You can't use both include and exclude");
    }
    if (hasInclude) {
        includeStores = include.reduce((/**
         * @param {?} acc
         * @param {?} path
         * @return {?}
         */
        function (acc, path) {
            if (isFunction(path)) {
                acc.fns.push(path);
            }
            else {
                /** @type {?} */
                var storeName = path.split('.')[0];
                acc[storeName] = path;
            }
            return acc;
        }), { fns: [] });
    }
    /** @type {?} */
    var stores = {};
    /** @type {?} */
    var acc = {};
    /** @type {?} */
    var subscriptions = [];
    /** @type {?} */
    var buffer = [];
    /**
     * @param {?} v
     * @return {?}
     */
    function _save(v) {
        observify(v).subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var next = buffer.shift();
            next && _save(next);
        }));
    }
    // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it
    /** @type {?} */
    var isLocalStorage = (hasLocalStorage() && storage === localStorage) || (hasSessionStorage() && storage === sessionStorage);
    observify(storage.getItem(key)).subscribe((/**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var storageState = isObject(value) ? value : deserialize(value || '{}');
        /**
         * @param {?} storeCache
         * @return {?}
         */
        function save(storeCache) {
            storageState['$cache'] = __assign({}, (storageState['$cache'] || {}), storeCache);
            storageState = Object.assign({}, storageState, acc);
            buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));
            _save(buffer.shift());
        }
        /**
         * @param {?} storeName
         * @param {?} path
         * @return {?}
         */
        function subscribe(storeName, path) {
            stores[storeName] = __stores__[storeName]
                ._select((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return getValue(state, path); }))
                .pipe(skip(1), filter((/**
             * @return {?}
             */
            function () { return skipStorageUpdate() === false; })), preStorageUpdateOperator())
                .subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) {
                acc[storeName] = preStorageUpdate(storeName, data);
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    var _a;
                    return save((_a = {}, _a[storeName] = __stores__[storeName]._cache().getValue(), _a));
                }));
            }));
        }
        /**
         * @param {?} storeName
         * @param {?} store
         * @param {?} path
         * @return {?}
         */
        function setInitial(storeName, store, path) {
            if (storeName in storageState) {
                setAction('@PersistState');
                store._setState((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) {
                    return setValue(state, path, preStoreUpdate(storeName, storageState[storeName]));
                }));
                /** @type {?} */
                var hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;
                __stores__[storeName].setHasCache(hasCache, { restartTTL: true });
            }
        }
        subscriptions.push($$deleteStore.subscribe((/**
         * @param {?} storeName
         * @return {?}
         */
        function (storeName) {
            var _a;
            if (stores[storeName]) {
                if (persistOnDestroy === false) {
                    save((_a = {}, _a[storeName] = false, _a));
                }
                stores[storeName].unsubscribe();
                delete stores[storeName];
            }
        })));
        subscriptions.push($$addStore.subscribe((/**
         * @param {?} storeName
         * @return {?}
         */
        function (storeName) {
            if (storeName === 'router' || (hasExclude && exclude.includes(storeName))) {
                return;
            }
            /** @type {?} */
            var store = __stores__[storeName];
            if (hasInclude) {
                /** @type {?} */
                var path = includeStores[storeName];
                if (!path) {
                    /** @type {?} */
                    var passPredicate = includeStores.fns.some((/**
                     * @param {?} fn
                     * @return {?}
                     */
                    function (fn) { return fn(storeName); }));
                    if (passPredicate) {
                        path = storeName;
                    }
                    else {
                        return;
                    }
                }
                setInitial(storeName, store, path);
                subscribe(storeName, path);
            }
            else {
                setInitial(storeName, store, storeName);
                subscribe(storeName, storeName);
            }
        })));
        _persistStateInit.next();
    }));
    return {
        destroy: /**
         * @return {?}
         */
        function () {
            subscriptions.forEach((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.unsubscribe(); }));
            for (var i = 0, keys = Object.keys(stores); i < keys.length; i++) {
                /** @type {?} */
                var storeName = keys[i];
                stores[storeName].unsubscribe();
            }
            stores = {};
        },
        clear: /**
         * @return {?}
         */
        function () {
            storage.clear();
        },
        clearStore: /**
         * @param {?=} storeName
         * @return {?}
         */
        function (storeName) {
            if (isNil(storeName)) {
                /** @type {?} */
                var value_1 = observify(storage.setItem(key, '{}'));
                value_1.subscribe();
                return;
            }
            /** @type {?} */
            var value = storage.getItem(key);
            observify(value).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                /** @type {?} */
                var storageState = deserialize(v || '{}');
                if (storageState[storeName]) {
                    delete storageState[storeName];
                    /** @type {?} */
                    var value_2 = observify(storage.setItem(key, serialize(storageState)));
                    value_2.subscribe();
                }
            }));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SnapshotManager = /** @class */ (function () {
    function SnapshotManager() {
    }
    /**
     * Get a snapshot of the whole state or a specific stores
     * Use it ONLY for things such as saving the state in the server
     */
    /**
     * Get a snapshot of the whole state or a specific stores
     * Use it ONLY for things such as saving the state in the server
     * @param {?=} stores
     * @return {?}
     */
    SnapshotManager.prototype.getStoresSnapshot = /**
     * Get a snapshot of the whole state or a specific stores
     * Use it ONLY for things such as saving the state in the server
     * @param {?=} stores
     * @return {?}
     */
    function (stores) {
        if (stores === void 0) { stores = []; }
        /** @type {?} */
        var acc = {};
        /** @type {?} */
        var hasInclude = stores.length > 0;
        /** @type {?} */
        var keys = hasInclude ? stores : Object.keys(__stores__);
        for (var i = 0; i < keys.length; i++) {
            /** @type {?} */
            var storeName = keys[i];
            if (storeName !== 'router') {
                acc[storeName] = __stores__[storeName]._value();
            }
        }
        return acc;
    };
    /**
     * @param {?} stores
     * @param {?=} options
     * @return {?}
     */
    SnapshotManager.prototype.setStoresSnapshot = /**
     * @param {?} stores
     * @param {?=} options
     * @return {?}
     */
    function (stores, options) {
        /** @type {?} */
        var mergedOptions = __assign({ skipStorageUpdate: false, lazy: false }, options);
        mergedOptions.skipStorageUpdate && setSkipStorageUpdate(true);
        /** @type {?} */
        var normalizedStores = stores;
        if (isString(stores)) {
            normalizedStores = JSON.parse((/** @type {?} */ (normalizedStores)));
        }
        /** @type {?} */
        var size = Object.keys(normalizedStores).length;
        if (mergedOptions.lazy) {
            $$addStore
                .pipe(filter((/**
             * @param {?} name
             * @return {?}
             */
            function (name) { return normalizedStores.hasOwnProperty(name); })), take(size))
                .subscribe((/**
             * @param {?} name
             * @return {?}
             */
            function (name) { return __stores__[name]._setState((/**
             * @return {?}
             */
            function () { return normalizedStores[name]; })); }));
        }
        else {
            var _loop_1 = function (i, keys) {
                /** @type {?} */
                var storeName = keys[i];
                if (__stores__[storeName]) {
                    __stores__[storeName]._setState((/**
                     * @return {?}
                     */
                    function () { return normalizedStores[storeName]; }));
                }
            };
            for (var i = 0, keys = Object.keys(normalizedStores); i < keys.length; i++) {
                _loop_1(i, keys);
            }
        }
        mergedOptions.skipStorageUpdate && setSkipStorageUpdate(false);
    };
    return SnapshotManager;
}());
/** @type {?} */
var snapshotManager = new SnapshotManager();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template State
 */
var  /**
 * @abstract
 * @template State
 */
AkitaPlugin = /** @class */ (function () {
    function AkitaPlugin(query, config) {
        this.query = query;
        if (config && config.resetFn) {
            if (getAkitaConfig().resettable) {
                this.onReset(config.resetFn);
            }
        }
    }
    /** This method is responsible for getting access to the query. */
    /**
     * This method is responsible for getting access to the query.
     * @protected
     * @return {?}
     */
    AkitaPlugin.prototype.getQuery = /**
     * This method is responsible for getting access to the query.
     * @protected
     * @return {?}
     */
    function () {
        return this.query;
    };
    /** This method is responsible for getting access to the store. */
    /**
     * This method is responsible for getting access to the store.
     * @protected
     * @return {?}
     */
    AkitaPlugin.prototype.getStore = /**
     * This method is responsible for getting access to the store.
     * @protected
     * @return {?}
     */
    function () {
        return this.getQuery().__store__;
    };
    /** This method is responsible tells whether the plugin is entityBased or not.  */
    /**
     * This method is responsible tells whether the plugin is entityBased or not.
     * @protected
     * @param {?} entityId
     * @return {?}
     */
    AkitaPlugin.prototype.isEntityBased = /**
     * This method is responsible tells whether the plugin is entityBased or not.
     * @protected
     * @param {?} entityId
     * @return {?}
     */
    function (entityId) {
        return toBoolean(entityId);
    };
    /** This method is responsible for selecting the source; it can be the whole store or one entity. */
    /**
     * This method is responsible for selecting the source; it can be the whole store or one entity.
     * @protected
     * @param {?} entityId
     * @param {?=} property
     * @return {?}
     */
    AkitaPlugin.prototype.selectSource = /**
     * This method is responsible for selecting the source; it can be the whole store or one entity.
     * @protected
     * @param {?} entityId
     * @param {?=} property
     * @return {?}
     */
    function (entityId, property) {
        var _this = this;
        if (this.isEntityBased(entityId)) {
            return ((/** @type {?} */ (this.getQuery()))).selectEntity(entityId).pipe(filterNil);
        }
        if (property) {
            return this.getQuery().select((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return getValue(state, _this.withStoreName(property)); }));
        }
        return this.getQuery().select();
    };
    /**
     * @protected
     * @param {?} entityId
     * @param {?=} property
     * @return {?}
     */
    AkitaPlugin.prototype.getSource = /**
     * @protected
     * @param {?} entityId
     * @param {?=} property
     * @return {?}
     */
    function (entityId, property) {
        if (this.isEntityBased(entityId)) {
            return ((/** @type {?} */ (this.getQuery()))).getEntity(entityId);
        }
        /** @type {?} */
        var state = this.getQuery().getValue();
        if (property) {
            return getValue(state, this.withStoreName(property));
        }
        return state;
    };
    /**
     * @protected
     * @param {?} prop
     * @return {?}
     */
    AkitaPlugin.prototype.withStoreName = /**
     * @protected
     * @param {?} prop
     * @return {?}
     */
    function (prop) {
        return this.storeName + "." + prop;
    };
    Object.defineProperty(AkitaPlugin.prototype, "storeName", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.getStore().storeName;
        },
        enumerable: true,
        configurable: true
    });
    /** This method is responsible for updating the store or one entity; it can be the whole store or one entity. */
    /**
     * This method is responsible for updating the store or one entity; it can be the whole store or one entity.
     * @protected
     * @param {?} newState
     * @param {?=} entityId
     * @param {?=} property
     * @return {?}
     */
    AkitaPlugin.prototype.updateStore = /**
     * This method is responsible for updating the store or one entity; it can be the whole store or one entity.
     * @protected
     * @param {?} newState
     * @param {?=} entityId
     * @param {?=} property
     * @return {?}
     */
    function (newState, entityId, property) {
        var _this = this;
        if (this.isEntityBased(entityId)) {
            this.getStore().update(entityId, newState);
        }
        else {
            if (property) {
                this.getStore()._setState((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) {
                    return setValue(state, _this.withStoreName(property), newState);
                }));
                return;
            }
            this.getStore()._setState((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return (__assign({}, state, newState)); }));
        }
    };
    /**
     * Function to invoke upon reset
     */
    /**
     * Function to invoke upon reset
     * @private
     * @param {?} fn
     * @return {?}
     */
    AkitaPlugin.prototype.onReset = /**
     * Function to invoke upon reset
     * @private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var _this = this;
        /** @type {?} */
        var original = this.getStore().reset;
        this.getStore().reset = (/**
         * @param {...?} params
         * @return {?}
         */
        function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            /** It should run after the plugin destroy method */
            setTimeout((/**
             * @return {?}
             */
            function () {
                original.apply(_this.getStore(), params);
                fn();
            }));
        });
    };
    return AkitaPlugin;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var paginatorDefaults = {
    pagesControls: false,
    range: false,
    startWith: 1,
    cacheTimeout: undefined,
    clearStoreWithCache: true
};
/**
 * @template State
 */
var PaginatorPlugin = /** @class */ (function (_super) {
    __extends(PaginatorPlugin, _super);
    function PaginatorPlugin(query, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, query, {
            resetFn: (/**
             * @return {?}
             */
            function () {
                _this.initial = false;
                _this.destroy({ clearCache: true, currentPage: 1 });
            })
        }) || this;
        _this.query = query;
        _this.config = config;
        /**
         * Save current filters, sorting, etc. in cache
         */
        _this.metadata = new Map();
        _this.pages = new Map();
        _this.pagination = {
            currentPage: 1,
            perPage: 0,
            total: 0,
            lastPage: 0,
            data: []
        };
        /**
         * When the user navigates to a different page and return
         * we don't want to call `clearCache` on first time.
         */
        _this.initial = true;
        /**
         * Proxy to the query loading
         */
        _this.isLoading$ = _this.query.selectLoading().pipe(delay(0));
        _this.config = Object.assign(paginatorDefaults, config);
        var _a = _this.config, startWith = _a.startWith, cacheTimeout = _a.cacheTimeout;
        _this.page = new BehaviorSubject(startWith);
        if (isObservable(cacheTimeout)) {
            _this.clearCacheSubscription = cacheTimeout.subscribe((/**
             * @return {?}
             */
            function () { return _this.clearCache(); }));
        }
        return _this;
    }
    Object.defineProperty(PaginatorPlugin.prototype, "pageChanges", {
        /**
         * Listen to page changes
         */
        get: /**
         * Listen to page changes
         * @return {?}
         */
        function () {
            return this.page.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaginatorPlugin.prototype, "currentPage", {
        /**
         * Get the current page number
         */
        get: /**
         * Get the current page number
         * @return {?}
         */
        function () {
            return this.pagination.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaginatorPlugin.prototype, "isFirst", {
        /**
         * Check if current page is the first one
         */
        get: /**
         * Check if current page is the first one
         * @return {?}
         */
        function () {
            return this.currentPage === 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaginatorPlugin.prototype, "isLast", {
        /**
         * Check if current page is the last one
         */
        get: /**
         * Check if current page is the last one
         * @return {?}
         */
        function () {
            return this.currentPage === this.pagination.lastPage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Whether to generate an array of pages for *ngFor
     * [1, 2, 3, 4]
     */
    /**
     * Whether to generate an array of pages for *ngFor
     * [1, 2, 3, 4]
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    PaginatorPlugin.prototype.withControls = /**
     * Whether to generate an array of pages for *ngFor
     * [1, 2, 3, 4]
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    function () {
        (/** @type {?} */ (this)).config.pagesControls = true;
        return (/** @type {?} */ (this));
    };
    /**
     * Whether to generate the `from` and `to` keys
     * [1, 2, 3, 4]
     */
    /**
     * Whether to generate the `from` and `to` keys
     * [1, 2, 3, 4]
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    PaginatorPlugin.prototype.withRange = /**
     * Whether to generate the `from` and `to` keys
     * [1, 2, 3, 4]
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    function () {
        (/** @type {?} */ (this)).config.range = true;
        return (/** @type {?} */ (this));
    };
    /**
     * Set the loading state
     */
    /**
     * Set the loading state
     * @param {?=} value
     * @return {?}
     */
    PaginatorPlugin.prototype.setLoading = /**
     * Set the loading state
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = true; }
        this.getStore().setLoading(value);
    };
    /**
     * Update the pagination object and add the page
     */
    /**
     * Update the pagination object and add the page
     * @param {?} response
     * @return {?}
     */
    PaginatorPlugin.prototype.update = /**
     * Update the pagination object and add the page
     * @param {?} response
     * @return {?}
     */
    function (response) {
        this.pagination = response;
        this.addPage(response.data);
    };
    /**
     *
     * Set the ids and add the page to store
     */
    /**
     *
     * Set the ids and add the page to store
     * @param {?} data
     * @return {?}
     */
    PaginatorPlugin.prototype.addPage = /**
     *
     * Set the ids and add the page to store
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.pages.set(this.currentPage, { ids: data.map((/**
             * @param {?} entity
             * @return {?}
             */
            function (entity) { return entity[_this.getStore().idKey]; })) });
        this.getStore().add(data);
    };
    /**
     * Clear the cache.
     */
    /**
     * Clear the cache.
     * @param {?=} options
     * @return {?}
     */
    PaginatorPlugin.prototype.clearCache = /**
     * Clear the cache.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (!this.initial) {
            logAction('@Pagination - Clear Cache');
            if (options.clearStore !== false && (this.config.clearStoreWithCache || options.clearStore)) {
                this.getStore().remove();
            }
            this.pages = new Map();
            this.metadata = new Map();
        }
        this.initial = false;
    };
    /**
     * @param {?} page
     * @return {?}
     */
    PaginatorPlugin.prototype.clearPage = /**
     * @param {?} page
     * @return {?}
     */
    function (page) {
        this.pages.delete(page);
    };
    /**
     * Clear the cache timeout and optionally the pages
     */
    /**
     * Clear the cache timeout and optionally the pages
     * @param {?=} __0
     * @return {?}
     */
    PaginatorPlugin.prototype.destroy = /**
     * Clear the cache timeout and optionally the pages
     * @param {?=} __0
     * @return {?}
     */
    function (_a) {
        var _b = _a === void 0 ? {} : _a, clearCache = _b.clearCache, currentPage = _b.currentPage;
        if (this.clearCacheSubscription) {
            this.clearCacheSubscription.unsubscribe();
        }
        if (clearCache) {
            this.clearCache();
        }
        if (!isUndefined(currentPage)) {
            this.setPage(currentPage);
        }
        this.initial = true;
    };
    /**
     * Whether the provided page is active
     */
    /**
     * Whether the provided page is active
     * @param {?} page
     * @return {?}
     */
    PaginatorPlugin.prototype.isPageActive = /**
     * Whether the provided page is active
     * @param {?} page
     * @return {?}
     */
    function (page) {
        return this.currentPage === page;
    };
    /**
     * Set the current page
     */
    /**
     * Set the current page
     * @param {?} page
     * @return {?}
     */
    PaginatorPlugin.prototype.setPage = /**
     * Set the current page
     * @param {?} page
     * @return {?}
     */
    function (page) {
        if (page !== this.currentPage || !this.hasPage(page)) {
            this.page.next((this.pagination.currentPage = page));
        }
    };
    /**
     * Increment current page
     */
    /**
     * Increment current page
     * @return {?}
     */
    PaginatorPlugin.prototype.nextPage = /**
     * Increment current page
     * @return {?}
     */
    function () {
        if (this.currentPage !== this.pagination.lastPage) {
            this.setPage(this.pagination.currentPage + 1);
        }
    };
    /**
     * Decrement current page
     */
    /**
     * Decrement current page
     * @return {?}
     */
    PaginatorPlugin.prototype.prevPage = /**
     * Decrement current page
     * @return {?}
     */
    function () {
        if (this.pagination.currentPage > 1) {
            this.setPage(this.pagination.currentPage - 1);
        }
    };
    /**
     * Set current page to last
     */
    /**
     * Set current page to last
     * @return {?}
     */
    PaginatorPlugin.prototype.setLastPage = /**
     * Set current page to last
     * @return {?}
     */
    function () {
        this.setPage(this.pagination.lastPage);
    };
    /**
     * Set current page to first
     */
    /**
     * Set current page to first
     * @return {?}
     */
    PaginatorPlugin.prototype.setFirstPage = /**
     * Set current page to first
     * @return {?}
     */
    function () {
        this.setPage(1);
    };
    /**
     * Check if page exists in cache
     */
    /**
     * Check if page exists in cache
     * @param {?} page
     * @return {?}
     */
    PaginatorPlugin.prototype.hasPage = /**
     * Check if page exists in cache
     * @param {?} page
     * @return {?}
     */
    function (page) {
        return this.pages.has(page);
    };
    /**
     * Get the current page if it's in cache, otherwise invoke the request
     */
    /**
     * Get the current page if it's in cache, otherwise invoke the request
     * @param {?} req
     * @return {?}
     */
    PaginatorPlugin.prototype.getPage = /**
     * Get the current page if it's in cache, otherwise invoke the request
     * @param {?} req
     * @return {?}
     */
    function (req) {
        var _this = this;
        /** @type {?} */
        var page = this.pagination.currentPage;
        if (this.hasPage(page)) {
            return this.selectPage(page);
        }
        else {
            this.setLoading(true);
            return from(req()).pipe(switchMap((/**
             * @param {?} config
             * @return {?}
             */
            function (config) {
                page = config.currentPage;
                applyTransaction((/**
                 * @return {?}
                 */
                function () {
                    _this.setLoading(false);
                    _this.update(config);
                }));
                return _this.selectPage(page);
            })));
        }
    };
    /**
     * @return {?}
     */
    PaginatorPlugin.prototype.getQuery = /**
     * @return {?}
     */
    function () {
        return this.query;
    };
    /**
     * @return {?}
     */
    PaginatorPlugin.prototype.refreshCurrentPage = /**
     * @return {?}
     */
    function () {
        if (isNil(this.currentPage) === false) {
            this.clearPage(this.currentPage);
            this.setPage(this.currentPage);
        }
    };
    /**
     * @private
     * @return {?}
     */
    PaginatorPlugin.prototype.getFrom = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isFirst) {
            return 1;
        }
        return (this.currentPage - 1) * this.pagination.perPage + 1;
    };
    /**
     * @private
     * @return {?}
     */
    PaginatorPlugin.prototype.getTo = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isLast) {
            return this.pagination.total;
        }
        return this.currentPage * this.pagination.perPage;
    };
    /**
     * Select the page
     */
    /**
     * Select the page
     * @private
     * @param {?} page
     * @return {?}
     */
    PaginatorPlugin.prototype.selectPage = /**
     * Select the page
     * @private
     * @param {?} page
     * @return {?}
     */
    function (page) {
        var _this = this;
        return this.query.selectAll({ asObject: true }).pipe(take(1), map((/**
         * @param {?} entities
         * @return {?}
         */
        function (entities) {
            /** @type {?} */
            var response = __assign({}, _this.pagination, { data: _this.pages.get(page).ids.map((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return entities[id]; })) });
            var _a = _this.config, range = _a.range, pagesControls = _a.pagesControls;
            /** If no total - calc it */
            if (isNaN(_this.pagination.total)) {
                if (response.lastPage === 1) {
                    response.total = response.data ? response.data.length : 0;
                }
                else {
                    response.total = response.perPage * response.lastPage;
                }
                _this.pagination.total = response.total;
            }
            if (range) {
                response.from = _this.getFrom();
                response.to = _this.getTo();
            }
            if (pagesControls) {
                response.pageControls = generatePages(_this.pagination.total, _this.pagination.perPage);
            }
            return response;
        })));
    };
    __decorate([
        action('@Pagination - New Page'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], PaginatorPlugin.prototype, "update", null);
    return PaginatorPlugin;
}(AkitaPlugin));
/**
 * Generate an array so we can ngFor them to navigate between pages
 * @param {?} total
 * @param {?} perPage
 * @return {?}
 */
function generatePages(total, perPage) {
    /** @type {?} */
    var len = Math.ceil(total / perPage);
    /** @type {?} */
    var arr = [];
    for (var i = 0; i < len; i++) {
        arr.push(i + 1);
    }
    return arr;
}
/**
 * backward compatibility
 * @type {?}
 */
var Paginator = PaginatorPlugin;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Todo: Return  AbstractControl interface
/**
 * @template T
 */
var  
// Todo: Return  AbstractControl interface
/**
 * @template T
 */
PersistNgFormPlugin = /** @class */ (function (_super) {
    __extends(PersistNgFormPlugin, _super);
    function PersistNgFormPlugin(query, factoryFnOrPath, params) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this, query) || this;
        _this.query = query;
        _this.factoryFnOrPath = factoryFnOrPath;
        _this.params = params;
        _this.params = __assign({ debounceTime: 300, formKey: 'akitaForm', emitEvent: false, arrControlFactory: (/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return _this.builder.control(v); }) }, params);
        _this.isRootKeys = toBoolean(factoryFnOrPath) === false;
        _this.isKeyBased = isString(factoryFnOrPath) || _this.isRootKeys;
        return _this;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} form
     * @param {?=} builder
     * @return {THIS}
     */
    PersistNgFormPlugin.prototype.setForm = /**
     * @template THIS
     * @this {THIS}
     * @param {?} form
     * @param {?=} builder
     * @return {THIS}
     */
    function (form, builder) {
        (/** @type {?} */ (this)).form = form;
        (/** @type {?} */ (this)).builder = builder;
        (/** @type {?} */ (this)).activate();
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?=} initialState
     * @return {?}
     */
    PersistNgFormPlugin.prototype.reset = /**
     * @param {?=} initialState
     * @return {?}
     */
    function (initialState) {
        var _this = this;
        var _a;
        /** @type {?} */
        var value;
        if (initialState) {
            value = initialState;
        }
        else {
            value = this.isKeyBased ? this.initialValue : ((/** @type {?} */ (this))).factoryFnOrPath();
        }
        if (this.isKeyBased) {
            Object.keys(this.initialValue).forEach((/**
             * @param {?} stateKey
             * @return {?}
             */
            function (stateKey) {
                /** @type {?} */
                var value = _this.initialValue[stateKey];
                if (Array.isArray(value) && _this.builder) {
                    /** @type {?} */
                    var formArray = _this.form.controls[stateKey];
                    _this.cleanArray(formArray);
                    value.forEach((/**
                     * @param {?} v
                     * @param {?} i
                     * @return {?}
                     */
                    function (v, i) {
                        _this.form.get(stateKey).insert(i, ((/** @type {?} */ (_this.params.arrControlFactory)))(v));
                    }));
                }
            }));
        }
        this.form.patchValue(value, { emitEvent: this.params.emitEvent });
        /** @type {?} */
        var storeValue = this.isKeyBased ? setValue(this.getQuery().getValue(), this.getStore().storeName + "." + this.factoryFnOrPath, value) : (_a = {}, _a[this.params.formKey] = value, _a);
        this.updateStore(storeValue);
    };
    /**
     * @private
     * @param {?} control
     * @return {?}
     */
    PersistNgFormPlugin.prototype.cleanArray = /**
     * @private
     * @param {?} control
     * @return {?}
     */
    function (control) {
        while (control.length !== 0) {
            control.removeAt(0);
        }
    };
    /**
     * @private
     * @param {?} formValue
     * @param {?} root
     * @return {?}
     */
    PersistNgFormPlugin.prototype.resolveInitialValue = /**
     * @private
     * @param {?} formValue
     * @param {?} root
     * @return {?}
     */
    function (formValue, root) {
        var _this = this;
        if (!formValue)
            return;
        return Object.keys(formValue).reduce((/**
         * @param {?} acc
         * @param {?} stateKey
         * @return {?}
         */
        function (acc, stateKey) {
            /** @type {?} */
            var value = root[stateKey];
            if (Array.isArray(value) && _this.builder) {
                /** @type {?} */
                var factory_1 = _this.params.arrControlFactory;
                _this.cleanArray(_this.form.get(stateKey));
                value.forEach((/**
                 * @param {?} v
                 * @param {?} i
                 * @return {?}
                 */
                function (v, i) {
                    _this.form.get(stateKey).insert(i, ((/** @type {?} */ (factory_1)))(v));
                }));
            }
            acc[stateKey] = root[stateKey];
            return acc;
        }), {});
    };
    /**
     * @private
     * @return {?}
     */
    PersistNgFormPlugin.prototype.activate = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        var _a;
        /** @type {?} */
        var path;
        if (this.isKeyBased) {
            if (this.isRootKeys) {
                this.initialValue = this.resolveInitialValue(this.form.value, this.getQuery().getValue());
                this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });
            }
            else {
                path = this.getStore().storeName + "." + this.factoryFnOrPath;
                /** @type {?} */
                var root = getValue(this.getQuery().getValue(), path);
                this.initialValue = this.resolveInitialValue(root, root);
                this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });
            }
        }
        else {
            if (!((/** @type {?} */ (this.getQuery().getValue())))[this.params.formKey]) {
                logAction('@PersistNgFormPlugin activate');
                this.updateStore((_a = {}, _a[this.params.formKey] = ((/** @type {?} */ (this))).factoryFnOrPath(), _a));
            }
            /** @type {?} */
            var value = this.getQuery().getValue()[this.params.formKey];
            this.form.patchValue(value);
        }
        this.formChanges = this.form.valueChanges.pipe(debounceTime(this.params.debounceTime)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            logAction('@PersistForm - Update');
            /** @type {?} */
            var newState;
            if (_this.isKeyBased) {
                if (_this.isRootKeys) {
                    newState = (/**
                     * @param {?} state
                     * @return {?}
                     */
                    function (state) { return (__assign({}, state, value)); });
                }
                else {
                    newState = (/**
                     * @param {?} state
                     * @return {?}
                     */
                    function (state) { return setValue(state, path, value); });
                }
            }
            else {
                newState = (/**
                 * @return {?}
                 */
                function () {
                    var _a;
                    return (_a = {}, _a[_this.params.formKey] = value, _a);
                });
            }
            _this.updateStore(newState(_this.getQuery().getValue()));
        }));
    };
    /**
     * @return {?}
     */
    PersistNgFormPlugin.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.formChanges && this.formChanges.unsubscribe();
        this.form = null;
        this.builder = null;
    };
    return PersistNgFormPlugin;
}(AkitaPlugin));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function capitalize(value) {
    return value && value.charAt(0).toUpperCase() + value.slice(1);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var subs = [];
/**
 * @param {?=} ngZoneOrOptions
 * @param {?=} options
 * @return {?}
 */
function akitaDevtools(ngZoneOrOptions, options) {
    if (options === void 0) { options = {}; }
    if (isNotBrowser)
        return;
    if (!((/** @type {?} */ (window))).__REDUX_DEVTOOLS_EXTENSION__) {
        return;
    }
    subs.length &&
        subs.forEach((/**
         * @param {?} s
         * @return {?}
         */
        function (s) {
            if (s.unsubscribe) {
                s.unsubscribe();
            }
            else {
                s && s();
            }
        }));
    /** @type {?} */
    var isAngular = ngZoneOrOptions && ngZoneOrOptions['run'];
    if (!isAngular) {
        ngZoneOrOptions = ngZoneOrOptions || {};
        ((/** @type {?} */ (ngZoneOrOptions))).run = (/**
         * @param {?} cb
         * @return {?}
         */
        function (cb) { return cb(); });
        options = (/** @type {?} */ (ngZoneOrOptions));
    }
    /** @type {?} */
    var defaultOptions = { name: 'Akita', shallow: true, storesWhitelist: [] };
    /** @type {?} */
    var merged = Object.assign({}, defaultOptions, options);
    /** @type {?} */
    var storesWhitelist = merged.storesWhitelist;
    /** @type {?} */
    var devTools = ((/** @type {?} */ (window))).__REDUX_DEVTOOLS_EXTENSION__.connect(merged);
    /** @type {?} */
    var appState = {};
    /** @type {?} */
    var isAllowed = (/**
     * @param {?} storeName
     * @return {?}
     */
    function (storeName) {
        if (!storesWhitelist.length) {
            return true;
        }
        return storesWhitelist.indexOf(storeName) > -1;
    });
    subs.push($$addStore.subscribe((/**
     * @param {?} storeName
     * @return {?}
     */
    function (storeName) {
        var _a;
        if (isAllowed(storeName) === false)
            return;
        appState = __assign({}, appState, (_a = {}, _a[storeName] = __stores__[storeName]._value(), _a));
        devTools.send({ type: "[" + capitalize(storeName) + "] - @@INIT" }, appState);
    })));
    subs.push($$deleteStore.subscribe((/**
     * @param {?} storeName
     * @return {?}
     */
    function (storeName) {
        if (isAllowed(storeName) === false)
            return;
        delete appState[storeName];
        devTools.send({ type: "[" + storeName + "] - Delete Store" }, appState);
    })));
    subs.push($$updateStore.subscribe((/**
     * @param {?} storeName
     * @return {?}
     */
    function (storeName) {
        var _a;
        if (isAllowed(storeName) === false)
            return;
        var type = currentAction.type, entityIds = currentAction.entityIds, skip$$1 = currentAction.skip;
        if (skip$$1) {
            setSkipAction(false);
            return;
        }
        /** @type {?} */
        var store = __stores__[storeName];
        if (!store) {
            return;
        }
        if (options.shallow === false && appState[storeName]) {
            /** @type {?} */
            var isEqual = JSON.stringify(store._value()) === JSON.stringify(appState[storeName]);
            if (isEqual)
                return;
        }
        appState = __assign({}, appState, (_a = {}, _a[storeName] = store._value(), _a));
        /** @type {?} */
        var normalize = capitalize(storeName);
        /** @type {?} */
        var msg = isDefined(entityIds) ? "[" + normalize + "] - " + type + " (ids: " + entityIds + ")" : "[" + normalize + "] - " + type;
        if (options.logTrace) {
            console.group(msg);
            console.trace();
            console.groupEnd();
        }
        if (options.sortAlphabetically) {
            /** @type {?} */
            var sortedAppState = Object.keys(appState)
                .sort()
                .reduce((/**
             * @param {?} acc
             * @param {?} storeName
             * @return {?}
             */
            function (acc, storeName) {
                acc[storeName] = appState[storeName];
                return acc;
            }), {});
            devTools.send({ type: msg }, sortedAppState);
            return;
        }
        devTools.send({ type: msg }, appState);
    })));
    subs.push(devTools.subscribe((/**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        if (message.type === 'DISPATCH') {
            /** @type {?} */
            var payloadType = message.payload.type;
            if (payloadType === 'COMMIT') {
                devTools.init(appState);
                return;
            }
            if (message.state) {
                /** @type {?} */
                var rootState_1 = JSON.parse(message.state);
                var _loop_1 = function (i, keys) {
                    /** @type {?} */
                    var storeName = keys[i];
                    if (__stores__[storeName]) {
                        ((/** @type {?} */ (ngZoneOrOptions))).run((/**
                         * @return {?}
                         */
                        function () {
                            __stores__[storeName]._setState((/**
                             * @return {?}
                             */
                            function () { return rootState_1[storeName]; }), false);
                        }));
                    }
                };
                for (var i = 0, keys = Object.keys(rootState_1); i < keys.length; i++) {
                    _loop_1(i, keys);
                }
            }
        }
    })));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Each plugin that wants to add support for entities should extend this interface.
 * @abstract
 * @template State, P
 */
var  /**
 * Each plugin that wants to add support for entities should extend this interface.
 * @abstract
 * @template State, P
 */
EntityCollectionPlugin = /** @class */ (function () {
    function EntityCollectionPlugin(query, entityIds) {
        this.query = query;
        this.entityIds = entityIds;
        this.entities = new Map();
    }
    /**
     * Get the entity plugin instance.
     */
    /**
     * Get the entity plugin instance.
     * @protected
     * @param {?} id
     * @return {?}
     */
    EntityCollectionPlugin.prototype.getEntity = /**
     * Get the entity plugin instance.
     * @protected
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.entities.get(id);
    };
    /**
     * Whether the entity plugin exist.
     */
    /**
     * Whether the entity plugin exist.
     * @protected
     * @param {?} id
     * @return {?}
     */
    EntityCollectionPlugin.prototype.hasEntity = /**
     * Whether the entity plugin exist.
     * @protected
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.entities.has(id);
    };
    /**
     * Remove the entity plugin instance.
     */
    /**
     * Remove the entity plugin instance.
     * @protected
     * @param {?} id
     * @return {?}
     */
    EntityCollectionPlugin.prototype.removeEntity = /**
     * Remove the entity plugin instance.
     * @protected
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this.destroy(id);
        return this.entities.delete(id);
    };
    /**
     * Set the entity plugin instance.
     */
    /**
     * Set the entity plugin instance.
     * @protected
     * @param {?} id
     * @param {?} plugin
     * @return {?}
     */
    EntityCollectionPlugin.prototype.createEntity = /**
     * Set the entity plugin instance.
     * @protected
     * @param {?} id
     * @param {?} plugin
     * @return {?}
     */
    function (id, plugin) {
        return this.entities.set(id, plugin);
    };
    /**
     * If the user passes `entityIds` we take them; otherwise, we take all.
     */
    /**
     * If the user passes `entityIds` we take them; otherwise, we take all.
     * @protected
     * @return {?}
     */
    EntityCollectionPlugin.prototype.getIds = /**
     * If the user passes `entityIds` we take them; otherwise, we take all.
     * @protected
     * @return {?}
     */
    function () {
        return isUndefined(this.entityIds) ? this.query.getValue().ids : coerceArray(this.entityIds);
    };
    /**
     * When you call one of the plugin methods, you can pass id/ids or undefined which means all.
     */
    /**
     * When you call one of the plugin methods, you can pass id/ids or undefined which means all.
     * @protected
     * @param {?=} ids
     * @return {?}
     */
    EntityCollectionPlugin.prototype.resolvedIds = /**
     * When you call one of the plugin methods, you can pass id/ids or undefined which means all.
     * @protected
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        return isUndefined(ids) ? this.getIds() : coerceArray(ids);
    };
    /**
     * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.
     *
     * For example in your plugin you may do the following:
     *
     * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));
     */
    /**
     * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.
     *
     * For example in your plugin you may do the following:
     *
     * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));
     * @protected
     * @param {?} ids
     * @param {?=} actions
     * @return {?}
     */
    EntityCollectionPlugin.prototype.rebase = /**
     * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.
     *
     * For example in your plugin you may do the following:
     *
     * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));
     * @protected
     * @param {?} ids
     * @param {?=} actions
     * @return {?}
     */
    function (ids, actions) {
        var _this = this;
        if (actions === void 0) { actions = {}; }
        /**
         *
         * If the user passes `entityIds` & we have new ids check if we need to add/remove instances.
         *
         * This phase will be called only upon update.
         */
        if (toBoolean(ids)) {
            /**
             * Which means all
             */
            if (isUndefined(this.entityIds)) {
                for (var i = 0, len = ids.length; i < len; i++) {
                    /** @type {?} */
                    var entityId = ids[i];
                    if (this.hasEntity(entityId) === false) {
                        isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);
                        /** @type {?} */
                        var plugin = this.instantiatePlugin(entityId);
                        this.entities.set(entityId, plugin);
                        isFunction(actions.afterAdd) && actions.afterAdd(plugin);
                    }
                }
                this.entities.forEach((/**
                 * @param {?} plugin
                 * @param {?} entityId
                 * @return {?}
                 */
                function (plugin, entityId) {
                    if (ids.indexOf(entityId) === -1) {
                        isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);
                        _this.removeEntity(entityId);
                    }
                }));
            }
            else {
                /**
                 * Which means the user passes specific ids
                 * @type {?}
                 */
                var _ids = coerceArray(this.entityIds);
                for (var i = 0, len = _ids.length; i < len; i++) {
                    /** @type {?} */
                    var entityId = _ids[i];
                    /** The Entity in current ids and doesn't exist, add it. */
                    if (ids.indexOf(entityId) > -1 && this.hasEntity(entityId) === false) {
                        isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);
                        /** @type {?} */
                        var plugin = this.instantiatePlugin(entityId);
                        this.entities.set(entityId, plugin);
                        isFunction(actions.afterAdd) && actions.afterAdd(plugin);
                    }
                    else {
                        this.entities.forEach((/**
                         * @param {?} plugin
                         * @param {?} entityId
                         * @return {?}
                         */
                        function (plugin, entityId) {
                            /** The Entity not in current ids and exists, remove it. */
                            if (ids.indexOf(entityId) === -1 && _this.hasEntity(entityId) === true) {
                                isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);
                                _this.removeEntity(entityId);
                            }
                        }));
                    }
                }
            }
        }
        else {
            /**
             * Otherwise, start with the provided ids or all.
             */
            this.getIds().forEach((/**
             * @param {?} id
             * @return {?}
             */
            function (id) {
                if (!_this.hasEntity(id))
                    _this.createEntity(id, _this.instantiatePlugin(id));
            }));
        }
    };
    /**
     * Listen for add/remove entities.
     */
    /**
     * Listen for add/remove entities.
     * @protected
     * @return {?}
     */
    EntityCollectionPlugin.prototype.selectIds = /**
     * Listen for add/remove entities.
     * @protected
     * @return {?}
     */
    function () {
        return this.query.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.ids; }));
    };
    /**
     * Base method for activation, you can override it if you need to.
     */
    /**
     * Base method for activation, you can override it if you need to.
     * @protected
     * @param {?=} ids
     * @return {?}
     */
    EntityCollectionPlugin.prototype.activate = /**
     * Base method for activation, you can override it if you need to.
     * @protected
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.rebase(ids);
    };
    /**
     * Loop over each id and invoke the plugin method.
     */
    /**
     * Loop over each id and invoke the plugin method.
     * @protected
     * @param {?} ids
     * @param {?} cb
     * @return {?}
     */
    EntityCollectionPlugin.prototype.forEachId = /**
     * Loop over each id and invoke the plugin method.
     * @protected
     * @param {?} ids
     * @param {?} cb
     * @return {?}
     */
    function (ids, cb) {
        /** @type {?} */
        var _ids = this.resolvedIds(ids);
        for (var i = 0, len = _ids.length; i < len; i++) {
            /** @type {?} */
            var id = _ids[i];
            if (this.hasEntity(id)) {
                cb(this.getEntity(id));
            }
        }
    };
    return EntityCollectionPlugin;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template State
 */
var  /**
 * @template State
 */
StateHistoryPlugin = /** @class */ (function (_super) {
    __extends(StateHistoryPlugin, _super);
    function StateHistoryPlugin(query, params, _entityId) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this, query, {
            resetFn: (/**
             * @return {?}
             */
            function () { return _this.clear(); })
        }) || this;
        _this.query = query;
        _this.params = params;
        _this._entityId = _entityId;
        /**
         * Allow skipping an update from outside
         */
        _this.skip = false;
        _this.history = {
            past: [],
            present: null,
            future: []
        };
        /**
         * Skip the update when redo/undo
         */
        _this.skipUpdate = false;
        params.maxAge = !!params.maxAge ? params.maxAge : 10;
        params.comparator = params.comparator || ((/**
         * @return {?}
         */
        function () { return true; }));
        _this.activate();
        return _this;
    }
    Object.defineProperty(StateHistoryPlugin.prototype, "hasPast$", {
        /**
         * Observable stream representing whether the history plugin has an available past
         *
         */
        get: /**
         * Observable stream representing whether the history plugin has an available past
         *
         * @return {?}
         */
        function () {
            return this._hasPast$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateHistoryPlugin.prototype, "hasFuture$", {
        /**
         * Observable stream representing whether the history plugin has an available future
         *
         */
        get: /**
         * Observable stream representing whether the history plugin has an available future
         *
         * @return {?}
         */
        function () {
            return this._hasFuture$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateHistoryPlugin.prototype, "hasPast", {
        get: /**
         * @return {?}
         */
        function () {
            return this.history.past.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateHistoryPlugin.prototype, "hasFuture", {
        get: /**
         * @return {?}
         */
        function () {
            return this.history.future.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateHistoryPlugin.prototype, "property", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.params.watchProperty;
        },
        enumerable: true,
        configurable: true
    });
    /* Updates the hasPast$ hasFuture$ observables*/
    /* Updates the hasPast$ hasFuture$ observables*/
    /**
     * @private
     * @return {?}
     */
    StateHistoryPlugin.prototype.updateHasHistory = /* Updates the hasPast$ hasFuture$ observables*/
    /**
     * @private
     * @return {?}
     */
    function () {
        this.hasFutureSubject.next(this.hasFuture);
        this.hasPastSubject.next(this.hasPast);
    };
    /**
     * @return {?}
     */
    StateHistoryPlugin.prototype.activate = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasPastSubject = new BehaviorSubject(false);
        this._hasPast$ = this.hasPastSubject.asObservable().pipe(distinctUntilChanged());
        this.hasFutureSubject = new BehaviorSubject(false);
        this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(distinctUntilChanged());
        this.history.present = this.getSource(this._entityId, this.property);
        this.subscription = ((/** @type {?} */ (this)))
            .selectSource(this._entityId, this.property)
            .pipe(pairwise())
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = __read(_a, 2), past = _b[0], present = _b[1];
            if (_this.skip) {
                _this.skip = false;
                return;
            }
            /**
             *  comparator: (prev, current) => isEqual(prev, current) === false
             * @type {?}
             */
            var shouldUpdate = _this.params.comparator(past, present);
            if (!_this.skipUpdate && shouldUpdate) {
                if (_this.history.past.length === _this.params.maxAge) {
                    _this.history.past = _this.history.past.slice(1);
                }
                _this.history.past = __spread(_this.history.past, [past]);
                _this.history.present = present;
                _this.updateHasHistory();
            }
        }));
    };
    /**
     * @return {?}
     */
    StateHistoryPlugin.prototype.undo = /**
     * @return {?}
     */
    function () {
        if (this.history.past.length > 0) {
            var _a = this.history, past = _a.past, present = _a.present;
            /** @type {?} */
            var previous = past[past.length - 1];
            this.history.past = past.slice(0, past.length - 1);
            this.history.present = previous;
            this.history.future = __spread([present], this.history.future);
            this.update();
        }
    };
    /**
     * @return {?}
     */
    StateHistoryPlugin.prototype.redo = /**
     * @return {?}
     */
    function () {
        if (this.history.future.length > 0) {
            var _a = this.history, past = _a.past, present = _a.present;
            /** @type {?} */
            var next = this.history.future[0];
            /** @type {?} */
            var newFuture = this.history.future.slice(1);
            this.history.past = __spread(past, [present]);
            this.history.present = next;
            this.history.future = newFuture;
            this.update('Redo');
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    StateHistoryPlugin.prototype.jumpToPast = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < 0 || index >= this.history.past.length)
            return;
        var _a = this.history, past = _a.past, future = _a.future, present = _a.present;
        /**
         *
         * const past = [1, 2, 3, 4, 5];
         * const present = 6;
         * const future = [7, 8, 9];
         * const index = 2;
         *
         * newPast = past.slice(0, index) = [1, 2];
         * newPresent = past[index] = 3;
         * newFuture = [...past.slice(index + 1),present, ...future] = [4, 5, 6, 7, 8, 9];
         *
         * @type {?}
         */
        var newPast = past.slice(0, index);
        /** @type {?} */
        var newFuture = __spread(past.slice(index + 1), [present], future);
        /** @type {?} */
        var newPresent = past[index];
        this.history.past = newPast;
        this.history.present = newPresent;
        this.history.future = newFuture;
        this.update();
    };
    /**
     * @param {?} index
     * @return {?}
     */
    StateHistoryPlugin.prototype.jumpToFuture = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < 0 || index >= this.history.future.length)
            return;
        var _a = this.history, past = _a.past, future = _a.future, present = _a.present;
        /**
         *
         * const past = [1, 2, 3, 4, 5];
         * const present = 6;
         * const future = [7, 8, 9, 10]
         * const index = 1
         *
         * newPast = [...past, present, ...future.slice(0, index) = [1, 2, 3, 4, 5, 6, 7];
         * newPresent = future[index] = 8;
         * newFuture = futrue.slice(index+1) = [9, 10];
         *
         * @type {?}
         */
        var newPast = __spread(past, [present], future.slice(0, index));
        /** @type {?} */
        var newPresent = future[index];
        /** @type {?} */
        var newFuture = future.slice(index + 1);
        this.history.past = newPast;
        this.history.present = newPresent;
        this.history.future = newFuture;
        this.update('Redo');
    };
    /**
     *
     * jump n steps in the past or forward
     *
     */
    /**
     *
     * jump n steps in the past or forward
     *
     * @param {?} n
     * @return {?}
     */
    StateHistoryPlugin.prototype.jump = /**
     *
     * jump n steps in the past or forward
     *
     * @param {?} n
     * @return {?}
     */
    function (n) {
        if (n > 0)
            return this.jumpToFuture(n - 1);
        if (n < 0)
            return this.jumpToPast(this.history.past.length + n);
    };
    /**
     * Clear the history
     *
     * @param customUpdateFn Callback function for only clearing part of the history
     *
     * @example
     *
     * stateHistory.clear((history) => {
     *  return {
     *    past: history.past,
     *    present: history.present,
     *    future: []
     *  };
     * });
     */
    /**
     * Clear the history
     *
     * \@example
     *
     * stateHistory.clear((history) => {
     *  return {
     *    past: history.past,
     *    present: history.present,
     *    future: []
     *  };
     * });
     * @param {?=} customUpdateFn Callback function for only clearing part of the history
     *
     * @return {?}
     */
    StateHistoryPlugin.prototype.clear = /**
     * Clear the history
     *
     * \@example
     *
     * stateHistory.clear((history) => {
     *  return {
     *    past: history.past,
     *    present: history.present,
     *    future: []
     *  };
     * });
     * @param {?=} customUpdateFn Callback function for only clearing part of the history
     *
     * @return {?}
     */
    function (customUpdateFn) {
        this.history = isFunction(customUpdateFn)
            ? customUpdateFn(this.history)
            : {
                past: [],
                present: null,
                future: []
            };
        this.updateHasHistory();
    };
    /**
     * @param {?=} clearHistory
     * @return {?}
     */
    StateHistoryPlugin.prototype.destroy = /**
     * @param {?=} clearHistory
     * @return {?}
     */
    function (clearHistory) {
        if (clearHistory === void 0) { clearHistory = false; }
        if (clearHistory) {
            this.clear();
        }
        this.subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    StateHistoryPlugin.prototype.ignoreNext = /**
     * @return {?}
     */
    function () {
        this.skip = true;
    };
    /**
     * @private
     * @param {?=} action
     * @return {?}
     */
    StateHistoryPlugin.prototype.update = /**
     * @private
     * @param {?=} action
     * @return {?}
     */
    function (action$$1) {
        if (action$$1 === void 0) { action$$1 = 'Undo'; }
        this.skipUpdate = true;
        logAction("@StateHistory - " + action$$1);
        this.updateStore(this.history.present, this._entityId, this.property);
        this.updateHasHistory();
        this.skipUpdate = false;
    };
    return StateHistoryPlugin;
}(AkitaPlugin));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template State, P
 */
var  /**
 * @template State, P
 */
EntityStateHistoryPlugin = /** @class */ (function (_super) {
    __extends(EntityStateHistoryPlugin, _super);
    function EntityStateHistoryPlugin(query, params) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this, query, params.entityIds) || this;
        _this.query = query;
        _this.params = params;
        params.maxAge = toBoolean(params.maxAge) ? params.maxAge : 10;
        _this.activate();
        _this.selectIds()
            .pipe(skip(1))
            .subscribe((/**
         * @param {?} ids
         * @return {?}
         */
        function (ids) { return _this.activate(ids); }));
        return _this;
    }
    /**
     * @param {?=} ids
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.redo = /**
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.redo(); }));
    };
    /**
     * @param {?=} ids
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.undo = /**
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.undo(); }));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.hasPast = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (this.hasEntity(id)) {
            return this.getEntity(id).hasPast;
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.hasFuture = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (this.hasEntity(id)) {
            return this.getEntity(id).hasFuture;
        }
    };
    /**
     * @param {?} ids
     * @param {?} index
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.jumpToFuture = /**
     * @param {?} ids
     * @param {?} index
     * @return {?}
     */
    function (ids, index) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.jumpToFuture(index); }));
    };
    /**
     * @param {?} ids
     * @param {?} index
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.jumpToPast = /**
     * @param {?} ids
     * @param {?} index
     * @return {?}
     */
    function (ids, index) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.jumpToPast(index); }));
    };
    /**
     * @param {?=} ids
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.clear = /**
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.clear(); }));
    };
    /**
     * @param {?=} ids
     * @param {?=} clearHistory
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.destroy = /**
     * @param {?=} ids
     * @param {?=} clearHistory
     * @return {?}
     */
    function (ids, clearHistory) {
        if (clearHistory === void 0) { clearHistory = false; }
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.destroy(clearHistory); }));
    };
    /**
     * @param {?=} ids
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.ignoreNext = /**
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.ignoreNext(); }));
    };
    /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    EntityStateHistoryPlugin.prototype.instantiatePlugin = /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return (/** @type {?} */ (new StateHistoryPlugin(this.query, this.params, id)));
    };
    return EntityStateHistoryPlugin;
}(EntityCollectionPlugin));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var dirtyCheckDefaultParams = {
    comparator: (/**
     * @param {?} head
     * @param {?} current
     * @return {?}
     */
    function (head, current) { return JSON.stringify(head) !== JSON.stringify(current); })
};
/**
 * @param {?} nestedObj
 * @param {?} path
 * @return {?}
 */
function getNestedPath(nestedObj, path) {
    /** @type {?} */
    var pathAsArray = path.split('.');
    return pathAsArray.reduce((/**
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    function (obj, key) { return (obj && obj[key] !== 'undefined' ? obj[key] : undefined); }), nestedObj);
}
/**
 * @template State
 */
var  /**
 * @template State
 */
DirtyCheckPlugin = /** @class */ (function (_super) {
    __extends(DirtyCheckPlugin, _super);
    function DirtyCheckPlugin(query, params, _entityId) {
        var _this = _super.call(this, query) || this;
        _this.query = query;
        _this.params = params;
        _this._entityId = _entityId;
        _this.dirty = new BehaviorSubject(false);
        _this.active = false;
        _this._reset = new Subject();
        _this.isDirty$ = _this.dirty.asObservable().pipe(distinctUntilChanged());
        _this.reset$ = _this._reset.asObservable();
        _this.params = __assign({}, dirtyCheckDefaultParams, params);
        if (_this.params.watchProperty) {
            /** @type {?} */
            var watchProp = (/** @type {?} */ (coerceArray(_this.params.watchProperty)));
            if (query instanceof QueryEntity && watchProp.includes('entities') && !watchProp.includes('ids')) {
                watchProp.push('ids');
            }
            _this.params.watchProperty = watchProp;
        }
        return _this;
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    DirtyCheckPlugin.prototype.reset = /**
     * @param {?=} params
     * @return {?}
     */
    function (params) {
        if (params === void 0) { params = {}; }
        /** @type {?} */
        var currentValue = this.head;
        if (isFunction(params.updateFn)) {
            if (this.isEntityBased(this._entityId)) {
                currentValue = params.updateFn(this.head, ((/** @type {?} */ (this.getQuery()))).getEntity(this._entityId));
            }
            else {
                currentValue = params.updateFn(this.head, ((/** @type {?} */ (this.getQuery()))).getValue());
            }
        }
        logAction("@DirtyCheck - Revert");
        this.updateStore(currentValue, this._entityId);
        this._reset.next();
    };
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    DirtyCheckPlugin.prototype.setHead = /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    function () {
        if (!(/** @type {?} */ (this)).active) {
            (/** @type {?} */ (this)).activate();
            (/** @type {?} */ (this)).active = true;
        }
        else {
            (/** @type {?} */ (this)).head = (/** @type {?} */ (this))._getHead();
        }
        (/** @type {?} */ (this)).updateDirtiness(false);
        return (/** @type {?} */ (this));
    };
    /**
     * @return {?}
     */
    DirtyCheckPlugin.prototype.isDirty = /**
     * @return {?}
     */
    function () {
        return !!this.dirty.value;
    };
    /**
     * @return {?}
     */
    DirtyCheckPlugin.prototype.hasHead = /**
     * @return {?}
     */
    function () {
        return !!this.getHead();
    };
    /**
     * @return {?}
     */
    DirtyCheckPlugin.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.head = null;
        this.subscription && this.subscription.unsubscribe();
        this._reset && this._reset.complete();
    };
    /**
     * @param {?} path
     * @return {?}
     */
    DirtyCheckPlugin.prototype.isPathDirty = /**
     * @param {?} path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var head = this.getHead();
        /** @type {?} */
        var current = ((/** @type {?} */ (this.getQuery()))).getValue();
        /** @type {?} */
        var currentPathValue = getNestedPath(current, path);
        /** @type {?} */
        var headPathValue = getNestedPath(head, path);
        return this.params.comparator(currentPathValue, headPathValue);
    };
    /**
     * @protected
     * @return {?}
     */
    DirtyCheckPlugin.prototype.getHead = /**
     * @protected
     * @return {?}
     */
    function () {
        return this.head;
    };
    /**
     * @private
     * @return {?}
     */
    DirtyCheckPlugin.prototype.activate = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.head = this._getHead();
        /**
         * if we are tracking specific properties select only the relevant ones
         * @type {?}
         */
        var source = this.params.watchProperty
            ? ((/** @type {?} */ (this.params.watchProperty))).map((/**
             * @param {?} prop
             * @return {?}
             */
            function (prop) {
                return _this.query
                    .select((/**
                 * @param {?} state
                 * @return {?}
                 */
                function (state) { return state[prop]; }))
                    .pipe(map((/**
                 * @param {?} val
                 * @return {?}
                 */
                function (val) { return ({
                    val: val,
                    __akitaKey: prop
                }); })));
            }))
            : [this.selectSource(this._entityId)];
        this.subscription = combineLatest.apply(void 0, __spread(source)).pipe(skip(1))
            .subscribe((/**
         * @param {?} currentState
         * @return {?}
         */
        function (currentState) {
            if (isUndefined(_this.head))
                return;
            /**
             * __akitaKey is used to determine if we are tracking a specific property or a store change
             * @type {?}
             */
            var isChange = currentState.some((/**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                /** @type {?} */
                var head = state.__akitaKey ? _this.head[(/** @type {?} */ (state.__akitaKey))] : _this.head;
                /** @type {?} */
                var compareTo = state.__akitaKey ? state.val : state;
                return _this.params.comparator(head, compareTo);
            }));
            _this.updateDirtiness(isChange);
        }));
    };
    /**
     * @private
     * @param {?} isDirty
     * @return {?}
     */
    DirtyCheckPlugin.prototype.updateDirtiness = /**
     * @private
     * @param {?} isDirty
     * @return {?}
     */
    function (isDirty) {
        this.dirty.next(isDirty);
    };
    /**
     * @private
     * @return {?}
     */
    DirtyCheckPlugin.prototype._getHead = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var head = this.getSource(this._entityId);
        if (this.params.watchProperty) {
            head = this.getWatchedValues((/** @type {?} */ (head)));
        }
        return head;
    };
    /**
     * @private
     * @param {?} source
     * @return {?}
     */
    DirtyCheckPlugin.prototype.getWatchedValues = /**
     * @private
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return ((/** @type {?} */ (this.params.watchProperty))).reduce((/**
         * @param {?} watched
         * @param {?} prop
         * @return {?}
         */
        function (watched, prop) {
            watched[prop] = source[prop];
            return watched;
        }), (/** @type {?} */ ({})));
    };
    return DirtyCheckPlugin;
}(AkitaPlugin));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template State, P
 */
var  /**
 * @template State, P
 */
EntityDirtyCheckPlugin = /** @class */ (function (_super) {
    __extends(EntityDirtyCheckPlugin, _super);
    function EntityDirtyCheckPlugin(query, params) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this, query, params.entityIds) || this;
        _this.query = query;
        _this.params = params;
        _this._someDirty = new Subject();
        _this.someDirty$ = merge(_this.query.select((/**
         * @param {?} state
         * @return {?}
         */
        function (state) { return state.entities; })), _this._someDirty.asObservable()).pipe(auditTime(0), map((/**
         * @return {?}
         */
        function () { return _this.checkSomeDirty(); })));
        _this.params = __assign({}, dirtyCheckDefaultParams, params);
        // TODO lazy activate?
        _this.activate();
        _this.selectIds()
            .pipe(skip(1))
            .subscribe((/**
         * @param {?} ids
         * @return {?}
         */
        function (ids) {
            _super.prototype.rebase.call(_this, ids, { afterAdd: (/**
                 * @param {?} plugin
                 * @return {?}
                 */
                function (plugin) { return plugin.setHead(); }) });
        }));
        return _this;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} ids
     * @return {THIS}
     */
    EntityDirtyCheckPlugin.prototype.setHead = /**
     * @template THIS
     * @this {THIS}
     * @param {?=} ids
     * @return {THIS}
     */
    function (ids) {
        if ((/** @type {?} */ (this)).params.entityIds && ids) {
            /** @type {?} */
            var toArray_1 = (/** @type {?} */ (coerceArray(ids)));
            /** @type {?} */
            var someAreWatched = coerceArray((/** @type {?} */ (this)).params.entityIds).some((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return toArray_1.indexOf(id) > -1; }));
            if (someAreWatched === false) {
                return (/** @type {?} */ (this));
            }
        }
        (/** @type {?} */ (this)).forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.setHead(); }));
        (/** @type {?} */ (this))._someDirty.next();
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.hasHead = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (this.entities.has(id)) {
            /** @type {?} */
            var entity = this.getEntity(id);
            return entity.hasHead();
        }
        return false;
    };
    /**
     * @param {?=} ids
     * @param {?=} params
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.reset = /**
     * @param {?=} ids
     * @param {?=} params
     * @return {?}
     */
    function (ids, params) {
        if (params === void 0) { params = {}; }
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.reset(params); }));
    };
    /**
     * @param {?} id
     * @param {?=} asObservable
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.isDirty = /**
     * @param {?} id
     * @param {?=} asObservable
     * @return {?}
     */
    function (id, asObservable) {
        if (asObservable === void 0) { asObservable = true; }
        if (this.entities.has(id)) {
            /** @type {?} */
            var entity = this.getEntity(id);
            return asObservable ? entity.isDirty$ : entity.isDirty();
        }
        return false;
    };
    /**
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.someDirty = /**
     * @return {?}
     */
    function () {
        return this.checkSomeDirty();
    };
    /**
     * @param {?} id
     * @param {?} path
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.isPathDirty = /**
     * @param {?} id
     * @param {?} path
     * @return {?}
     */
    function (id, path) {
        if (this.entities.has(id)) {
            /** @type {?} */
            var head = ((/** @type {?} */ (this.getEntity(id)))).getHead();
            /** @type {?} */
            var current = this.query.getEntity(id);
            /** @type {?} */
            var currentPathValue = getNestedPath(current, path);
            /** @type {?} */
            var headPathValue = getNestedPath(head, path);
            return this.params.comparator(currentPathValue, headPathValue);
        }
        return null;
    };
    /**
     * @param {?=} ids
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.destroy = /**
     * @param {?=} ids
     * @return {?}
     */
    function (ids) {
        this.forEachId(ids, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.destroy(); }));
        /** complete only when the plugin destroys */
        if (!ids) {
            this._someDirty.complete();
        }
    };
    /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.instantiatePlugin = /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return (/** @type {?} */ (new DirtyCheckPlugin(this.query, this.params, id)));
    };
    /**
     * @private
     * @return {?}
     */
    EntityDirtyCheckPlugin.prototype.checkSomeDirty = /**
     * @private
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var entitiesIds = this.resolvedIds();
        try {
            for (var entitiesIds_1 = __values(entitiesIds), entitiesIds_1_1 = entitiesIds_1.next(); !entitiesIds_1_1.done; entitiesIds_1_1 = entitiesIds_1.next()) {
                var id = entitiesIds_1_1.value;
                if (this.getEntity(id).isDirty()) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (entitiesIds_1_1 && !entitiesIds_1_1.done && (_a = entitiesIds_1.return)) _a.call(entitiesIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    return EntityDirtyCheckPlugin;
}(EntityCollectionPlugin));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Generate random guid
 *
 * \@example
 *
 * {
 *   id: guid()
 * }
 *
 * @return {?}
 */
function guid() {
    return 'xxxxxx4xyx'.replace(/[xy]/g, (/**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var r = (Math.random() * 16) | 0;
        /** @type {?} */
        var v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @template E
 * @param {?} entities
 * @param {?=} idKey
 * @return {?}
 */
function toEntitiesIds(entities, idKey) {
    if (idKey === void 0) { idKey = DEFAULT_ID_KEY; }
    var e_1, _a;
    /** @type {?} */
    var ids = [];
    try {
        for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
            var entity = entities_1_1.value;
            ids.push(entity[idKey]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return ids;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Reset stores back to their initial state
 *
 * \@example
 *
 * resetStores()
 * resetStores({
 *   exclude: ['auth']
 * })
 * @param {?=} options
 * @return {?}
 */
function resetStores(options) {
    /** @type {?} */
    var defaults = {
        exclude: []
    };
    options = Object.assign({}, defaults, options);
    /** @type {?} */
    var stores = Object.keys(__stores__);
    applyTransaction((/**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var stores_1 = __values(stores), stores_1_1 = stores_1.next(); !stores_1_1.done; stores_1_1 = stores_1.next()) {
                var store = stores_1_1.value;
                /** @type {?} */
                var s = __stores__[store];
                if (!options.exclude) {
                    s.reset();
                }
                else {
                    if (options.exclude.indexOf(s.storeName) === -1) {
                        s.reset();
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (stores_1_1 && !stores_1_1.done && (_a = stores_1.return)) _a.call(stores_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} value
 * @return {?}
 */
function isNumber(value) {
    return !isArray(value) && value - parseFloat(value) + 1 >= 0;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var StoreActions = {
    Update: 0,
    AddEntities: 1,
    SetEntities: 2,
    UpdateEntities: 3,
    RemoveEntities: 4,
    UpsertEntities: 5,
};
StoreActions[StoreActions.Update] = 'Update';
StoreActions[StoreActions.AddEntities] = 'AddEntities';
StoreActions[StoreActions.SetEntities] = 'SetEntities';
StoreActions[StoreActions.UpdateEntities] = 'UpdateEntities';
StoreActions[StoreActions.RemoveEntities] = 'RemoveEntities';
StoreActions[StoreActions.UpsertEntities] = 'UpsertEntities';
/**
 * @template EntityOrState
 * @param {?} storeName
 * @param {?} action
 * @param {?} params
 * @return {?}
 */
function runStoreAction(storeName, action, params) {
    /** @type {?} */
    var store = __stores__[storeName];
    if (isNil(store)) {
        throw new AkitaError(storeName + " doesn't exist");
    }
    switch (action) {
        case StoreActions.SetEntities: {
            var payload = (/** @type {?} */ (params)).payload;
            ((/** @type {?} */ (store))).set(payload.data);
            return;
        }
        case StoreActions.AddEntities: {
            var payload = (/** @type {?} */ (params)).payload;
            ((/** @type {?} */ (store))).add(payload.data, payload.params);
            return;
        }
        case StoreActions.UpdateEntities: {
            var payload = (/** @type {?} */ (params)).payload;
            ((/** @type {?} */ (store))).update(payload.entityIds, payload.data);
            return;
        }
        case StoreActions.RemoveEntities: {
            var payload = (/** @type {?} */ (params)).payload;
            ((/** @type {?} */ (store))).remove(payload.entityIds);
            return;
        }
        case StoreActions.UpsertEntities: {
            var payload = (/** @type {?} */ (params)).payload;
            if (payload.entityIds) {
                ((/** @type {?} */ (store))).upsert(payload.entityIds, payload.data);
            }
            else if (Array.isArray(payload.data)) {
                ((/** @type {?} */ (store))).upsertMany(payload.data);
            }
            else {
                ((/** @type {?} */ (store))).upsertMany([payload.data]);
            }
            return;
        }
        case StoreActions.Update: {
            var payload = (/** @type {?} */ (params)).payload;
            ((/** @type {?} */ (store))).update(payload.data);
            return;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Root, Entity
 * @param {?} keyOrRoot
 * @param {?} predicateOrIds
 * @param {?} obj
 * @param {?=} idKey
 * @return {?}
 */
function arrayUpdate(keyOrRoot, predicateOrIds, obj, idKey) {
    if (idKey === void 0) { idKey = DEFAULT_ID_KEY; }
    /** @type {?} */
    var condition;
    if (isFunction(predicateOrIds)) {
        condition = predicateOrIds;
    }
    else {
        /** @type {?} */
        var ids_1 = coerceArray(predicateOrIds);
        condition = (/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return ids_1.includes(isObject(item) ? item[idKey] : item) === true; });
    }
    /** @type {?} */
    var updateFn = (/**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        return state.map((/**
         * @param {?} entity
         * @return {?}
         */
        function (entity) {
            if (condition(entity) === true) {
                return isObject(entity)
                    ? __assign({}, entity, obj) : obj;
            }
            return entity;
        }));
    });
    if (isArray(keyOrRoot)) {
        return updateFn(keyOrRoot);
    }
    return (/**
     * @param {?} root
     * @return {?}
     */
    function (root) {
        var _a;
        return _a = {},
            _a[(/** @type {?} */ (keyOrRoot))] = updateFn(root[keyOrRoot]),
            _a;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Root, Entity
 * @param {?} keyOrRoot
 * @param {?} newEntity
 * @param {?=} options
 * @return {?}
 */
function arrayAdd(keyOrRoot, newEntity, options) {
    if (options === void 0) { options = {}; }
    /** @type {?} */
    var newEntities = coerceArray(newEntity);
    /** @type {?} */
    var addFn = (/**
     * @param {?} state
     * @return {?}
     */
    function (state) { return (options.prepend ? __spread(newEntities, (state || [])) : __spread((state || []), newEntities)); });
    if (isArray(keyOrRoot)) {
        return addFn(keyOrRoot);
    }
    return (/**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        var _a;
        return _a = {},
            _a[(/** @type {?} */ (keyOrRoot))] = addFn(state[keyOrRoot]),
            _a;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Upsert item in a collection
 *
 * \@example
 *
 *
 * store.update(1, entity => ({
 *   comments: arrayUpsert(entity.comments, 1, { name: 'newComment' })
 * }))
 * @template Root
 * @param {?} arr
 * @param {?} id
 * @param {?} obj
 * @param {?=} idKey
 * @return {?}
 */
function arrayUpsert(arr, id, obj, idKey) {
    if (idKey === void 0) { idKey = DEFAULT_ID_KEY; }
    var _a;
    /** @type {?} */
    var entityIsObject = isObject(obj);
    /** @type {?} */
    var entityExists = arr.some((/**
     * @param {?} entity
     * @return {?}
     */
    function (entity) { return (entityIsObject ? entity[idKey] === id : entity === id); }));
    if (entityExists) {
        return arrayUpdate(arr, id, obj, idKey);
    }
    else {
        return arrayAdd(arr, entityIsObject ? __assign({}, obj, (_a = {}, _a[idKey] = id, _a)) : obj);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @internal
/**
 * @param {?} pred
 * @return {?}
 */
function not(pred) {
    return (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return !pred.apply(void 0, __spread(args));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Root, Entity
 * @param {?} keyOrRoot
 * @param {?} identifier
 * @param {?=} idKey
 * @return {?}
 */
function arrayRemove(keyOrRoot, identifier, idKey) {
    if (idKey === void 0) { idKey = DEFAULT_ID_KEY; }
    /** @type {?} */
    var identifiers;
    /** @type {?} */
    var filterFn;
    if (isFunction(identifier)) {
        filterFn = not(identifier);
    }
    else {
        identifiers = coerceArray((/** @type {?} */ (identifier)));
        filterFn = (/**
         * @param {?} current
         * @return {?}
         */
        function (current) {
            return identifiers.includes(isObject(current) ? current[idKey] : current) === false;
        });
    }
    if (Array.isArray(keyOrRoot)) {
        return keyOrRoot.filter(filterFn);
    }
    return (/**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        var _a;
        return _a = {},
            _a[(/** @type {?} */ (keyOrRoot))] = state[keyOrRoot].filter(filterFn),
            _a;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template State
 * @param {?} initialState
 * @param {?} options
 * @return {?}
 */
function createStore(initialState, options) {
    return new Store(initialState, options);
}
/**
 * @template State
 * @param {?} store
 * @return {?}
 */
function createQuery(store) {
    return new Query(store);
}
/**
 * @template State
 * @param {?} initialState
 * @param {?} options
 * @return {?}
 */
function createEntityStore(initialState, options) {
    return new EntityStore(initialState, options);
}
/**
 * @template State
 * @param {?} store
 * @param {?=} options
 * @return {?}
 */
function createEntityQuery(store, options) {
    if (options === void 0) { options = {}; }
    return new QueryEntity(store, options);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * Helper function for checking if we have data in cache
 *
 * export class ProductsService {
 *   constructor(private productsStore: ProductsStore) {}
 *   get(): Observable<void> {
 *     const request = this.http.get().pipe(
 *       tap(this.productsStore.set(response))
 *     );
 *
 *     return cacheable(this.productsStore, request);
 *   }
 * }
 * @template T
 * @param {?} store
 * @param {?} request$
 * @param {?=} options
 * @return {?}
 */
function cacheable(store, request$, options) {
    if (options === void 0) { options = { emitNext: false }; }
    if (store._cache().value) {
        return options.emitNext ? of(undefined) : EMPTY;
    }
    return request$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template R
 * @param {?} observables
 * @return {?}
 */
function combineQueries(observables) {
    return (/** @type {?} */ (combineLatest(observables).pipe(auditTime(0))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template S
 */
var  /**
 * @abstract
 * @template S
 */
EntityService = /** @class */ (function () {
    function EntityService() {
    }
    return EntityService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} store
 * @return {?}
 */
function setLoading(store) {
    return (/**
     * @template T
     * @param {?} source
     * @return {?}
     */
    function (source) {
        return defer((/**
         * @return {?}
         */
        function () {
            store.setLoading(true);
            return source.pipe(finalize((/**
             * @return {?}
             */
            function () { return store.setLoading(false); })));
        }));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { EntityStore, EntityUIStore, QueryEntity, EntityUIQuery, Query, Store, applyTransaction, transaction, commit, endBatch, isTransactionInProcess, startBatch, transactionManager, withTransaction, filterNil, DEFAULT_ID_KEY, action, setAction, setSkipAction, logAction, currentAction, resetCustomAction, SnapshotManager, snapshotManager, configKey, StoreConfig, QueryConfig, queryConfigKey, akitaConfig, getAkitaConfig, compareValues, Order, AkitaPlugin, Paginator, PaginatorPlugin, PersistNgFormPlugin, persistState, selectPersistStateInit, akitaDevtools, EntityCollectionPlugin, StateHistoryPlugin, EntityStateHistoryPlugin, dirtyCheckDefaultParams, DirtyCheckPlugin, getNestedPath, EntityDirtyCheckPlugin, guid, setEntities, isEntityState, toEntitiesIds, toEntitiesObject, hasEntity, hasActiveState, getExitingActives, isMultiActiveState, resolveActiveEntity, isEmpty, coerceArray, updateEntities, removeEntities, removeAllEntities, getInitialEntitiesState, getActiveEntities, addEntities, resetStores, isObject, isPlainObject, isFunction, isArray, toBoolean, isUndefined, isNil, isString, isNumber, isDefined, setValue, getValue, sortByOptions, entitiesToArray, entitiesToMap, __stores__, isDev, enableAkitaProdMode, __DEV__, isNotBrowser, runStoreAction, StoreActions, arrayUpdate, arrayAdd, arrayUpsert, arrayFind, distinctUntilArrayItemChanged, find, arrayRemove, createEntityQuery, createEntityStore, createQuery, createStore, cacheable, combineQueries, EntityService, setLoading, EntityActions, dispatchDeleted, dispatchAdded, dispatchUpdate, $$deleteStore, $$addStore, $$updateStore, isBrowser as a };

//# sourceMappingURL=datorama-akita.js.map