/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isFunction } from './isFunction';
import { hasEntity } from './hasEntity';
import { isPlainObject } from './isPlainObject';
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
export function updateEntities(_a) {
    var state = _a.state, ids = _a.ids, idKey = _a.idKey, newStateOrFn = _a.newStateOrFn, preUpdateEntity = _a.preUpdateEntity, producerFn = _a.producerFn;
    var e_1, _b;
    /** @type {?} */
    var updatedEntities = {};
    /** @type {?} */
    var isUpdatingIdKey = false;
    /** @type {?} */
    var idToUpdate;
    try {
        for (var ids_1 = tslib_1.__values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            // if the entity doesn't exist don't do anything
            if (hasEntity(state.entities, id) === false) {
                continue;
            }
            /** @type {?} */
            var oldEntity = state.entities[id];
            /** @type {?} */
            var newState = void 0;
            if (isFunction(newStateOrFn)) {
                newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);
            }
            else {
                newState = newStateOrFn;
            }
            /** @type {?} */
            var isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];
            /** @type {?} */
            var newEntity = void 0;
            idToUpdate = id;
            if (isIdChanged) {
                isUpdatingIdKey = true;
                idToUpdate = newState[idKey];
            }
            /** @type {?} */
            var merged = tslib_1.__assign({}, oldEntity, newState);
            if (isPlainObject(oldEntity)) {
                newEntity = merged;
            }
            else {
                /**
                 * In case that new state is class of it's own, there's
                 * a possibility that it will be different than the old
                 * class.
                 * For example, Old state is an instance of animal class
                 * and new state is instance of person class.
                 * To avoid run over new person class with the old animal
                 * class we check if the new state is a class of it's own.
                 * If so, use it. Otherwise, use the old state class
                 */
                if (isPlainObject(newState)) {
                    newEntity = new ((/** @type {?} */ (oldEntity))).constructor(merged);
                }
                else {
                    newEntity = new ((/** @type {?} */ (newState))).constructor(merged);
                }
            }
            updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ids_1_1 && !ids_1_1.done && (_b = ids_1.return)) _b.call(ids_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /** @type {?} */
    var updatedIds = state.ids;
    /** @type {?} */
    var stateEntities = state.entities;
    if (isUpdatingIdKey) {
        var _c = tslib_1.__read(ids, 1), id_1 = _c[0];
        var _d = state.entities, _e = id_1, deletedEntity = _d[_e], rest = tslib_1.__rest(_d, [typeof _e === "symbol" ? _e : _e + ""]);
        stateEntities = rest;
        updatedIds = state.ids.map((/**
         * @param {?} current
         * @return {?}
         */
        function (current) { return (current === id_1 ? idToUpdate : current); }));
    }
    return tslib_1.__assign({}, state, { entities: tslib_1.__assign({}, stateEntities, updatedEntities), ids: updatedIds });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlRW50aXRpZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvdXBkYXRlRW50aXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7O0FBWWhELE1BQU0sVUFBVSxjQUFjLENBQThCLEVBQTRGO1FBQTFGLGdCQUFLLEVBQUUsWUFBRyxFQUFFLGdCQUFLLEVBQUUsOEJBQVksRUFBRSxvQ0FBZSxFQUFFLDBCQUFVOzs7UUFDbEgsZUFBZSxHQUFHLEVBQUU7O1FBRXRCLGVBQWUsR0FBRyxLQUFLOztRQUN2QixVQUFjOztRQUVsQixLQUFpQixJQUFBLFFBQUEsaUJBQUEsR0FBRyxDQUFBLHdCQUFBLHlDQUFFO1lBQWpCLElBQU0sRUFBRSxnQkFBQTtZQUNYLGdEQUFnRDtZQUNoRCxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssRUFBRTtnQkFDM0MsU0FBUzthQUNWOztnQkFFSyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7O2dCQUNoQyxRQUFRLFNBQUE7WUFDWixJQUFJLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDNUIsUUFBUSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ25HO2lCQUFNO2dCQUNMLFFBQVEsR0FBRyxZQUFZLENBQUM7YUFDekI7O2dCQUVLLFdBQVcsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxTQUFTLENBQUMsS0FBSyxDQUFDOztnQkFDdEYsU0FBUyxTQUFHO1lBQ2hCLFVBQVUsR0FBRyxFQUFFLENBQUM7WUFFaEIsSUFBSSxXQUFXLEVBQUU7Z0JBQ2YsZUFBZSxHQUFHLElBQUksQ0FBQztnQkFDdkIsVUFBVSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM5Qjs7Z0JBRUssTUFBTSx3QkFDUCxTQUFTLEVBQ1QsUUFBUSxDQUNaO1lBRUQsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQzVCLFNBQVMsR0FBRyxNQUFNLENBQUM7YUFDcEI7aUJBQU07Z0JBQ0w7Ozs7Ozs7OzttQkFTRztnQkFDSCxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDM0IsU0FBUyxHQUFHLElBQUksQ0FBQyxtQkFBQSxTQUFTLEVBQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDeEQ7cUJBQU07b0JBQ0wsU0FBUyxHQUFHLElBQUksQ0FBQyxtQkFBQSxRQUFRLEVBQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDdkQ7YUFDRjtZQUVELGVBQWUsQ0FBQyxVQUFVLENBQUMsR0FBRyxlQUFlLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3JFOzs7Ozs7Ozs7O1FBRUcsVUFBVSxHQUFHLEtBQUssQ0FBQyxHQUFHOztRQUN0QixhQUFhLEdBQUcsS0FBSyxDQUFDLFFBQVE7SUFFbEMsSUFBSSxlQUFlLEVBQUU7UUFDYixJQUFBLDJCQUFVLEVBQVQsWUFBUztZQUNWLG1CQUFpRCxFQUEvQyxTQUFJLEVBQUosc0JBQW1CLEVBQUUsa0VBQU87UUFDcEMsYUFBYSxHQUFHLElBQUksQ0FBQztRQUNyQixVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7O1FBQUMsVUFBQSxPQUFPLElBQUksT0FBQSxDQUFDLE9BQU8sS0FBSyxJQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQXZDLENBQXVDLEVBQUMsQ0FBQztLQUNoRjtJQUVELDRCQUNLLEtBQUssSUFDUixRQUFRLHVCQUNILGFBQWEsRUFDYixlQUFlLEdBRXBCLEdBQUcsRUFBRSxVQUFVLElBQ2Y7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW50aXR5U3RhdGUsIElELCBQcmVVcGRhdGVFbnRpdHksIFVwZGF0ZVN0YXRlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgaGFzRW50aXR5IH0gZnJvbSAnLi9oYXNFbnRpdHknO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdCc7XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUVudGl0aWVzUGFyYW1zPFN0YXRlLCBFbnRpdHk+ID0ge1xuICBzdGF0ZTogU3RhdGU7XG4gIGlkczogYW55W107XG4gIGlkS2V5OiBzdHJpbmc7XG4gIG5ld1N0YXRlT3JGbjogVXBkYXRlU3RhdGVDYWxsYmFjazxFbnRpdHk+IHwgUGFydGlhbDxFbnRpdHk+IHwgUGFydGlhbDxTdGF0ZT47XG4gIHByZVVwZGF0ZUVudGl0eTogUHJlVXBkYXRlRW50aXR5PEVudGl0eT47XG4gIHByb2R1Y2VyRm47XG59O1xuXG4vLyBAaW50ZXJuYWxcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVFbnRpdGllczxTIGV4dGVuZHMgRW50aXR5U3RhdGU8RT4sIEU+KHsgc3RhdGUsIGlkcywgaWRLZXksIG5ld1N0YXRlT3JGbiwgcHJlVXBkYXRlRW50aXR5LCBwcm9kdWNlckZuIH06IFVwZGF0ZUVudGl0aWVzUGFyYW1zPFMsIEU+KSB7XG4gIGNvbnN0IHVwZGF0ZWRFbnRpdGllcyA9IHt9O1xuXG4gIGxldCBpc1VwZGF0aW5nSWRLZXkgPSBmYWxzZTtcbiAgbGV0IGlkVG9VcGRhdGU6IElEO1xuXG4gIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgLy8gaWYgdGhlIGVudGl0eSBkb2Vzbid0IGV4aXN0IGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGhhc0VudGl0eShzdGF0ZS5lbnRpdGllcywgaWQpID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkRW50aXR5ID0gc3RhdGUuZW50aXRpZXNbaWRdO1xuICAgIGxldCBuZXdTdGF0ZTtcbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZU9yRm4pKSB7XG4gICAgICBuZXdTdGF0ZSA9IGlzRnVuY3Rpb24ocHJvZHVjZXJGbikgPyBwcm9kdWNlckZuKG9sZEVudGl0eSwgbmV3U3RhdGVPckZuKSA6IG5ld1N0YXRlT3JGbihvbGRFbnRpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlT3JGbjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0lkQ2hhbmdlZCA9IG5ld1N0YXRlLmhhc093blByb3BlcnR5KGlkS2V5KSAmJiBuZXdTdGF0ZVtpZEtleV0gIT09IG9sZEVudGl0eVtpZEtleV07XG4gICAgbGV0IG5ld0VudGl0eTogRTtcbiAgICBpZFRvVXBkYXRlID0gaWQ7XG5cbiAgICBpZiAoaXNJZENoYW5nZWQpIHtcbiAgICAgIGlzVXBkYXRpbmdJZEtleSA9IHRydWU7XG4gICAgICBpZFRvVXBkYXRlID0gbmV3U3RhdGVbaWRLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAgIC4uLm9sZEVudGl0eSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0KG9sZEVudGl0eSkpIHtcbiAgICAgIG5ld0VudGl0eSA9IG1lcmdlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBJbiBjYXNlIHRoYXQgbmV3IHN0YXRlIGlzIGNsYXNzIG9mIGl0J3Mgb3duLCB0aGVyZSdzXG4gICAgICAgKiBhIHBvc3NpYmlsaXR5IHRoYXQgaXQgd2lsbCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkXG4gICAgICAgKiBjbGFzcy5cbiAgICAgICAqIEZvciBleGFtcGxlLCBPbGQgc3RhdGUgaXMgYW4gaW5zdGFuY2Ugb2YgYW5pbWFsIGNsYXNzXG4gICAgICAgKiBhbmQgbmV3IHN0YXRlIGlzIGluc3RhbmNlIG9mIHBlcnNvbiBjbGFzcy5cbiAgICAgICAqIFRvIGF2b2lkIHJ1biBvdmVyIG5ldyBwZXJzb24gY2xhc3Mgd2l0aCB0aGUgb2xkIGFuaW1hbFxuICAgICAgICogY2xhc3Mgd2UgY2hlY2sgaWYgdGhlIG5ldyBzdGF0ZSBpcyBhIGNsYXNzIG9mIGl0J3Mgb3duLlxuICAgICAgICogSWYgc28sIHVzZSBpdC4gT3RoZXJ3aXNlLCB1c2UgdGhlIG9sZCBzdGF0ZSBjbGFzc1xuICAgICAgICovXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChuZXdTdGF0ZSkpIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbmV3IChvbGRFbnRpdHkgYXMgYW55KS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbmV3IChuZXdTdGF0ZSBhcyBhbnkpLmNvbnN0cnVjdG9yKG1lcmdlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlZEVudGl0aWVzW2lkVG9VcGRhdGVdID0gcHJlVXBkYXRlRW50aXR5KG9sZEVudGl0eSwgbmV3RW50aXR5KTtcbiAgfVxuXG4gIGxldCB1cGRhdGVkSWRzID0gc3RhdGUuaWRzO1xuICBsZXQgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuXG4gIGlmIChpc1VwZGF0aW5nSWRLZXkpIHtcbiAgICBjb25zdCBbaWRdID0gaWRzO1xuICAgIGNvbnN0IHsgW2lkXTogZGVsZXRlZEVudGl0eSwgLi4ucmVzdCB9ID0gc3RhdGUuZW50aXRpZXM7XG4gICAgc3RhdGVFbnRpdGllcyA9IHJlc3Q7XG4gICAgdXBkYXRlZElkcyA9IHN0YXRlLmlkcy5tYXAoY3VycmVudCA9PiAoY3VycmVudCA9PT0gaWQgPyBpZFRvVXBkYXRlIDogY3VycmVudCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlbnRpdGllczoge1xuICAgICAgLi4uc3RhdGVFbnRpdGllcyxcbiAgICAgIC4uLnVwZGF0ZWRFbnRpdGllc1xuICAgIH0sXG4gICAgaWRzOiB1cGRhdGVkSWRzXG4gIH07XG59XG4iXX0=