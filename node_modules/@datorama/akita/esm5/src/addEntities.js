/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { hasEntity } from './hasEntity';
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
export function addEntities(_a) {
    var state = _a.state, entities = _a.entities, idKey = _a.idKey, _b = _a.options, options = _b === void 0 ? {} : _b, preAddEntity = _a.preAddEntity;
    var e_1, _c;
    /** @type {?} */
    var newEntities = {};
    /** @type {?} */
    var newIds = [];
    /** @type {?} */
    var hasNewEntities = false;
    try {
        for (var entities_1 = tslib_1.__values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
            var entity = entities_1_1.value;
            if (hasEntity(state.entities, entity[idKey]) === false) {
                // evaluate the middleware first to support dynamic ids
                /** @type {?} */
                var current = preAddEntity(entity);
                /** @type {?} */
                var entityId = current[idKey];
                newEntities[entityId] = current;
                if (options.prepend)
                    newIds.unshift(entityId);
                else
                    newIds.push(entityId);
                hasNewEntities = true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entities_1_1 && !entities_1_1.done && (_c = entities_1.return)) _c.call(entities_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return hasNewEntities
        ? {
            newState: tslib_1.__assign({}, state, { entities: tslib_1.__assign({}, state.entities, newEntities), ids: options.prepend ? tslib_1.__spread(newIds, state.ids) : tslib_1.__spread(state.ids, newIds) }),
            newIds: newIds
        }
        : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkRW50aXRpZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvYWRkRW50aXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7Ozs7O0FBYXhDLE1BQU0sVUFBVSxXQUFXLENBQThCLEVBQStFO1FBQTdFLGdCQUFLLEVBQUUsc0JBQVEsRUFBRSxnQkFBSyxFQUFFLGVBQVksRUFBWixpQ0FBWSxFQUFFLDhCQUFZOzs7UUFDdkcsV0FBVyxHQUFHLEVBQUU7O1FBQ2hCLE1BQU0sR0FBRyxFQUFFOztRQUNYLGNBQWMsR0FBRyxLQUFLOztRQUUxQixLQUFxQixJQUFBLGFBQUEsaUJBQUEsUUFBUSxDQUFBLGtDQUFBLHdEQUFFO1lBQTFCLElBQU0sTUFBTSxxQkFBQTtZQUNmLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFOzs7b0JBRWhELE9BQU8sR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDOztvQkFDOUIsUUFBUSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7Z0JBQy9CLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxPQUFPLENBQUM7Z0JBQ2hDLElBQUksT0FBTyxDQUFDLE9BQU87b0JBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7b0JBQ3pDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRTNCLGNBQWMsR0FBRyxJQUFJLENBQUM7YUFDdkI7U0FDRjs7Ozs7Ozs7O0lBRUQsT0FBTyxjQUFjO1FBQ25CLENBQUMsQ0FBQztZQUNFLFFBQVEsdUJBQ0gsS0FBSyxJQUNSLFFBQVEsdUJBQ0gsS0FBSyxDQUFDLFFBQVEsRUFDZCxXQUFXLEdBRWhCLEdBQUcsRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsa0JBQUssTUFBTSxFQUFLLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBSyxLQUFLLENBQUMsR0FBRyxFQUFLLE1BQU0sQ0FBQyxHQUM3RTtZQUNELE1BQU0sUUFBQTtTQUNQO1FBQ0gsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNYLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdHlTdGF0ZSwgUHJlQWRkRW50aXR5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBoYXNFbnRpdHkgfSBmcm9tICcuL2hhc0VudGl0eSc7XG5cbmV4cG9ydCB0eXBlIEFkZEVudGl0aWVzUGFyYW1zPFN0YXRlLCBFbnRpdHk+ID0ge1xuICBzdGF0ZTogU3RhdGU7XG4gIGVudGl0aWVzOiBFbnRpdHlbXTtcbiAgaWRLZXk6IHN0cmluZztcbiAgb3B0aW9uczogQWRkRW50aXRpZXNPcHRpb25zO1xuICBwcmVBZGRFbnRpdHk6IFByZUFkZEVudGl0eTxFbnRpdHk+O1xufTtcblxuZXhwb3J0IHR5cGUgQWRkRW50aXRpZXNPcHRpb25zID0geyBwcmVwZW5kPzogYm9vbGVhbjsgbG9hZGluZz86IGJvb2xlYW4gfTtcblxuLy8gQGludGVybmFsXG5leHBvcnQgZnVuY3Rpb24gYWRkRW50aXRpZXM8UyBleHRlbmRzIEVudGl0eVN0YXRlPEU+LCBFPih7IHN0YXRlLCBlbnRpdGllcywgaWRLZXksIG9wdGlvbnMgPSB7fSwgcHJlQWRkRW50aXR5IH06IEFkZEVudGl0aWVzUGFyYW1zPFMsIEU+KSB7XG4gIGxldCBuZXdFbnRpdGllcyA9IHt9O1xuICBsZXQgbmV3SWRzID0gW107XG4gIGxldCBoYXNOZXdFbnRpdGllcyA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgaWYgKGhhc0VudGl0eShzdGF0ZS5lbnRpdGllcywgZW50aXR5W2lkS2V5XSkgPT09IGZhbHNlKSB7XG4gICAgICAvLyBldmFsdWF0ZSB0aGUgbWlkZGxld2FyZSBmaXJzdCB0byBzdXBwb3J0IGR5bmFtaWMgaWRzXG4gICAgICBjb25zdCBjdXJyZW50ID0gcHJlQWRkRW50aXR5KGVudGl0eSk7XG4gICAgICBjb25zdCBlbnRpdHlJZCA9IGN1cnJlbnRbaWRLZXldO1xuICAgICAgbmV3RW50aXRpZXNbZW50aXR5SWRdID0gY3VycmVudDtcbiAgICAgIGlmIChvcHRpb25zLnByZXBlbmQpIG5ld0lkcy51bnNoaWZ0KGVudGl0eUlkKTtcbiAgICAgIGVsc2UgbmV3SWRzLnB1c2goZW50aXR5SWQpO1xuXG4gICAgICBoYXNOZXdFbnRpdGllcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc05ld0VudGl0aWVzXG4gICAgPyB7XG4gICAgICAgIG5ld1N0YXRlOiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmVudGl0aWVzLFxuICAgICAgICAgICAgLi4ubmV3RW50aXRpZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkczogb3B0aW9ucy5wcmVwZW5kID8gWy4uLm5ld0lkcywgLi4uc3RhdGUuaWRzXSA6IFsuLi5zdGF0ZS5pZHMsIC4uLm5ld0lkc11cbiAgICAgICAgfSxcbiAgICAgICAgbmV3SWRzXG4gICAgICB9XG4gICAgOiBudWxsO1xufVxuIl19